[{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1652536515,"objectID":"8e92482d9e3b129fafbe928eb75c989f","permalink":"https://www.romainthomas.fr/projects-images/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/projects-images/","section":"projects-images","summary":"","tags":null,"title":"","type":"projects-images"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1652536515,"objectID":"1b7f62207d2617f7491785ce1c71e57f","permalink":"https://www.romainthomas.fr/project/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/","section":"project","summary":"","tags":null,"title":"","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1652536515,"objectID":"3a079e7dad19be978a318345a7749d34","permalink":"https://www.romainthomas.fr/publication/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/publication/","section":"publication","summary":"","tags":null,"title":"Publications","type":"publication"},{"authors":null,"categories":null,"content":"","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"c4d1f293f132915949efd449efcf67f2","permalink":"https://www.romainthomas.fr/home/work-experience/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/home/work-experience/","section":"home","summary":"","tags":null,"title":"Work Experience","type":"home"},{"authors":["Romain Thomas"],"categories":null,"content":" Slides   Whitepaper   Talk at BlackHat (English) To be published\n Talk at SSTIC (French)   Assets https://github.com/romainthomas/droidguard-samples\n","date":1652313600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652725184,"objectID":"a397c974a6d1b005221a034db12e5318","permalink":"https://www.romainthomas.fr/publication/22-sstic-blackhat-droidguard-safetynet/","publishdate":"2022-05-12T00:00:00Z","relpermalink":"/publication/22-sstic-blackhat-droidguard-safetynet/","section":"publication","summary":"SafetyNet is the Android component developed by Google to verify the devices' integrity. These checks are used by the developers to prevent running applications on devices that would not meet security requirements but it is also used by Google to prevent bots, fraud \u0026 abuse. In 2017, Collin Mulliner \u0026 John Kozyrakis made one of the first public presentations about SafetyNet and a glimpse into the internal mechanisms. Since then, the Google anti-abuse team improved the strength of the solution which moved most of the original Java layer of SafetyNet, into a native module called DroidGuard. This module implements a custom virtual machine that runs a proprietary bytecode provided by Google to perform the devices integrity checks. This paper aims at providing a state-of-the-art of the current implementation of SafetyNet. In particular, it presents the internal mechanisms behind SafetyNet and the DroidGuard module. This includes an overview of the VM design, its internal mechanisms, and the security checks performed by SafetyNet to detect Magisk, emulators, rooted devices, and even Pegasus. ","tags":null,"title":"DroidGuard: A Deep Dive into SafetyNet","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":"This is a PoC that shows basic integrity bypass without MagiskHide by modifying the execution of DroidGuard.\n Here are, for instance, some modules detected by DroidGuard:\n1frida-agent-32.so 2frida-agent-64.so 3libarthook_native.so 4libfrida-gadget.so 5libmemtrack_real.so 6librfbinder-cpp.so 7libriru_edxp.so 8libriru_edxposed.so 9libriru_snet-tweak-riru.so 10libsandhook-native.so 11libsandhook.edxp.so 12libsandhook.so 13libva++.so 14libva-native.so 15libwhale.edxp.so 16libxposed_art.so ","date":1636588800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"3d97e95959a856a1820124b28b93b190","permalink":"https://www.romainthomas.fr/projects-images/safetynet/","publishdate":"2021-11-11T00:00:00Z","relpermalink":"/projects-images/safetynet/","section":"projects-images","summary":"DroidGuard / Safetynet bypass","tags":["Android","Reverse"],"title":"DroidGuard","type":"projects-images"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" .green { color:green; font-family: 'Fira Code', monospace; } .blue { color: blue; font-family: 'Fira Code', monospace; } .orange { color: #FF6347; font-family: 'Fira Code', monospace; } .red { color: #c02032; font-family: 'Fira Code', monospace; } a.ul { color: #c02032 !important; } .hl-comment { color: #df2b04; font-family: 'Fira Code', monospace; } .hl-keyword { color: #A90D91; font-family: 'Fira Code', monospace; } .hl-literal { color: #1C01CE; font-family: 'Fira Code', monospace; } .hl-preproc { color: #633820; font-family: 'Fira Code', monospace; } .hl-strings { color: #C41A16; font-family: 'Fira Code', monospace; } .yellow { color: #CC7000; font-family: 'Fira Code', monospace; }  Introduction A few days after the release of the blog post Gotta Catch \u0026lsquo;Em All: Frida \u0026amp; jailbreak detection, someone on reddit - r/ReverseEngineering caught my attention on a cheating app for the Android version of PokemonGO:\nSo here it is!\nPGSharp belongs to the family of PokemonGO\u0026rsquo;s cheating app that is not (yet) banned by Niantic. This cheat provides an enhanced game experience with interesting functionalities such as:\n GPS Spoofing Quick Catch Pokemon Feed Nearby Radar \u0026hellip;  Last but not least, PGSharp runs on regular devices, rooted or not.\nThis cheat made my weekends for the last 4 months and, from a technical point of view, it was worth it. As will be discussed through this blog post, PGSharp uses several interesting tricks.\n    Note The content of this blog post is based on PGSharp 1.33.0 which is related to the following APKs:\nÂ PGSharp v1.33.0\nÂ PokemonGO v0.221.0\n    This blog post is quite long but the different parts are more or less independents, so feel free to jump on them depending on your interests:\n\n Â Code Protection  Lua VM Java Obfuscation   Â Cheat Mechanisms  DEX Files Comparison libmain.so Signature Bypass Dynamic APK Loading GPS Spoofing JNIEnv Proxifier Unity Hooks Network Communications SafetyNet When PGSharp avoids PokemonGO pitfalls   Â Final Words Â Acknowledgments Â Annexes  You can also check the slides to get an overview of the content:\n  Enjoy!\n Â Code Protection PokemonGO is a target of choice for reverse engineers and some critical functionalities are protected by a commercial solution. It is worth mentioning that only a subset of the game is obfuscated. For instance, the \u0026ldquo;Java\u0026rdquo; part of the game is absolutely not protected, such as we have the original class and method names. The Unity part is \u0026ldquo;compiled\u0026rdquo; into libil2cpp.so but we can recover some metadata with Perfare/Il2CppDumper.\nAll the obfuscation is focused on libNianticLabsPlugin.so (c.f. Gotta Catch \u0026lsquo;Em All: Frida \u0026amp; jailbreak detection), and since only this part of the game is heavily obfuscated, it gives a hint about where the critical functionalities are.\nOn the other hand, PGSharp uses different layers of obfuscation to prevent its analysis. First of all, it uses O-LLVM to obfuscate the native code that includes, at least, control-flow flattening and string encryption. Nevertheless, the obfuscation is relatively weak against emulation and static analysis1.\nÂ Lua VM Some obfuscation techniques are based on transforming the original code through a VM (like VMProtect). It adds another layer to reverse, as we need to understand the VM architecture before being able to understand the original semantic of the code.\n  But what about using an interpreted language (like Python) and obfuscate its VM or its interpreter with O-LLVM? \n This is what PGSharp does with Lua. Some parts of the cheat are written in Lua whose VM has been modified to:\n Fake the version: try to make believe Lua 5.1 while it\u0026rsquo;s Lua 5.3 Add new opcodes (OP_RUN, OP_GETDOWNVAL, OP_OLDTABLE, and OP_XXOR) to break decompilation and common Lua tools.  The native library that implements the cheat functionalities and that contains the Lua VM being stripped, one of the challenges lies in recognizing the Lua C API among the library\u0026rsquo;s functions2. For instance, here is a basic block of a native function that uses the Lua API:\nAmong all the Lua C functions, some of them are worth identifying to ease reverse engineering:\n   luaL_loadbuffer  \u0026ldquo;Load a buffer as a Lua chunk.\u0026rdquo;.\n   Basically, it loads a Lua bytecode from a buffer given in parameter. This Lua bytecode is the result of the compilation of the original script with luac. By hooking this function, we can recover the following files:\n base64.luac class.luac global.luac init.luac json.luac - from https://github.com/rxi/json.lua location.luac md5.luac - from https://github.com/kikito/md5.lua pgo.luac pgodump.luac plugin.luac reflect.luac    The orange files are utilities, while the green ones contain cheat mechanisms.\n   luaD_precall Function that is involved when calling a C native function or a pure Lua function. Since its prototype is (lua_State *L, StkId func, int nresults), it can help to dynamically identify which function is called:  10x6776a8 luaD_precall(\u0026#39;gamehelper\u0026#39;) 20x6776a8 luaD_precall(\u0026#39;@./app/arm64-v8a/luac/global.lua:0 - sub_71733ea5d0\u0026#39;) { 30x694d90 luaD_precall(\u0026#39;@./app/arm64-v8a/luac/global.lua:246 - sub_71733f7b50\u0026#39;) { 40x6776a8 luaD_precall(\u0026#39;@./app/arm64-v8a/luac/location.lua:38 - sub_717346d650\u0026#39;) {    lua_pushcclosure  Pushes a new C closure onto the stack.\n   This function is particularly interesting to recover native C functions linked to Lua function:\n  10x0e9cc0: lua_pushcclosure(\u0026#39;initil2cppmethods\u0026#39;) 20x0e9cd4: lua_setfield(-2, \u0026#39;initil2cppmethods\u0026#39;, \u0026#39;func_0xedaa0\u0026#39;) 3... 40x0e9d10: lua_pushcclosure(\u0026#39;nar\u0026#39;) 50x0e9d24: lua_setfield(-2, \u0026#39;nar\u0026#39;, \u0026#39;func_0xeddbc\u0026#39;) 6... 70x0ea020: lua_pushcclosure(\u0026#39;ipf\u0026#39;) 80x0ea034: lua_setfield(-2, \u0026#39;ipf\u0026#39;, \u0026#39;func_0x1318b0\u0026#39;)    lua_pushstring  \u0026ldquo;Pushes the zero-terminated string pointed to by s onto the stack.\u0026rdquo;\n   This function enables to dynamically recover strings that might not be present in the native code or somehow encoded:\n10x0ebdfc: lua_pushstring(\u0026#39;https://tens.pgsharp.com/v1/scc-2-[...]/\u0026#39;) 20x0ebe28: lua_pushstring(\u0026#39;me.uw.hela.pref\u0026#39;) 30x0c56ac: lua_pushstring(\u0026#39;AIza[...]XhM4\u0026#39;) 40x0e15b4: lua_pushstring(\u0026#39;token=[Redacted]\u0026#39;)     To dynamically understand the behavior of the Lua VM, we can compile the Frida Gum SDK along with Lua v5.3.\nIt enables to hook Lua functions with Frida and to leverage the compiled Lua v5.3 to inspect the parameters:\n1extern \u0026#34;C\u0026#34; { 2#include \u0026#34;lua.h\u0026#34;3#include \u0026#34;ldo.h\u0026#34;4#include \u0026#34;ldebug.h\u0026#34;5} 6 7gum_interceptor_attach(listener_-\u0026gt;interceptor, 8 luaD_precall_addr, listener_ luaD_precall_addr); 9 10void native_listener_on_enter(GumInvocationListener *listener, GumInvocationContext* ic) { 11 auto* L = reinterpret_cast\u0026lt;lua_State*\u0026gt;(ic-\u0026gt;cpu_context-\u0026gt;x[0]); 12 auto func = reinterpret_cast\u0026lt;StkId\u0026gt;(ic-\u0026gt;cpu_context-\u0026gt;x[1]); 13 auto narg = static_cast\u0026lt;int\u0026gt;(ic-\u0026gt;cpu_context-\u0026gt;x[2]); 14 if (ttype(func) != LUA_TLCL) { 15 return log(\u0026#34;sub_{:x}\u0026#34;, ptr); 16 } 17 Proto *p = clLvalue(func)-\u0026gt;p; 18 return log(\u0026#34;{}:{:d} - sub_{:x}\u0026#34;, getstr(p-\u0026gt;source), p-\u0026gt;linedefined, ptr); 19}   Â Java Obfuscation Contrary to the PokemonGO\u0026rsquo;s Java layer, PGSharp protects its Java code with Proguard and the strings are xored with the hardcoded key:\n vqGqQWCVnDRrNXTR\n This key seems to not change across the different versions of PGSharp and the encoded strings look like this:\n1public void q() { 2 String a = GL.a(r3.a(\u0026#34;FAQgLiQlLw==\u0026#34;), (String) null); 3 if (a != null) { 4 JSONObject jSONObject = new JSONObject(); 5 Context context = GL.c; 6 jSONObject.put(r3.a(\u0026#34;Agg3FA==\u0026#34;), r3.a(\u0026#34;Axg=\u0026#34;)); 7 jSONObject.put(r3.a(\u0026#34;Axgj\u0026#34;), UI.g(context)); 8 jSONObject.put(r3.a(\u0026#34;BQUmBTQ=\u0026#34;), this.s); 9 jSONObject.put(r3.a(\u0026#34;BQEoHjc+LTE=\u0026#34;), ((Boolean) ...); 10 jSONObject.put(r3.a(\u0026#34;BAUr\u0026#34;), UI.f()); 11 jSONObject.put(r3.a(\u0026#34;Gh8g\u0026#34;), Locale.getDefault().getDisplayLanguage()); 12 jSONObject.put(r3.a(\u0026#34;FxMu\u0026#34;), UI.a()); 13 jSONObject.put(r3.a(\u0026#34;FBA1\u0026#34;), LayoutInflater$Factory2o.i.e(context)); 14 jSONObject.put(r3.a(\u0026#34;Gx4j\u0026#34;), Build.MODEL); 15 String str = Build.VERSION.RELEASE; 16 } 17} The string encoding routine being easy to reverse, we can create a Jadx plugin that automatically decodes these strings:\n1[...] 2passes.add(new SimplifyVisitor()); 3 4passes.add(new PGSharpString()); // Automatically decode the strings 5 6passes.add(new CheckRegions()); 7[...] It results in this kind of output:\n1public void q() { 2 String a = GL.a(\u0026#34;bug_url\u0026#34;, (String) null); 3 if (a != null) { 4 JSONObject jSONObject = new JSONObject(); 5 Context context = GL.c; 6 jSONObject.put(\u0026#34;type\u0026#34;, \u0026#34;ui\u0026#34;); 7 jSONObject.put(\u0026#34;uid\u0026#34;, UI.g(context)); 8 jSONObject.put(\u0026#34;state\u0026#34;, this.s); 9 jSONObject.put(\u0026#34;spoofing\u0026#34;, ((Boolean) PL.a(\u0026#34;hlspoofing\u0026#34;)).booleanValue()); 10 jSONObject.put(\u0026#34;rtl\u0026#34;, UI.f()); 11 jSONObject.put(\u0026#34;lng\u0026#34;, Locale.getDefault().getDisplayLanguage()); 12 jSONObject.put(\u0026#34;abi\u0026#34;, UI.a()); 13 jSONObject.put(\u0026#34;bar\u0026#34;, LayoutInflater$Factory2o.i.e(context)); 14 jSONObject.put(\u0026#34;mod\u0026#34;, Build.MODEL); 15 String str = Build.VERSION.RELEASE; 16 } 17} You can find the whole Jadx plugin on Github: PGSharpStrings.java\nÂ Cheat Mechanisms One disruptive feature of PGSharp is that it does not require a rooted device. Until recently, most of the PokemonGO cheating apps required a jailbroken or a rooted device which raises a barrier for people who are not familiar with rooting.\n But wait, how hell they do that?\n The structure of the PGSharp APK is very close to the genuine PokemonGO application, which leads identifying which parts of the game have been tampered with.\nA naive comparison (cf. zip_diff.py) raises mismatches on the following files:\n   File Size in PGSharp Size in PGO Delta     classes.dex 9057844 8953000 +1.17%   classes2.dex 7131864 7107296 +0.34%   lib/arm64-v8a/libmain.so 21278480 6424 +331134%   META-INF/MANIFEST.MF 351045 355533 -1.26%    The high level of similarity between the two applications, associated with a different signature confirms that PGSharp repackaged the original application.\nÂ DEX Files Comparison To figure out which parts of the DEX files have been modified, we can use LIEF (yes, LIEF can read the DEX format). Basically, the idea is to check which method(s) has a bytecode whose size is different from the real PokemonGO application:\n1import zipfile 2import lief 3 4with zipfile.ZipFile(CHEAT_FILE) as zip_file: 5 with zip_file.open(target) as f: 6 hela_dex = f.read() 7 8 9with zipfile.ZipFile(ORIG_FILE) as zip_file: 10 with zip_file.open(target) as f: 11 pgo_dex = f.read() 12 13hela_dex = lief.DEX.parse(list(hela_dex)) 14pgo_dex = lief.DEX.parse(list(pgo_dex)) 15 16hela = {f\u0026#34;{m.cls.pretty_name}.{m.name}.{m.prototype!s}\u0026#34;: len(m.bytecode) \\ 17 for m in hela_dex.methods} 18 19pgo = {f\u0026#34;{m.cls.pretty_name}.{m.name}.{m.prototype!s}\u0026#34;: len(m.bytecode) \\ 20 for m in pgo_dex.methods} 21 22for k, size_hela in hela.items(): 23 size_pgo = pgo[k] 24 if size_pgo != size_hela: 25 print(f\u0026#34;Mismatch: {k}\u0026#34;) By running this script on classes.dex, we don\u0026rsquo;t find any difference. Actually, the PGSharp authors tried to prevent diffing by changing the line number attribute of the DEX classes. If we try to diff the two applications from the output of apktool or Jadx, we get a lot of noise as the line number is used in the output. On the other hand, the size bytecode for this kind of repackaging is suitable3.\nRunning the same script on classes2.dex raises the following mismatches:\n holoholo.libholoholo.unity.UnityMainActivity.onActivityResult holoholo.nativelib.Library.\u0026lt;clinit\u0026gt;  In UnityMainActivity.onActivityResult, they changed this piece of code:\n1public void onActivityResult(int i, int i2, Intent intent) { 2 UnityCallbackInfo unityCallbackInfo = this.activityCallbacks.get(Integer.valueOf(i)); 3 if (unityCallbackInfo != null) { 4 UnityPlayer.UnitySendMessage(unityCallbackInfo.mGameObjectName, 5 unityCallbackInfo.mMethodName, 6 String.valueOf(i2)); 7 } else { 8 Client.handleActivityResult(i, intent); 9 } 10} into:\n1public void onActivityResult(int i, int i2, Intent intent) { 2 UnityCallbackInfo unityCallbackInfo = this.activityCallbacks.get(Integer.valueOf(i)); 3 if (unityCallbackInfo != null) { 4 String mGameObjectName = unityCallbackInfo.mGameObjectName; 5 UnityPlayer.UnitySendMessage(mGameObjectName, unityCallbackInfo.mMethodName, \u0026#34;HL.PL\u0026#34;.equals(mGameObjectName) ? intent == null ? \u0026#34;\u0026#34; : intent.getData().toString() : String.valueOf(i2)); 6 return; 7 } 8 Client.handleActivityResult(i, intent); 9} While in the static constructor of the Library class, they force the loading of libmain.so:\n1static { 2 System.loadLibrary(\u0026#34;main\u0026#34;); 3 System.loadLibrary(\u0026#34;holoholo\u0026#34;); 4} Now, let\u0026rsquo;s look at libmain.so\nÂ libmain.so Compared to the original PokemonGO APK, libmain.so in PGSharp is substantially larger. Moreover, the ELF metadata leaks the original file name of the file:\n1$ readelf -d libmain.so 2... 30x000000000000000e (SONAME) Library soname: [libhela.so] 4... During the analysis of PGSharp, we find references to Hela in different places, like the package name of the dynamically-loaded APK: me.underworld.helaplugin.\nOriginally, the purpose of this library is to initialize some parts of the Unity engine but PGSharp uses it to load its main payload.\nIn the cheating app, libmain.so is responsible for:\n Initializing the Lua VM Implementing Lua native C functions Implementing JNI functions Calling the Lua scripts  libmain.so exposes JNI_OnLoad which is used as an entrypoint to perform the actions listed above.\nThe JNI functions don\u0026rsquo;t have a meaningful name but thanks to their callsites, we can figure out their purpose:\n   Name Description Rename     NRL Trigger Lua function from Java NativeRunLua   NSMTC Trigger PGSharp Action -   NOHRB OkHtttp callback NativeOkHttpResponseByte   NOHR OkHtttp callback NativeOkHttpResponse   NOHF OkHtttp callback NativeOkHttpFailure   NIOS Google Signing? -   NIOR Seems not used -   NOT Perform periodic actions on Lua threads NativeOnTimer   NIPE Related to PokemonGO Plus -   NIOF Seems to do nothing relevant -    Similarly, for the Lua C closures, we get the following table:\n   Name Description Rename     callpgo Trigger Lua function from Java -   add_unity_task Trigger PGSharp Action -   initil2cppbase OkHtttp callback -   initil2cpphooks OkHtttp callback -   initil2cppmethods OkHtttp callback -   newjbytearray Create a Java bytearray from Lua -   nar - nativeAttestResponse   ngak - nativeGetApiKey   findclass Find a Java class from Lua -   gettid Get Thread ID -   logi Log info (empty) -   logv Log verbose (empty) -   init_plugin_natives Init Java layer (JNI + nUSlwbRIjReLowOP) -   uf_whitelist empty -   uf_forbid empty -   uf_redirect empty -   fkinitjni Lua wrapper4 FakeInitJNI   fknalp Lua wrapper4 FakeNativeAddLocationProvider   fkngsu Lua wrapper4 FakeNativeGpsStatusUpdate   fknlu Lua wrapper4 FakeNativeLocationUpdate   getPoisFromCache Related to the autowalk feature -    \u0026nbsp;\u0026nbsp;NRL Actions    Action Event Task     1 plg.float.click   2 plg.float.remove   3 plg.map.tp   4 plg.setspeed   5 plg.randomwalk   6 plg.enablespoof   7 plg.joystart   8 plg.joystop   9 plg.entergame   10 plg.pause        Long story short, PGSharp repackages the PokemonGO application and implements its payload in libmain.so   But wait, since they repackage the application they have to re-sign the application and you won\u0026rsquo;t tell me that PokemonGO does have signature checks?\n  And this is where the fun begins!\n The functionalities of PGSharp heavily rely on hooking but not the hooking you might think of \u0026hellip;\nÂ Signature Bypass As it is detailed in the next section, libmain.so dynamically loads another APK. Within this APK, and more precisely in the class androidx.appcompat.app.AppCompatDelegateImpl5, we can notice this method:\n1/* renamed from: g */ 2public static void proxifySignatureCheck(Context context) { 3 String packageName = context.getPackageName(); 4 Class\u0026lt;?\u0026gt; aThreadCls = Class.forName(\u0026#34;android.app.ActivityThread\u0026#34;); 5 Object mCurrentActivityThread = aThreadCls.getDeclaredMethod(\u0026#34;currentActivityThread\u0026#34;, new Class[0]).invoke(null, new Object[0]); 6 7 Field sPackageManager = aThreadCls.getDeclaredField(\u0026#34;sPackageManager\u0026#34;); 8 sPackageManager.setAccessible(true); 9 10 Object pm = sPackageManager.get(mCurrentActivityThread); 11 Class\u0026lt;?\u0026gt; IPackageManager = Class.forName(\u0026#34;android.content.pm.IPackageManager\u0026#34;); 12 SignatureMock mock = new SignatureMock(pm, \u0026#34;30820 [ ... ] aa001f55\u0026#34;, packageName) 13 Object newProxyInstance = Proxy.newProxyInstance(IPackageManager.getClassLoader(), 14 new Class[]{IPackageManager}, mock); 15 sPackageManager.set(mCurrentActivityThread, newProxyInstance); 16 PackageManager packageManager = context.getPackageManager(); 17 Field mPM = packageManager.getClass().getDeclaredField(\u0026#34;mPM\u0026#34;); 18 mPM.setAccessible(true); 19 mPM.set(packageManager, newProxyInstance); 20} This code leverages the Java hooking API, java.lang.reflect.Proxy, to proxify the Android PackageManager Â¯\\_(ãƒ„)_/Â¯.\nThe mocked PackageManager looks like this:\n1public SignatureMock(Object pm, String originalSignature, String packageName) { 2 this.mPackageManager = pm; 3 this.mOriginalSignature = originalSignature; 4 this.mPackageName = packageName; 5} 6@Override // java.lang.reflect.InvocationHandler 7public Object invoke(Object obj, Method inMeth, Object[] args) { 8 PackageInfo packageInfo; 9 SigningInfo signingInfo; 10 // Hook getPackageInfo 11 if (\u0026#34;getPackageInfo\u0026#34;.equals(inMeth.getName())) { 12 String pkgName = (String) args[0]; 13 int flags = ((Integer) args[1]).intValue(); 14 // Handle both 15 // GET_SIGNATURES (0x00000040) - Deprecated in API 28 16 // GET_SIGNING_CERTIFICATES (0x08000000) 17 if ((flags \u0026amp; PackageManager.GET_SIGNATURES) != 0 \u0026amp;\u0026amp; 18 this.mPackageName.equals(pkgName)) { 19 PackageInfo fakePkgInfo = (PackageInfo) inMeth.invoke(this.mPackageManager, args); 20 // Fake the signature 21 fakePkgInfo.signatures[0] = new Signature(this.mOriginalSignature); 22 return fakePkgInfo; 23 } else if (Build.VERSION.SDK_INT \u0026gt;= 28 \u0026amp;\u0026amp; 24 (flags \u0026amp; GET_SIGNING_CERTIFICATES) != 0 \u0026amp;\u0026amp; 25 this.mPackageName.equals(pkgName) \u0026amp;\u0026amp; 26 (signingInfo = (packageInfo = (PackageInfo) method.invoke(this.mPackageManager, args)).signingInfo) != null) { 27 Field FieldSigningDetails = signingInfo.getClass().getDeclaredField(\u0026#34;mSigningDetails\u0026#34;); 28 FieldSigningDetails.setAccessible(true); 29 Object mSigningDetails = FieldSigningD.get(packageInfo); 30 Signature[] fakeSigArray = {new Signature(this.mOriginalSignature)}; 31 Field FieldSignatures = mSigningDetails.getClass().getDeclaredField(\u0026#34;signatures\u0026#34;); 32 FieldSignatures.setAccessible(true); 33 FieldSignatures.set(FieldSigningDetails, fakeSigArray); 34 return packageInfo; 35 } 36 } 37 return inMeth.invoke(this.mPackageManager, args); 38} In doing so, when PokemonGO accesses the PackageManager, it gets a mocked version of the PackageManager that is controlled by PGSharp. PGSharp changes the behavior of getPackageInfo() to return the real PokemonGO signature instead of its own.\nThe following figure outlines the process:\nÂ Dynamic APK Loading In the Lua script plugin.lua, PGSharp defines an init function that performs the following actions:\n1local filesdir = (ref.call_method)(runtime.app, \u0026#34;getFilesDir\u0026#34;, \u0026#34;()Ljava/io/File;\u0026#34;) 2local filesdirpath = (ref.call_method)(filesdir, \u0026#34;getAbsolutePath\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;) 3u_plugin_path = (gh.ipf)(loadjstring(filesdirpath)) ipf is a function that takes the output of cxt.getFilesDir().getAbsolutePath() as parameter, in other words, the path of the files directory of PokemonGO: /data/data/com.nianticlabs.pokemongo/files, and returns a u_plugin_path as a Lua string.\nIf we look for ipf in the Lua scripts, we don\u0026rsquo;t find any implementation. Actually, this function is referenced in the gamehelper() function of libmain.so where it is linked as follows:\nSo ipf is a native Lua C function registered with lua_pushcclosure.\nOnce we identified the location of ipf, the logic of the function can be summarized with this pseudo code:\n1// file_dir: /data/user/0/com.nianticlabs.pokemongo/files 2void ipf(lua_State *L) { 3 // std::string ctor @0xA4F00 4 std::string outpath = lua_tostring(L, -1); 5 // std::string::append @0xD868C 6 outpath.append(\u0026#34;/\u0026#34;); 7 outpath.append(\u0026#34;LZZqoKpt.plg\u0026#34;); 8 9 FILE* fout = fopen(outpath.c_str(), \u0026#34;wb\u0026#34;); 10 11 // @0x634424 12 extract_apk_file(FILE* fout) { 13 for (chunk : chunks) { 14 decode(chunk, 0x2710); 15 fwrite(chunk, 0x2710, 1, fout); 16 } 17 } 18 fclose(fout); 19 lua_pushlstring(L, outpath.c_str(), outpath.size()); 20} 21 22void inline_decode(uint8_t* data, size_t size) { 23 for (size_t i = 0; i \u0026lt; size; ++i) { 24 // Byte decoding 25 data[i] = (0xb3 \u0026amp; ~data[i]) | (data[i] \u0026amp; 0x4c) 26 } 27} Since the decoded file is written in the /data partition, one can also pull the file from the device (this file is not removed when PGSharp stops running).  The written file, LZZqoKpt.plg, is actually an APK that is loaded with PathClassLoader in the Lua script:\n1u_classloader = (ref.new_instance)(\u0026#34;dalvik/system/PathClassLoader\u0026#34;, 2 \u0026#34;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V\u0026#34;, 3 (env.NewStringUTF)(u_plugin_path), 4 nativeLibraryDir, 5 gh.pgo_classloader); \u0026nbsp;\u0026nbsp;Rest of the function 1u_plugin_cls = findclass(\u0026#34;me/underworld/helaplugin/PL\u0026#34;, u_classloader) 2u_global_cls = findclass(\u0026#34;me/underworld/helaplugin/GL\u0026#34;, u_classloader) 3u_runnable_cls = findclass(\u0026#34;me/underworld/helaplugin/HR\u0026#34;, u_classloader) 4 5u_global_cls = (env.NewGlobalRef)(u_global_cls) 6u_plugin_cls = (env.NewGlobalRef)(u_plugin_cls) 7u_classloader = (env.NewGlobalRef)(u_classloader) 8u_runnable_cls = (env.NewGlobalRef)(u_runnable_cls) 9u_runnable_init_mid = (env.GetMethodID)(u_runnable_cls, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;(ILjava/lang/Object;)V\u0026#34;) 10u_geturl_mid = (env.GetStaticMethodID)(u_plugin_cls, \u0026#34;GU\u0026#34;, \u0026#34;(Ljava/lang/String;Ljava/lang/String;)I\u0026#34;) 11u_postString_mid = (env.GetStaticMethodID)(u_plugin_cls, \u0026#34;vtEdUZmWQYAgtGWs\u0026#34;, \u0026#34;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I\u0026#34;) 12u_postBytes_mid = (env.GetStaticMethodID)(u_plugin_cls, \u0026#34;BbTwaTXurePBxTDt\u0026#34;, \u0026#34;(Ljava/lang/String;[BLjava/lang/String;)I\u0026#34;) 13u_onLuaMessage_mid = (env.GetStaticMethodID)(u_plugin_cls, \u0026#34;tFAxNZCNHOXBTYGM\u0026#34;, \u0026#34;(ILjava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\u0026#34;) 14u_global_updatelocation_mid = (env.GetStaticMethodID)(u_global_cls, \u0026#34;ul\u0026#34;, \u0026#34;(DD)V\u0026#34;) 15u_global_savelocation_mid = (env.GetStaticMethodID)(u_global_cls, \u0026#34;sl\u0026#34;, \u0026#34;()V\u0026#34;) 16 17(gh.init_plugin_natives)(u_classloader) 18(ref.call_static_method)(u_plugin_cls, 19 \u0026#34;rDymrMuxPIlIESFe\u0026#34;, \u0026#34;(Landroid/app/Application;Ljava/lang/String;I)V\u0026#34;, 20 runtime.app, (env.NewStringUTF)(u_plugin_path), runtime.log_level) 21 22local cls = (gh.findclass)(\u0026#34;me.underworld.helaplugin.HLVM\u0026#34;, u_classloader) 23local hlviewmanagerref = (ref.call_static_method)(cls, \u0026#34;getInstance\u0026#34;, \u0026#34;()Lme/underworld/helaplugin/HLVM;\u0026#34;) 24u_sm_mid = (env.GetMethodID)(cls, \u0026#34;SM\u0026#34;, \u0026#34;(Ljava/lang/String;I)V\u0026#34;) 25u_setviewshow_mid = (env.GetMethodID)(cls, \u0026#34;SVC\u0026#34;, \u0026#34;(Ljava/lang/String;Z)V\u0026#34;) 26u_hlviewmanager = (env.NewGlobalRef)(hlviewmanagerref) 27plugin.classloader = u_classloader      Â GPS Spoofing Since PokemonGO heavily relies on the user\u0026rsquo;s location, the must-have feature for the PokemonGO cheat engines is to be able to spoof the GPS location.\nThe genuine PokemonGO application manages the user location through the Java class NianticLocationManager, which exposes three natives functions:\n nativeAddLocationProviders(Context ctx) nativeGpsStatusUpdate(int i, SatelliteInfo[] info) nativeLocationUpdate(String providerName, Location location, \u0026hellip;)  nativeAddLocationProviders aims at instantiating the different location providers as Java object:\n FusedLocationProvider GnssLocationProvider GpsLocationProvider NetworkLocationProvider  while nativeLocationUpdate and nativeGpsStatusUpdate are a kind of callbacks triggered when there is a new user location to consider.\nThe implementation of nativeLocationUpdate checks natively if the location object given in the second parameter is mocked (cf. isMock() or isFromMockProvider()).\nActually PGSharp hooks two of these three native methods:\n nativeAddLocationProviders(Context ctx) nativeGpsStatusUpdate(int i, SatelliteInfo[] info) nativeLocationUpdate(String provider, Location location, \u0026hellip;)  By hooking nativeLocationUpdate, they can modify the value of the Location parameter to change the real location.\n \u0026ldquo;You assert that PGSharp hooks nativeLocationUpdate and nativeAddLocationProviders in libNianticLabsPlugin.so, but this library is protected by a commercial obfuscator which has anti-hooks features. How do they hook these functions?\u0026rdquo;\n And this is where the fun reaches another level ðŸš€\nÂ JNIEnv Proxifier I would assume that nativeLocationUpdate and nativeAddLocationProviders are critical enough to be protected against hooking. It turns out that PGSharp embeds a hooking framework to hook Unity functions, but they don\u0026rsquo;t use it on these functions.\n  The authors of PGSharp found a subtle trick to circumvent the anti-hook protection.\n\n nativeLocationUpdate and nativeAddLocationProviders are JNI functions that are dynamically registered by Java_com_nianticlabs_nia_unity_UnityUtil_nativeInit:\n1Java_com_nianticlabs_nia_unity_UnityUtil_nativeInit(env, ...) { 2 env-\u0026gt;RegisterNatives(...); 3} The env parameter refers to the JNIEnv structure which is an array of function pointers:\n1struct JNINativeInterface { 2 ... 3 jclass (*GetObjectClass)(JNIEnv*, jobject); 4 jboolean (*IsInstanceOf)(JNIEnv*, jobject, jclass); 5 jmethodID (*GetMethodID)(JNIEnv*, jclass, const char*, const char*); 6 ... 7} The values of these pointers are defined by the implementation of the \u0026ldquo;JVM\u0026rdquo; which is, for Android, the Android RunTime (ART).\nFor instance, FindClass is actually a pointer to art::{CheckJNI, JNIImpl}::FindClass located in art/runtime/jni/{jni_internal, check_jni}.cc:\n1static jclass FindClass(JNIEnv* env, const char* name) { 2 Runtime* runtime = Runtime::Current(); 3 ClassLinker* class_linker = runtime-\u0026gt;GetClassLinker(); 4 std::string descriptor(NormalizeJniClassDescriptor(name)); 5 ScopedObjectAccess soa(env); 6 ObjPtr\u0026lt;mirror::Class\u0026gt; c = nullptr; 7 if (runtime-\u0026gt;IsStarted()) { 8 StackHandleScope\u0026lt;1\u0026gt; hs(soa.Self()); 9 Handle\u0026lt;mirror::ClassLoader\u0026gt; class_loader(hs.NewHandle(GetClassLoader\u0026lt;kEnableIndexIds\u0026gt;(soa))); 10 c = class_linker-\u0026gt;FindClass(soa.Self(), descriptor.c_str(), class_loader); 11 } else { 12 c = class_linker-\u0026gt;FindSystemClass(soa.Self(), descriptor.c_str()); 13 } 14 return soa.AddLocalReference\u0026lt;jclass\u0026gt;(c); 15} If we hook Java_com_nianticlabs_nia_unity_UnityUtil_nativeInit from the genuine PokemonGO, and we check where the pointers of the JNIEnv structure point to, we get this kind of output:\nThis output is consistent with what we said about the JVM and the runtime ART. If we do the same check on PGSharp, we get this result:\nAs we can see, some pointers have been relocated to point in libmain.so:\n    JNI Function Offset in libmain.so (v1.33.0)     GetMethodID 0x14540c   CallObjectMethodV 0x145194   CallVoidMethodV 0x145040   RegisterNatives 0x1452f0     It means that when libNianticLabsPlugin.so is calling one of the functions listed above, the execution is forwarded to libmain.so instead of libart.so.\nPGSharp proxifies these functions for the following purposes:\nGetMethodID\nÂ To monitor:\n SafetyNetService.attest SafetyNetService.cancel NianticLocationManager.addLocationProvider  CallVoidMethodV\nÂ To monitor the parameters of:\n SafetyNetService.attest (to intercept the nonce) SafetyNetService.cancel  RegisterNatives\nÂ Proxified to get, and potentially change, the effective location of the libNianticLabsPlugin.so JNI functions:\n nativeAttestResponse nativeGetApiKey nativeAddLocationProviders nativeLocationUpdate initJni nativeInjectEvent nativeUnitySendMessage nativeRender nativeMuteMasterAudio  By managing the function JNIEnv::RegisterNatives, they are able to change the value of JNINativeMethod.fnPtr, such as when PokemonGO calls nativeLocationUpdate, it actually calls a function managed by PGSharp.\nIt results that JNI functions used by libNianticLabsPlugin.so have been redefined:\n   JNI Function Location     NianticLocationManager.nativeAddLocationProviders libmain.so!ea868   NianticLocationManager.nativeGpsStatusUpdate libNianticLabsPlugin.so!bc508   NianticLocationManager.nativeLocationUpdate libmain.so!ea8bc   NLog.nativeDispatchLogMessage libNianticLabsPlugin.so!4beaa0   NetworkConnectivity.nativeNotifyNetworkStateChanged libNianticLabsPlugin.so!6f8118   NianticTrustManager.nativeCheckClientTrusted libNianticLabsPlugin.so!9b9cc   NianticTrustManager.nativeCheckServerTrusted libNianticLabsPlugin.so!73b42c   NianticTrustManager.nativeGetAcceptedIssuers libNianticLabsPlugin.so!6dc5c8   WebsocketController.nativeOnDidClose libNianticLabsPlugin.so!6fcabc   WebsocketController.nativeOnDidFail libNianticLabsPlugin.so!4a0d0c   WebsocketController.nativeOnDidOpen libNianticLabsPlugin.so!5922b0   WebsocketController.nativeOnDidReceiveData libNianticLabsPlugin.so!742fa8   SafetyNetService.nativeAttestResponse libNianticLabsPlugin.so!5ea1b8   SafetyNetService.nativeGetApiKey libNianticLabsPlugin.so!6bc60   NianticSensorManager.nativeCompassUpdate libNianticLabsPlugin.so!4b9bc0   NianticSensorManager.nativeSensorUpdate libNianticLabsPlugin.so!177c44    Â Unity Hooks In addition to GPS spoofing, PGSharp provides other functionalities such as, Pokemon feed, skip evolve animation \u0026hellip;\nIn the genuine PokemonGO application, these functionalities are implemented in the Unity layer that is compiled into libil2cpp.so.\nTo perform these functionalities, PGSharp hooks (hooking like Frida) some of these Unity functions.\nThey tried to hide6 the underlying hooking framework used to perform these hooks, unfortunately they missed to remove important strings:\n1$ strings ./libmain.so|grep -i -E \u0026#34;\\w\\+\\.cc\u0026#34; 2E:/work/code/Hela/app/src/main/cpp/Dobby/source/InterceptRouting/Routing/FunctionInlineReplace/FunctionInlineReplaceExport.cc 3E:/work/code/Hela/app/src/main/cpp/Dobby/source/TrampolineBridge/Trampoline/arm64/trampoline-arm64.cc 4E:/work/code/Hela/app/src/main/cpp/Dobby/source/MemoryAllocator/MemoryArena.cc 5E:/work/code/Hela/app/src/main/cpp/Dobby/source/InstructionRelocation/arm64/ARM64InstructionRelocation.cc 6E:/work/code/Hela/app/src/main/cpp/Dobby/source/UserMode/PlatformUtil/Linux/ProcessRuntimeUtility.cc 7E:/work/code/Hela/app/src/main/cpp/Dobby/source/UserMode/UnifiedInterface/platform-posix.cc So the hooking framework is Dobby:\n  \u0026nbsp;\u0026nbsp;\u0026nbsp;https://github.com/jmpews/Dobby  Unity hooks start, in the script init.lua of PGSharp where they wait for the loading of libil2cpp.so7:\n1set_event_handler(\u0026#34;pgo.il2ready\u0026#34;, 2 function(il2base) 3 runtime.il2base = il2base; 4 (gh.initil2cppmethods)(); 5 (gh.initil2cpphooks)(); 6 end 7) initil2cppmethods() aims at resolving the address of PokemonGO Unity functions needed to perform cheating actions, while initil2cpphooks() dobby-hooks some Unity functions to change their behaviour. In the version 1.33 of PGSharp, they hook 207 functions of libil2cpp.so and we will take one of them to detail the internal mechanisms:\n UnityEngine.Application$$OpenURL  First of all, if we look at the symbols or the strings of libil2cpp.so, we don\u0026rsquo;t find meaningful information that could help to figure out the original purpose of the Unity functions. In fact, the Unity metadata are embedded in global-metadata.dat, and to recover the bindings between this file and libil2cpp.so, we can use Perfare/Il2CppDumper.\nThey compute the absolute of a Unity function by adding the offset provided by global-metadata.dat to the base address of libil2cpp.so. Here is an example UnityEngine.Application$$OpenURL:\nMOV W13, 0x4bfeea0 ; Offset of the function (thanks to global-metadata.dat) ADRP X14, #Application_OpenURL ADD X13, X8, X13 ; Add the libil2cpp.so base address STR X13, [X14, #Application_OpenURL] ; Store the absolute address in libmain.so The function associated with initil2cpphooks() is quite large as shown in the figure below:\nActually, the function is large but easily understandable statically8. The right-hand side of the figure is actually the catch { ... } handlers of the exceptions, while the left-hand side that goes down, initializes C++ objects. In this area of the CFG, we find the same pattern that repeats all the way down:\nFrom what we can see, it initializes a C++ object (on the stack) and the first instructions setup the VTable. We can find the relevant function in the last entry of the VTable that contains the hooking logic:\nFrom this code, we can see that they perform the resolution of the absolute address of UnityEngine.Application$$OpenURL. Also, thanks to the prototype of DobbyHook() we can quickly understand that the new behavior of OpenURL is located in the function sub_6C983C:\nIn this hook, they check if PokemonGO is opening its Google Play URL and redirect the user to the PGSharp home page.\nÂ Network Communications and Encryption The cheating application communicates with its servers through the TLS/HTTP protocol and adds another layer of encryption on the top of TLS. To encrypt the HTTP payload, they use AES in the CBC mode. We can identify the AES algorithm thanks to clear S-BOX present in the .rodata section.\nIt seems that they use different keys, depending on the endpoint the application targets but we can retrieve them by hooking the AES key schedule function. It results that we can decrypt the communication between the application and the PGSharp servers9.\nHere are examples of endpoints and the data sent by PGSharp:\n\u0026nbsp;\u0026nbsp;hazelnuts  POST hazelnuts  Action: Handshake Request: 1 { 2 \u0026#34;bid\u0026#34;: \u0026#34;com.nianticlabs.pokemongo\u0026#34;, 3 \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, 4 \u0026#34;host\u0026#34;: \u0026#34;Samsung A40\u0026#34;, 5 \u0026#34;lv\u0026#34;: -1, 6 \u0026#34;nonce\u0026#34;: \u0026#34;\u0026#34;, 7 \u0026#34;nonce_key\u0026#34;: \u0026#34;\u0026#34;, 8 \u0026#34;pgver\u0026#34;: \u0026#34;0.221.0\u0026#34;, 9 \u0026#34;uid\u0026#34;: \u0026#34;00000000-00000000-[...]\u0026#34;, 10 \u0026#34;ver\u0026#34;: \u0026#34;1.33.0\u0026#34; 11 }  Response: 1{ 2 \u0026#34;err\u0026#34;: 0, 3 \u0026#34;shiny\u0026#34;: [\u0026#34;List of shiny\u0026#34;], 4 \u0026#34;hotplaces\u0026#34;: [ 5 { 6 \u0026#34;name\u0026#34;: \u0026#34;ðŸ‡§ðŸ‡· Consolacao, SÃ£o Paulo, Brazil\u0026#34;, 7 \u0026#34;lat\u0026#34;: -23.5512, 8 \u0026#34;lng\u0026#34;: -46.6584 9 }, 10 ] 11}         \u0026nbsp;\u0026nbsp;Cw8dfkXpW7mq2i  POST Cw8dfkXpW7mq2i  Action: PGS_ACTIONS.GETPLAYER Request: 1{ 2 \u0026#34;bid\u0026#34;: \u0026#34;com.nianticlabs.pokemongo\u0026#34;, 3 \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, 4 \u0026#34;host\u0026#34;: \u0026#34;Samsung A40\u0026#34;, 5 \u0026#34;lv\u0026#34;: 4, 6 \u0026#34;nonce\u0026#34;: \u0026#34;\u0026#34;, 7 \u0026#34;nonce_key\u0026#34;: \u0026#34;\u0026#34;, 8 \u0026#34;pgver\u0026#34;: \u0026#34;0.221.0\u0026#34;, 9 \u0026#34;player\u0026#34;: { 10 \u0026#34;ban\u0026#34;: 0, 11 \u0026#34;captured\u0026#34;: 3, 12 \u0026#34;encountered\u0026#34;: 5, 13 \u0026#34;kmwalked\u0026#34;: 10.50, 14 \u0026#34;outage\u0026#34;: 0, 15 \u0026#34;pid\u0026#34;: \u0026#34;[redacted]\u0026#34;, 16 \u0026#34;serverlo\u0026#34;: 0, 17 \u0026#34;susp\u0026#34;: 0, 18 \u0026#34;suspa\u0026#34;: 0, 19 \u0026#34;visits\u0026#34;: 1, 20 \u0026#34;warn\u0026#34;: 0, 21 \u0026#34;warna\u0026#34;: 0, 22 \u0026#34;warndt\u0026#34;: 623234511000000000, 23 \u0026#34;warntm\u0026#34;: 0 24 }, 25 \u0026#34;uid\u0026#34;: \u0026#34;00000000-00000000-[...]\u0026#34;, 26 \u0026#34;ver\u0026#34;: \u0026#34;1.33.0\u0026#34; 27}         \u0026nbsp;\u0026nbsp;SSZgBPn6Ixq2ZK  POST SSZgBPn6Ixq2ZK  Action: PGS_ACTIONS.GETREPORTABLE Request: 1{ 2\u0026#34;bid\u0026#34;: \u0026#34;com.nianticlabs.pokemongo\u0026#34;, 3\u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, 4\u0026#34;host\u0026#34;: \u0026#34;Samsung A40\u0026#34;, 5\u0026#34;lv\u0026#34;: 4, 6\u0026#34;nonce\u0026#34;: \u0026#34;\u0026#34;, 7\u0026#34;nonce_key\u0026#34;: \u0026#34;\u0026#34;, 8\u0026#34;pgver\u0026#34;: \u0026#34;0.221.0\u0026#34;, 9\u0026#34;raid\u0026#34;: [ 10 { 11 \u0026#34;battle\u0026#34;: 1634490000000, 12 \u0026#34;campaignId\u0026#34;: \u0026#34;\u0026#34;, 13 \u0026#34;complete\u0026#34;: false, 14 \u0026#34;costume\u0026#34;: 12233, 15 \u0026#34;dex\u0026#34;: 326, 16 \u0026#34;eligible\u0026#34;: false, 17 \u0026#34;end\u0026#34;: 1634490000000, 18 \u0026#34;exclusive\u0026#34;: false, 19 \u0026#34;form\u0026#34;: 0, 20 \u0026#34;free\u0026#34;: false, 21 \u0026#34;gender\u0026#34;: 1, 22 \u0026#34;hidden\u0026#34;: false, 23 \u0026#34;lat\u0026#34;: 0.1234, 24 \u0026#34;lng\u0026#34;: 5.6789, 25 \u0026#34;lv\u0026#34;: 3, 26 \u0026#34;mov1\u0026#34;: 163, 27 \u0026#34;mov2\u0026#34;: 90, 28 \u0026#34;schedule\u0026#34;: false, 29 \u0026#34;seed\u0026#34;: 5000000, 30 \u0026#34;spawn\u0026#34;: 1634400000000, 31 \u0026#34;team\u0026#34;: 1, 32 \u0026#34;web\u0026#34;: 0, 33 \u0026#34;wec\u0026#34;: 3 34 }, 35], 36\u0026#34;uid\u0026#34;: \u0026#34;00000000-00000000-[...]\u0026#34;, 37\u0026#34;ver\u0026#34;: \u0026#34;1.33.0\u0026#34; 38}         \u0026nbsp;\u0026nbsp;/pga/keycode/v-q2mgqcyji/  POST /pga/keycode/v-q2mgqcyji/  Action: Activate PGSharp with a premium key Request: 1{ 2 \u0026#34;ver\u0026#34;: \u0026#34;1.33.0\u0026#34;, 3 \u0026#34;gi\u0026#34;: 1, 4 \u0026#34;key\u0026#34;: \u0026#34;AVerySecretKey\u0026#34;, 5 \u0026#34;host\u0026#34;: \u0026#34;Samsung A40\u0026#34;, 6 \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, 7 \u0026#34;ua\u0026#34;: \u0026#34;Samsung A40/11/[redacted]/arm64-v8a/[redacted]/unknow/unknown/English\u0026#34;, 8 \u0026#34;uid\u0026#34;: \u0026#34;00000000-00000000-[...]\u0026#34; 9}         Â SafetyNet  I skimmed this layer this weekend, so some parts might be inaccurate or wrong.  In addition to standard code obfuscation, PokemonGO uses SafetyNet as an attestation mechanism. Similarly to the GPS management, we find a (non-obfuscated) Java layer implemented in the class SafetyNetService. This class exposes two native functions:\n String nativeGetApiKey() void nativeAttestResponse(byte[] nonce, String jwtResult)  The implementation of these two functions is obfuscated within libNianticLabsPlugin.so.\nThe first function is used to get the Google SafetyNet API key (AIzaSyCh8l[...]_eOTXhM4) while the second one, is involved in the validation of the SafetyNet attestation.\nThanks to the JNIEnv proxy on GetMethodID and CallVoidMethodV, PGSharp is able to monitor the calls to SafetyNetService.attest(bytes[] nonce). When this function is called, PGSharp intercepts the nonce and forward the request to its servers:\n  https://tens.pgsharp.com/v1/scc-2-eg[...]4/\n The request is performed through a http POST, whose data are encrypted with AES. The clear payload has the following layout:\n1{ 2 \u0026#34;n\u0026#34;: \u0026#34;Cy[...]\u0026#34;, 3 \u0026#34;type\u0026#34;: \u0026#34;attest\u0026#34;, 4 \u0026#34;ver\u0026#34;: \u0026#34;\u0026lt;PGSharp Version\u0026gt;\u0026#34;, 5 \u0026#34;k\u0026#34;: \u0026#34;i3[...]\u0026#34;, 6 \u0026#34;clt\u0026#34;: \u0026#34;pgs\u0026#34;, 7 \u0026#34;data\u0026#34;: { 8 \u0026#34;k\u0026#34;: \u0026#34;AIzaSyCh8l[...]_eOTXhM4 \u0026lt;- From nativeGetApiKey\u0026#34;, 9 \u0026#34;n\u0026#34;: \u0026#34;\u0026lt;nonce\u0026gt;\u0026#34; 10 } 11} On success, the server responses with an AES-encrypted payload which has the following layout:\n{\u0026#34;result\u0026#34;:\u0026#34;suc: \u0026lt;JWT SafetyNet Attestation\u0026gt;\u0026#34;} The JWT SafetyNet value is then forwarded by PGSharp to nativeAttestResponse() with the original nonce. At some point, this JWT attestation is sent to Niantic\u0026rsquo;s servers (on the endpoint plfe/112/rpc2) wrapped by a Protobuf structure.\nTo understand how they \u0026ldquo;bypass\u0026rdquo; SafetyNet, let\u0026rsquo;s look at the JWT payload:\n1{ 2 \u0026#34;nonce\u0026#34;: \u0026#34;\u0026lt;nonce\u0026gt;\u0026#34;, 3 \u0026#34;timestampMs\u0026#34;: 1636265656, 4 \u0026#34;apkPackageName\u0026#34;: \u0026#34;com.nianticlabs.pokemongo\u0026#34;, 5 \u0026#34;apkDigestSha256\u0026#34;: \u0026#34;ioYmlh5mk5EhMUH/DsaG1jrhUoQJDK/2IvK61eiAXJE=\u0026#34;, 6 \u0026#34;ctsProfileMatch\u0026#34;: true, 7 \u0026#34;apkCertificateDigestSha256\u0026#34;: [ 8 \u0026#34;lEvaRm6vZL4ck4ltXI6aRUoHyNj8vEre7vs1RbM16Xk=\u0026#34; 9 ], 10 \u0026#34;basicIntegrity\u0026#34;: true, 11 \u0026#34;evaluationType\u0026#34;: \u0026#34;BASIC\u0026#34; 12} First of all, the JWT is correctly signed by Google SafetyNet\u0026rsquo;s key and the apkCertificateDigestSha256 matches the signature of the real PokemonGO application.\nBut \u0026hellip;\nThe value of apkDigestSha256 does not match the checksum of the genuine PokemonGO application ðŸ˜•\nHere are my hypothesis:\nThe server https://tens.pgsharp.com/v1/scc-2-eg/... forwards the SafetyNet request to a real application that runs on a real device. This application would have been created by PGSharp authors to really run SafetyNet and to get a valid attestation signed with a valid Google key. The fake application would have been created with com.nianticlabs.pokemongo as package name and would implement signature mocking, as discussed in the first part.\nIf they would have managed to break SafetyNet, the apkDigestSha256 value would have been consistent.\nThe JWT attestation is forwarded to Niantic so they might check the consistency of apkDigestSha256 but they might only focus on the signature (which can be faked) and not this value \u0026hellip;\nÂ When PGSharp avoids PokemonGO pitfalls As discussed in the section Signature Bypass, PGSharp tricks the Android PackageManager to mock the signature of the application.\nIt turns out that PGSharp is also concerned about app repackaging. As they provide premium features, they don\u0026rsquo;t want to be cheated \u0026hellip;\nIn the function associated with PGS_ACTIONS.INITPOST they perform a device fingerprint whose one of these elements is the APK\u0026rsquo;s signature. But instead of using the Android PackageManager to retrieve the signature, they use DimaKoz/stunning-signature to compute the MD5 digest of the signature.\nÂ Final Words When I started to look at this cheating app, I did not expect to find such nice tricks and challenges. The PGSharp\u0026rsquo;s authors know the sneaky tricks to hinder reverse engineering. Unfortunately, O-LLVM is relatively weak in this context compared to the commercial obfuscator used by Niantic.\nOn the other hand, the design of PokemonGO is such that all the reverse engineering difficulties lie in one single module that can be treated in black-box once we identified the API. In particular, the un-obfuscated Java layer helps a lot to identify these API.\nRegarding the signature bypass, at first, I thought it would be easy to prevent by checking the integrity of the .apk and/or the native libraries. But, there are some points that need to be taken into account:\nAPK Integrity Check\nNaively, we might want to compute a checksum of the APK or re-compute the signature (as it\u0026rsquo;s done by PGSharp). But in fact, since a few years, Google tries to push developers to use app bundle such as an application is no longer a single .apk but a split .apk. While this feature optimizes the device\u0026rsquo;s data partition size, it complicates the verification of the signature since it would require to deal with different files and different checksum.\nIt\u0026rsquo;s not infeasible, but it complicates its implementation in the APK build \u0026amp; development pipeline.\nNative Library Integrity Check\nI guess that libNianticLabsPlugin.so implements checksum on its own library as it is a sensitive part of the application. Regarding the other libraries, some of them are owned by Niantic (like libholoholo.so) and others come from third-parties (like libmain.so). Depending on how they are integrated, the checksum of these external libraries might not be easy to automatically compute while releasing a new version of PokemonGO. These third-party libraries are, most of the time, not copy-pasted by the developers but automatically bundled when compiling the application. Therefore, computing their checksums might require tweaking the build process in a non-easy way.\nOn the top of that, Niantic releases a new version of its games on a monthly basis. It means that these checks need to be automated in CI/CD pipeline which might not be trivial to do.\nIt was a funny and very interesting journey, for those who want to dig a bit more in PGSharp, I pushed some materials and documents on Github. In particular, you can find the symbol list of libmain.so based on reverse engineering.\n  \u0026nbsp;\u0026nbsp;\u0026nbsp;https://github.com/romainthomas/pgsharp  Â Acknowledgments This analysis has been independently done in my spare time while being at Quarkslab and UL, my current employer.\nÂ Annexes Third-Party Here is the (non exhaustive) list of the open-source projects used by PGSharp:\n        https://github.com/jmpews/Dobby   https://github.com/or-dvir/EasySettings   https://github.com/zupet/LuaTinker or https://github.com/yanwei1983/luatinkerE   https://github.com/DimaKoz/stunning-signature   https://www.sqlite.org/index.html   https://github.com/nlohmann/json   https://www.lua.org/manual/5.3/   https://github.com/kikito/md5.lua   https://github.com/rxi/json.lua    List of the Unity Functions used by PGSharp \u0026nbsp;\u0026nbsp;Expand 1object__Invoke 2String_CreateString1 3String_CreateString3 4ulong_object___get_Item 5ulong_object___ContainsKey 6ulong_object___TryGetValue 7Application_OpenURL 8Application_set_targetFrameRate 9Quaternion_Angle 10PlayerPrefs_TrySetInt 11PlayerPrefs_TrySetFloat 12PlayerPrefs_TrySetSetString 13PlayerPrefs_SetInt 14PlayerPrefs_GetInt 15PlayerPrefs_SetFloat 16PlayerPrefs_GetFloat 17PlayerPrefs_SetString 18PlayerPrefs_GetStringNoDefault 19PlayerPrefs_HasKey 20PlayerPrefs_DeleteKey 21Component_get_gameObject 22Transform_get_rotation 23Animator_get_speed 24Animator_set_speed 25Animator_SetTriggerID 26Animator_Update 27Promise__ctor 28Promise_Complete 29MapMath_MetersBetween 30NL_NLAny_object_ 31NL_NLFirst_object_ 32InputField_ActivateInputField 33InputField_DeactivateInputField 34Text_set_text 35Text_set_fontSize 36DiContainer_InjectExplicitInternal 37Schedule_WaitOn_c__AnonStorey0____m__0 38GameState_EnterState 39GameState_ExitState 40RpcBindings_Send 41RpcManager_DispatchCallbacks 42Animator_SetTriggerID 43RpcManager_DispatchCallbacks 44AuthService_get_CachedCredentialsExist 45AuthService_Logout 46DeviceServiceExtensions_IsUsable 47GameMasterData_IsPokemonWeatherBoosted 48Animator_SetTriggerID 49AuthService_get_CachedCredentialsExist 50AuthService_Logout 51PgpApi_UpdateNotifications 52ARPlusEncounterValuesProto__ctor 53ARPlusEncounterValuesProto__cctor 54PlayerService_GetPlayerDayBucket 55PlayerService_get_PlayerStats 56PlayerService_get_CurrentPokeball 57PlayerService_get_CurrentLinkedLogins 58AuthService_get_CachedCredentialsExist 59PlayerService_get_PokemonBag 60PlayerService_GetPlayerProfile 61PlayerService_set_CurrentPokeball 62PlayerService_get_BagIsFull 63PlayerService_GetCandyCountForPokemon 64StateToken_Complete 65TimeUtil_ServerNowMs 66RequestGymDetailsById_onSucceed 67RequestGymDetailsById_onError 68PlayerPrefs_SetInt 69BluetoothUtil_get_IsBluetoothEnabled 70PgpGuiController_ClickIcon 71PgpGuiService_SetSfidaIconVisible 72PgpGuiService_EnableSfidaIcon 73ulong_object___get_Item 74PgpService_get_IsSessionActive 75PgpService_GetCurrentNotificationType 76ItemBagImpl_GetItemCount 77PokemonBagImpl_GetPokemon 78ulong_object___get_Item 79PgpApi_UpdateNotifications 80Animator_set_speed 81StateToken_Complete 82VersionCheckService_CheckVersion 83ulong_object___TryGetValue 84QuestMapPokemon_get_Pokemon 85QuestService_BeginQuestEncounterWithOut 86EulaGuiController_PressAccept 87StarterMapPokemon_get_Pokemon 88OpenRemoteGym_gymOpner 89OpenRemoteGym_onSucceed 90BluetoothUtil_get_IsBluetoothEnabled 91QuestService_BeginQuestEncounterWithOut 92RaidState_ExitGymWithRaidDetails 93AccountChoiceState_ClickNewPlayer 94AccountChoiceState_ClickExistingPlayer 95LoginAgeGateState_SubmitSelections 96LoginChoiceState_ClickPtc 97LoginChoiceState_ClickGoogle 98LoginGuiController_ClickSubmit 99PtcLoginState_SubmitLogin 100I18n_PokemonMoveName 101I18n_SetUpLanguageTable 102I18n_PokemonNameTemporaryEvolution 103I18n_Text 104I18n_PokemonName 105FriendsGuiState_StartOpenGiftFlow 106FriendsGuiState_StartSendGiftFlow 107FriendsRpcService_RemoveGiftbox 108GiftingRpcService_SendGift 109GiftingRpcService_OpenGift 110StickerService_GetStickerInventory 111CombatDirector_Initialize 112MapPokestop_get_PoiId 113MapPokestop_get_ActiveIncidentType 114MapPokestop_get_Location 115EncounterParkCameraController_PlayIntro 116RunPokemonCaptured_onDitto 117EncounterInteractionState_RunAway 118MapMath_MetersBetween 119PlayerPrefs_TrySetSetString 120EncounterInteractionState_IntroCompleted 121AttemptCapture_onResponse 122EncounterIntroState_ExitState 123EncounterPokemon_get_MapPokemon 124PlayerPrefs_HasKey 125ItemBagImpl_GetItemCount 126Pokeball_TryHitPokemon 127Pokeball_FlyStateImpl_Capture__MoveNext 128Pokeball_DropStateImpl_Capture__MoveNext 129EncounterGuiController_ShowPokemonFlee 130EncounterState_get_EncounterType 131EncounterState_EncounterStateComplete 132EncounterState_EncounterStateComplete 133EncounterState_get_MapPokemon 134EncounterState_OnEncounterResponse 135DefaultEncounter_get_DefaultBall 136ExtraMapPokemon_get_Pokemon 137ResearchEncounter_get_DefaultBall 138ResearchEncounter_get_DefaultBall 139object_object__object___CurrentPageIndex 140PokemonInventoryCellView_Initialize 141ToastService_OneLineMedium 142ToastService_RewardItemNameAmount 143ToastService_RewardItemDefault 144ToastService_RewardItemStardust 145ToastService_OneLineMediumWithParams 146ToastService_RewardItemXlCandy 147ToastService_RewardItemAmount 148ToastService_TwoLine 149ToastService_RewardItemAmountType 150ToastService_RewardItemMegaResource 151ToastService_RewardSticker 152ToastService_OneLineWithParams 153ToastService_OneLineBig 154ToastService_OneLineBigWithParams 155ToastService_RewardItemCandy 156UserPromptsService_HasActiveModal 157UserPromptsService_DismissActiveModal 158PokemonInfoDynoScrollRect_Cleanup 159Quaternion_Angle 160Animator_get_speed 161PokemonInfoPanel_DoUpdate 162GymRootController_get_View 163GymRootController_get_MapGym 164MapGym_get_PoiId 165MapGym_OnTap 166MapGym_get_Location 167RaidMapPokemon_get_Pokemon 168MapContentHandler_UpdateCells 169MapEntityCell_get_Pois 170MapEntityService_get_Cells 171MapEntityService_GetMapPoi 172MapEntityService_UpdatePois 173MapExploreState_GymSelected 174MapExploreState_EnterQuestEncounter 175MapPokemon_get_Location 176MapPokemon_get_DespawnTime 177MapPokemon_TryCapture 178PhotobombingMapPokemon_get_Pokemon 179MapPokestop_get_ActiveIncidentType 180SendEncounterRequestCapture_onResponse 181PoiMapPokemon_get_SpawnPointId 182PoiMapPokemon_get_EncounterId 183WildMapPokemon_get_Pokemon 184WildMapPokemon_SendEncounterRequest 185PoiDirectoryService_AddPokemon 186PoiDirectoryService_RemovePokemon 187RaidMapPokemon_get_Pokemon 188IncidentMapPokemon_get_Pokemon 189IncenseMapPokemon_SendEncounterRequest 190IncenseMapPokemon_OnDestroy 191IncenseMapPokemon_get_Pokemon 192TroyDiskMapPokemon_SendEncounterRequest 193TroyDiskMapPokemon_get_Pokemon 194GroundTapHandler_OnTap 195GroundTapHandler_OnTap1 196MapViewHandler_GetGroundLocation 197MapViewHandler_GetGroundPosition 198MapViewHandler_GetWorldLocation 199NL_NLFirst_object_ 200CompassGuiController_Update 201PlayerService_SetPlayerProto 202MapPokemon_LogEncounterMetrics        O-LLVM provides control-flow obfuscation that can be recovered with emulation. On the other hand, the data-flow (function parameters, stack values, memory accesses) can be analysed at a basic-block level with static analysis.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n libmain.so is also statically linked against other libraries like jmpews/Dobby, nlohmann/json, sqlite \u0026hellip;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Modded apps use similar tricks as discussed in Android Application Diffing: Analysis of Modded Version\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n In order to arbitrarily call the underlying function when needed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The package names are stripped with Proguard but we can quite easily recover those packages.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Basically, they renamed DobbyHook in FbbUePBslRNHWkdS\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The event is triggered when nativeMuteMasterAudio or nativeRender is registered and they get the base address by iterating over /proc/\u0026lt;pid\u0026gt;/maps.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n O-LLVM seems not applied on this function\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n One can also hook the AES encrypt/decrypt functions whose prototype is (uint8_*t key_schedule, uint8_t* inout_buffer, size_t size)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1636243200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"e1b2b14aab84fe49c5f5a99ad637a0da","permalink":"https://www.romainthomas.fr/post/21-11-pgsharp-analysis/","publishdate":"2021-11-07T00:00:00Z","relpermalink":"/post/21-11-pgsharp-analysis/","section":"post","summary":"This blog post is about the internal mechanisms of PGSharp, a cheat engine for PokemonGO.","tags":["Android","reverse engineering","obfuscation"],"title":"PGSharp: Analysis of a Cheating App for PokemonGO","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":" Slides   Talk   \n Blog Post PGSharp: Analysis of a Cheating App for PokemonGO\n","date":1636070400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"a48df6c4b5b94100898b669f445ec782","permalink":"https://www.romainthomas.fr/publication/21-ekoparty-mobile-hacking-space-pgsharp/","publishdate":"2021-11-05T00:00:00Z","relpermalink":"/publication/21-ekoparty-mobile-hacking-space-pgsharp/","section":"publication","summary":"PGSharp is a cheating app for PokemonGO that works on non-rooted devices. This talk introduces its functionalities and the protections used to prevent reverse-engineering.","tags":null,"title":"PGSharp: Analysis of a Cheat Engine on Android","type":"publication"},{"authors":["Romain Thomas"],"categories":["iOS","Reverse Engineering"],"content":" .green { color:green; font-family: 'Fira Code', monospace; font-size: 87.5%; } .blue { color: blue; font-family: 'Fira Code', monospace; font-size: 87.5%; } .orange { color: #FF6347; font-family: 'Fira Code', monospace; font-size: 87.5%; } .red { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-comment { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-keyword { color: #A90D91; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-literal { color: #1C01CE; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-preproc { color: #633820; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-strings { color: #C41A16; font-family: 'Fira Code', monospace; font-size: 87.5%; } .yellow { color: #CC7000; font-family: 'Fira Code', monospace; font-size: 87.5%; }      Note Do not expect a click \u0026amp; play solution for PokemonGO in this blog post. This blog post is more about the technical aspects of jailbreak detection than a bypass for this game.     Introduction While working on LIEF during my vacations to support in-memory parsing for Mach-O files, I found that PokemonGO was an interesting use case to introduce this feature. It led me to look at the jailbreak and Frida detection implemented in this game. Being more familiar with Android than iOS, the analysis workflow on this platform is quite different, which is also a good opportunity to improve tooling.\nThe first challenge stems from jailbreaking the device. Fortunately, checkra1n eases this step. The second difficulty lies in extracting the encrypted iOS app from the device. In contrast to Android, iOS apps are encrypted on the disk and decrypted by the kernel when loaded. It means that one way to get the unencrypted code is to dump the file from memory. One could also leverage the function mremap_encrypted() as described in Decrypting Apps on iOS.\nPokemonGO Overview When running PokemonGO on a jailbroken device1, the application immediately crashes with the following backtrace:\n10 ??? 0x000000020ac46ab8 0 + 8770579128 21 libdyld.dylib 0x0000000184df8304 invocation function for block in dyld3::AllImages::runAllInitializersInImage(dyld3::closure::Image const*, dyld3::MachOLoaded const*) + 136 32 libdyld.dylib 0x0000000184dea5b0 dyld3::closure::Image::forEachInitializer(void const*, void (void const*) block_pointer) const + 96 43 libdyld.dylib 0x0000000184df8160 invocation function for block in dyld3::AllImages::runInitialzersBottomUp(dyld3::closure::Image const*) + 296 54 libdyld.dylib 0x0000000184deae6c dyld3::closure::Image::forEachImageToInitBefore(void (unsigned int, bool\u0026amp;) block_pointer) const + 92 65 libdyld.dylib 0x0000000184df8b48 dyld3::AllImages::loadImage(Diagnostics\u0026amp;, char const*, unsigned int, dyld3::closure::DlopenClosure const*, bool, bool, bool, bool, void const*) + 776 76 libdyld.dylib 0x0000000184df8698 dyld3::AllImages::dlopen(Diagnostics\u0026amp;, char const*, bool, bool, bool, bool, bool, void const*, bool) + 872 87 libdyld.dylib 0x0000000184dfa2b4 dyld3::dlopen_internal(char const*, int, void*) + 368 98 libdyld.dylib 0x0000000184ded5b0 dlopen_internal(char const*, int, void*) + 108 109 CoreFoundation 0x00000001850ed038 _CFBundleDlfcnLoadFramework + 136 1110 CoreFoundation 0x00000001850be974 _CFBundleLoadExecutableAndReturnError + 376 1211 Foundation 0x0000000186359ba8 -[NSBundle loadAndReturnError:] + 332 1312 pokemongo 0x00000001041a7c5c 0x1041a0000 + 31836 1413 pokemongo 0x00000001041a7d50 0x1041a0000 + 32080 1514 libdyld.dylib 0x0000000184de9588 start + 4 The full crash log is available here.  In this backtrace, the main pokemongo binary is a kind of stub that loads the Unity binary: UnityFramework which contains the main logic of the game.\nThis library is loaded by the dlopen_internal function at index 8 in the backtrace as a result of -[NSBundle loadAndReturnError:]. Since UnityFramework depends on other libraries, they are (pre)loaded with Image::forEachImageToInitBefore which processes the following files:\n @/usr/lib/libc++.1.dylib \u0026hellip; @rpath/NianticLabsPlugin.framework/NianticLabsPlugin \u0026hellip; @rpath/libswiftos.dylib  Among those dependencies, we can notice the NianticLabsPlugin library which is a cross-platform Unity plugin \u0026ndash; also present in the Android version \u0026ndash; that contains the main protections of the game. These protections are used to prevent cheat, bots, GPS spoofing, in PokemonGO. The whole being obfuscated by Digital.ai (formerly known as Arxan). NianticLabsPlugin communicates with the UnityFramework through an exported function GetN2Api that returns an array of functions (pointers).\nThe following figure outlines these different components:\nGetting back to the backtrace, if we assume that the application crashes when loading NianticLabsPlugin, it precisely crashes when calling the Mach-O constructors in AllImages::runAllInitializersInImage. Since the application is heavily obfuscated, a static analysis reaches quickly its limits, which forces us to emulate or dynamically analyze the functions of interest.\n    Note The addresses of the functions/instructions mentioned in this blog post are based on the following version of NianticLabsPlugin:\n NianticLabsPlugin - 2140426ccdfdfb2529f454697cb5cc83\n PokemonGO v0.211.2 - June 2021\n    Analyzing Mach-O constructors with Frida From the previous section, we surmised that the application crashed because of the NianticLabsPlugin\u0026rsquo;s constructors. Since these functions are called before any other functions of the library, it raises the question of finding a way to perform actions (or hook) before they are executed.\nOn Android, when we need to analyse a library\u0026rsquo;s constructors, we can hook the call_array function from Bionic\u0026rsquo;s linker (ELF loader):\n If we try to apply the same approach on iOS, the mirror of the ELF loader on iOS is dyld which contains most of the logic to load Mach-O files. It turns out that at some points, the Mach-O\u0026rsquo;s constructors are processed in the doModInitFunctions function (from ImageLoaderMachO.cpp).\n1void ImageLoaderMachO::doModInitFunctions(const LinkContext\u0026amp; context) { 2 ... 3 for (const struct macho_section* sect=sectionsStart; sect \u0026lt; sectionsEnd; ++sect) { 4 const uint8_t type = sect-\u0026gt;flags \u0026amp; SECTION_TYPE; 5 if ( type == S_MOD_INIT_FUNC_POINTERS ) { 6 Initializer* inits = (Initializer*)(sect-\u0026gt;addr + fSlide); 7 ... 8 if (!this-\u0026gt;containsAddress(stripPointer((void*)func)) ) { 9 dyld::throwf(\u0026#34;initializer function %p not in mapped image for %s\\n\u0026#34;, func, this-\u0026gt;getPath()); 10 } 11 ... 12 func(context.argc, context.argv, context.envp, context.apple, \u0026amp;context.programVars); 13 } 14 } 15 ... 16} From this code, we can notice that all constructor addresses are checked beforehand by the containsAddress function. Therefore, it makes this function a good hooking spot as it is executed before calling the constructor itself. One can use the native SDK of frida-gum to perform this action:\n1// Address of ImageLoader::containsAddress in /usr/lib/dyld 2const uintptr_t containsAddress_ptr = ...; 3 4// Setup hooks with gum_interceptor_attach 5GumAttachReturn attach_ret = gum_interceptor_attach( 6 listener_-\u0026gt;interceptor, 7 /* target */ reinterpret_cast\u0026lt;void*\u0026gt;(containsAddress_ptr), 8 reinterpret_cast\u0026lt;GumInvocationListener*\u0026gt;(listener_), 9 /* ID */ reinterpret_cast\u0026lt;void*\u0026gt;(containsAddress_ptr) 10); 11.... 12// Equivalent of onEnter in Javascript 13void native_listener_on_enter(GumInvocationListener* listener, GumInvocationContext* ic) { 14 const uintptr_t ctor_function_addr = ic-\u0026gt;cpu_context-\u0026gt;x[1]; 15 // Do stuff with ctor_function_addr 16} containsAddress is a member function, therefore x0 contains a pointer on this and the address to check is located in x1.  By hooking containsAddress(), we get the control before the execution of the constructors. It gives us the ability to perform the following actions that can help to identify the constructor involved in the crash:\n Trace the constructors (see: constructors_trace.log) Replace/disable a constructor (gum_interceptor_replace) Detect the first constructor and hook the next ones (gum_interceptor_attach)  NianticLabsPlugin embeds no less than 120 constructors among those, 62 are involved in detecting Frida, jailbroken devices, anti-debug, etc:\n   Index Offset Description     15 0x4369e0 Anti-debug \u0026amp; anti-emulation   16 0x00e0d8 Frida detection   17 0x26bd5c Anti-bypass?   18 0x449b84 Anti-jailbreak, anti-Frida   19 0x731b90 Anti-jailbreak, anti-debug, anti-frida   20 0x359194 Anti-jailbreak    Once we reduced the set of functions involved in the crash, we can combine dynamic analysis with Frida and emulation with Unicorn.\nAnti-debug One of the redundant checks we can find in many functions (not only the constructors) are the anti-debugs. They always come in two parts:\n Try to \u0026ldquo;kill\u0026rdquo; its own pid with the 0-signal Check if PTRACE is flagged  1void try_kill() { 2 const int pid = getpid(); // syscall@0x436cdc 3 int ret = kill(pid, 0); // syscall@0x436d28 4} According to the man page of kill (man 2 kill), the signal 0 is used to check that the pid given in the first parameter really exists.\n [\u0026hellip;] A value of 0, however, will cause error checking to be performed (with no signal being sent). This can be used to check the validity of pid.\n This kill operation is followed by three PTRACE checks:\n1// Done three times 2inline bool ptrace_detect() { 3 int32_t opt[4] = { 4 CTL_KERN, 5 KERN_PROC, 6 KERN_PROC_PID, 7 getpid(), 8 }; 9 kinfo_proc info; 10 sysctl(opt, 4, \u0026amp;info, sizeof(kinfo_proc), nullptr, 0); 11 return info.kp_proc.p_flag \u0026amp; P_TRACED; 12} These three P_TRACED checks always come together:\n10x436cdc: getpid(): 6015 20x436d28: kill(6015, 0): 0 30x4374b0: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) 40x4371e8: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) 50x437398: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) Frida Detection Frida is detected by the application through its client-server mode, which binds the localhost on the port 27042. When PokemonGO is starting, it tries to open a socket on this port and if it manages to connect, it tests the Frida handshake.\n10x00e3b8: getifaddrs(0x16b7fb518): 0x0 20x016990: socket(\u0026#39;IPV4\u0026#39;, \u0026#39;TCP\u0026#39;, \u0026#39;0\u0026#39;): 0x8 30x019d60: bind(\u0026#39;PF_INET\u0026#39;, 0x8, \u0026#39;127.0.0.1:27042\u0026#39;) 40x01805c: close(0x8) 50x016990: socket(\u0026#39;IPV4\u0026#39;, \u0026#39;TCP\u0026#39;, \u0026#39;0\u0026#39;): 0x8 60x019d60: bind(\u0026#39;PF_INET\u0026#39;, 0x8, \u0026#39;192.168.0.26:27042\u0026#39;) 70x01805c: close(0x8) 80x00e3ec: freeifaddrs(0x10601ac00): 0x105360a00 The application also iterates over the list of the libraries loaded in memory with the _dyld_image_count/_dyld_get_image_name functions. Nevertheless, it seems that they are not used to detect Frida libraries artifacts (like FridaGadget.dylib).\nJailbreak Detection The application implements jailbreak detection by checking if some files are accessible or not on the device. Most of the checks are done by using the access() syscalls that are inlined in different places:\n10x44c390: access(\u0026#39;/bin/grep\u0026#39;, 0x0) 2... 30x7326b0: access(\u0026#39;/private/var/checkra1n.dmg\u0026#39;, 0x0) The list of the checked files is given in the annexes of the blog post.\nThis list is very close to vnodebypass/hidePathList.plist  In addition to raw access syscall, the application enhances its detection by creating a symbolic link of the root directory in a temporary app data directory:\n0x734e08: symlink(\u0026#39;/Applications/..\u0026#39;, \u0026#39;/private/var/mobile/Containers/Data/Application/D933FBC9-90E7-4584-851E-CE2D5E900446/tmp/WCH38bnM0x101a9e7d0\u0026#39;) Then, it performs the same checks with the app data directory as prefix: [...]/tmp/WCH38bnM0x101a9e7d0:\n0x7376d8: access(\u0026#39;/private/var/mobile/Containers/Data/Application/D933FBC9-90E7-4584-851E-CE2D5E900446/tmp/3Odis0x101a9dfd0/usr/bin/passwd\u0026#39;, 0x0) Signature Check At some point, one function checks the integrity of the signature of the pokemongo binary. This check starts by opening the main pokemongo binary from the disk:\n10x7392ec: add x0, x19, #6,lsl#12 20x7392f0: add x0, x0, #0x540 30x7392f4: mov w1, #0x1000000 40x7392f8: mov x2, #0 50x7392fc: svc 0x80 ; x16 -\u0026gt; SYS_open = 5 6// open(\u0026#39;/private/var/containers/Bundle/Application/[...]/pokemongo.app/pokemongo\u0026#39;): fd_pgo Then, it reads the beginning of the file in a stack buffer:\n10x74b494: ldr x0, [x19, #0xc0] ; fd 20x74b498: ldr x1, [x19, #0x130] ; buff 30x74b49c: ldr x2, [x19, #0xb8] ; buff_size 40x74b4a0: svc 0x80 ; x16 -\u0026gt; SYS_read = 3 5// uint8_t macho_head[0x4167]; 6// 0x74b4a0: read(fd_pgo, macho_header, 0x4167); to iterate over the Mach-O load commands:\n1; x8 points to the read\u0026#39;s buffer 20x73942c: ldr w8, [x8, #0x10] ; Number of LC_COMMANDS 3 4for (size_t i = 0; i \u0026lt; nb_cmds; ++i) { 5 0x74bc40: ldr w10, [x9, #4] ; Command\u0026#39;s size 6 0x74ade4: ldr w9, [x9] ; command\u0026#39;s type 7 if (cmd.type == LC_CODE_SIGNATURE) { 8 0x74b1b8: ldr w10, [x10, #8] ; read signature offset -\u0026gt; 0xc3d0 9 } 10} With the offset of the Mach-O LC_CODE_SIGNATURE command, it reads the raw signature using the lseek/read syscalls:\n1uint8_t sig_header[0x205]; 20x73a978: lseek(fd_pgo, LC_CODE_SIGNATURE offset, 0x0) 30x73aecc: read(fd_pgo, \u0026amp;sig_header, 0x205); The raw signature buffer is processed by chunks of 10 bytes in a function that looks like a checksum:\n1[...] 20x73ad58: ldrsb w13, [x12] 30x73ad5c: mov w14, #83 40x73ad60: sub w13, w14, w13 50x73ad64: ldrsb w14, [x12, #1] 60x73ad68: mov w15, #87 70x73ad6c: sub w14, w15, w14 80x73ad70: ldrsb w16, [x12, #2] 90x73ad74: mov w17, #53 100x73ad78: sub w16, w17, w16 110x73ad7c: ldrsb w17, [x12, #3] 120x73ad80: mov w0, #52 130x73ad84: sub w17, w0, w17 140x73ad88: ldrsb w0, [x12, #4] 150x73ad8c: sub w0, w15, w0 160x73ad90: ldrsb w1, [x12, #5] 170x73ad94: mov w2, #51 180x73ad98: sub w1, w2, w1 190x73ad9c: ldrsb w2, [x12, #6] 200x73ada0: mov w3, #54 210x73ada4: sub w2, w3, w2 220x73ada8: ldrsb w3, [x12, #7] 230x73adac: sub w15, w15, w3 240x73adb0: ldrsb w3, [x12, #8] 250x73adb4: mov w4, #78 260x73adb8: sub w3, w4, w3 270x73adbc: ldrsb w12, [x12, #9] 280x73adc0: mov w4, #70 290x73adc4: sub w4, w4, w12 30[...] I did not manage to identify the underlying checksum algorithm, but it involves square multiplications and the key(?): SW5436NF\nControl-Fault Injection Once we determined the functions involved in the detections, we might want to disable them in order to run the game smoothly. Actually, PokemonGO is protected against such bypass with global variables that assert if a function ran successfully or not.\nThis protection is equivalent to the following piece of code:\n1static constexpr uintptr_t GOOD = 0x00627178; // bqx ? 2static uintptr_t MAGIC_CFI = 0xdeadc0de; 3 4__attribute__((constructor)) 5void frida_detect() { 6 if (is_frida_running()) { 7 crash(); 8 } 9 MAGIC_CFI = GOOD; 10} 11 12 13__attribute__((constructor)) 14void control_fault_check() { 15 if (MAGIC_CFI != GOOD) { 16 crash(); 17 } 18} If we only disable frida_detect(), the application will crash because of control_fault_check().\nWe could bypass this protection by identifying the address of the MAGIC_CFI in the __data section, or by disabling the control_fault_check().\nWhat about LIEF? As mentioned in the introduction, it started with an ongoing feature to parse Mach-O files from memory. Basically, LIEF will3 enable to parse Mach-O files4 from an absolute address with this kind of API:\n1// 0x10234400 -\u0026gt; start of the Mach-O file 2auto bin = LIEF::MachO::Parser::parse_from_memory(0x10234400); Depending on the user\u0026rsquo;s needs, the write() operation will optionally undo all the relocations and the symbol bindings. This could be useful if we aim at (re)running the file dumped (on a Apple M1?).\nAs expected, the strings used within the NianticLabsPlugin library are encoded by the obfuscator. We could statically analyze the decoding routine (cf. Tim Blazytko\u0026rsquo;s blog post) ,but another technique consists in using a property of the obfuscator\u0026rsquo;s string encoding mechanism.\nIt seems that the obfuscator put all the strings5 in the data section and decrypts all of them in a single constructor function.\nFor instance, if we have the string \u0026ldquo;TOKEN\u0026rdquo; to protect in the following functions:\n1void protect_me() { 2 sensitive(\u0026#34;TOKEN\u0026#34;); 3} 4 5void protect_me_2() { 6 sensitive(\u0026#34;TOKEN2\u0026#34;); 7} The obfuscator transforms and decodes the strings into something like:\n1// __data section 2static char var_TOKEN[] = \u0026#34;\\x00\\x1D\\xDD\\xEE\\xAB\u0026#34;; 3static char var_TOKEN_2[] = \u0026#34;\\x00\\x1D\\xDD\\xEE\\xAF\u0026#34;; 4 5__attribute__((constructor)) 6void decode_strings() { 7 decode(var_TOKEN); 8 decode(var_TOKEN_2); 9} 10 11void protect_me() { 12 sensitive(var_TOKEN); 13} 14 15void protect_me_2() { 16 sensitive(var_TOKEN_2); 17} Since all the strings are decoded at once in one of the first constructors, if we manage to dump the binary right after this constructor, we can recover the original strings for free.\nProgrammatically, it can be done using (again) frida-gum SDK with the following pseudocode:\n1// Hook associated with ImageLoader::containsAddress 2void native_listener_on_enter(GumInvocationListener* listener, 3 GumInvocationContext* ic) { 4 static size_t CTOR_ID = 0; 5 const uintptr_t ctor_function_addr = ic-\u0026gt;cpu_context-\u0026gt;x[1]; 6 std::string libname = module_from_addr(ctor_function_addr); 7 if (libname == \u0026#34;NianticLabsPlugin\u0026#34; \u0026amp;\u0026amp; CTOR_ID++ == 3) { 8 const uintptr_t base_address = base_addr_from_ptr(ctor_function_addr); 9 auto bin = LIEF::MachO::Parser::parse_from_memory(base_address); 10 bin-\u0026gt;write(\u0026#34;/tmp/pokemongo_after_ctor.bin\u0026#34;); // /tmp on the iPhone 11 } 12} In the end, the dumped file contains the decoded strings:\nIf we skim the __data section, we can also observe the following changes:\nA practiced eye might notice6 that some strings of the section are actually embedded in protobuf structures. We can confirm this observation by trying to infer the data as protobuf types:\n1from . import proto_dump 2import lief 3pgo = lief.parse(\u0026#34;pokemongo_after_ctor.bin\u0026#34;) 4 5start = 0x12A51A7 6end = 0x12A51E2 7raw_proto = pgo.get_content_from_virtual_address(start, end - start) 8print(proto_dump(raw_proto)) 1{ 2 #3 = 4 3 #4 (repeated) = 1 { 4 #1 = \u0026#34;CheatReputation\u0026#34; 5 #2 (repeated) = { 6 #1 = \u0026#34;UNSET\u0026#34; 7 #2 = 0 8 } { 9 #1 = \u0026#34;BOT\u0026#34; 10 #2 = 1 11 } { 12 #1 = \u0026#34;SPOOFER\u0026#34; 13 #2 = 2 14 } 15 } 16 #5 = 8 17 #8 = [] 18} Final Words The application embeds other checks in the constructors and in the functions returned by GetN2Api. It can make a good exercise for those that are interested in.\nGenerally speaking, the application and the protections are well designed since they slow down reverse engineers. Nevertheless, anti-{jb, frida, debug} are quite difficult to protect as they need to interact with the OS through functions or syscalls with unprotected parameters. As a result, and once identified, we can bypass them.\nOne technique consists in injecting a library with Frida\u0026rsquo;s injector that aims at hooking the containsAddress() to disable/patch the functions involved in the detections:\n Nevertheless, this technique is not persistent and version-dependant.\nAfter writing this post, it turned out that its structure is very close to Reverse Engineering Starling Bank. In particular, we can find the same anti-debug and the same Frida detection routine. These similarities suggest that these two application uses the same obfuscator that also provides anti-{jb, frida, debug} as built-in.\nYou might also be interested in the recent talk of Eloi Benoist-Vanderbeken @Pass the Salt   who detailed another approach to identify and bypass jailbreak detections.\nLIEF is a tool developed at Quarkslab along with QBDI \u0026amp; Triton.   Annexes    Files that trigger the JB detection Files that should be present     /.bootstrapped_electra /cores   /Applications/Anemone.app /dev/null   /Applications/Cydia.app /etc/hosts   /Applications/SafeMode.app /etc/passwd   /Library/Frameworks/CydiaSubstrate.framework /sbin   /Library/MobileSubstrate/DynamicLibraries/FlyJB.dylb /sbin/launchd   /Library/MobileSubstrate/MobileSubstrate.dylib /sbin/mount   /Library/PreferenceBundles/LaunchInSafeMode.bundle /usr   /Library/PreferenceLoader/Preferences/LaunchInSafeMode.plist    /Library/Themes    /Library/dpkg/info/com.inoahdev.launchinsafemode.list    /Library/dpkg/info/com.inoahdev.launchinsafemode.md5sums    /bin/bash    /bin/bunzip2    /bin/bzip2    /bin/cat    /bin/chgrp    /bin/chmod    /bin/chown    /bin/cp    /bin/grep    /bin/gzip    /bin/kill    /bin/ln    /bin/ls    /bin/mkdir    /bin/mv    /bin/sed    /bin/sh    /bin/su    /bin/tar    /binpack    /bootstrap    /chimera    /electra    /etc/apt    /etc/profile    /jb    /private/var/binpack    /private/var/checkra1n.dmg    /private/var/lib/apt    /usr/bin/diff    /usr/bin/hostinfo    /usr/bin/killall    /usr/bin/passwd    /usr/bin/recache    /usr/bin/tar    /usr/bin/which    /usr/bin/xargs    /usr/lib/SBInject    /usr/lib/SBInject.dylib    /usr/lib/TweakInject    /usr/lib/TweakInject.dylib    /usr/lib/TweakInjectMapsCheck.dylib    /usr/lib/libjailbreak.dylib    /usr/lib/libsubstitute.0.dylib    /usr/lib/libsubstitute.dylib    /usr/lib/libsubstrate.dylib    /usr/libexec/sftp-server    /usr/sbin/sshd    /usr/share/terminfo    /var/mobile/Library/.sbinjectSafeMode    /var/mobile/Library/Preferences/jp.akusio.kernbypass.plist       iPhone 6 running on iOS 14.2 with checkra1n.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n We can identify them by trial and error.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ETA: likely by the end of the year\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The Mach-O format is very suitable for this feature as the header in mapped in memory. Therefore, it eases the parsing.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n More generally, it can encode local data (strings, bytes arrays, \u0026hellip;)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Protobuf strings can be identified as they usually start with 0xA, 0xB, followed by their lengths and the string itself (see: protocol-buffers/docs/encoding)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1626566400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"5a603667ac0a847f9c12e6a764ffbd36","permalink":"https://www.romainthomas.fr/post/21-07-pokemongo-anti-frida-jailbreak-bypass/","publishdate":"2021-07-18T00:00:00Z","relpermalink":"/post/21-07-pokemongo-anti-frida-jailbreak-bypass/","section":"post","summary":"This blog post analyzes the Frida and Jailbreak detection in PokemonGO for iOS.","tags":["iOS","reverse engineering","obfuscation"],"title":"Gotta Catch 'Em All: Frida \u0026 jailbreak detection","type":"post"},{"authors":["Adrien Guinet","Romain Thomas"],"categories":null,"content":"QBDL (QuarkslaB Dynamic Loader) is a cross-platform library that enables to load ELF, PE and Mach-O binaries with an abstraction on the targeted system. It abstracts the memory model on which the binary is loaded and provides an enhanced API to the user to process symbols resolution. In a nutshell, it enables to load binaries on foreign systems without reinventing the wheel.\nHere is an example to load a Mach-O in Triton with QBDL:\n1class TritonVM(pyqbdl.TargetMemory): 2 def __init__(self, ctx: TritonContext): 3 super().__init__() 4 self.ctx = ctx 5 6 def mmap(self, ptr, size): 7 return ptr 8 9 def mprotect(self, ptr, size, access): 10 return True 11 12 def write(self, ptr, data): 13 self.ctx.setConcreteMemoryAreaValue(ptr, bytes(data)) 14 15 def read(self, ptr, size): 16 return self.ctx.getConcreteMemoryAreaValue(ptr, size) 17 18class TritonSystem(pyqbdl.TargetSystem): 19 def __init__(self, arch, ctx): 20 super().__init__(TritonVM(ctx)) 21 self.arch = arch 22 self.ctx = ctx 23 24 def symlink(self, loader, sym): 25 for name, impl, addr in externalFunctions: 26 if sym.name == name: 27 return addr 28 return 0 29 30 def supports(self, bin_): 31 return pyqbdl.Arch.from_bin(bin_) == self.arch 32 33 def base_address_hint(self, bin_ba, vsize): 34 return bin_ba 35 36x86_64_arch = pyqbdl.Arch(lief.ARCHITECTURES.X86, lief.ENDIANNESS.LITTLE, True) 37loader = pyqbdl.loaders.MachO.from_file(args.filename, x86_64_arch, 38 TritonSystem(x86_64_arch, ctx), pyqbdl.Loader.BIND.NOW) ","date":1622678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"56cca5f733ce0497aa03618871afae50","permalink":"https://www.romainthomas.fr/project/qbdl/","publishdate":"2021-06-03T00:00:00Z","relpermalink":"/project/qbdl/","section":"project","summary":"QuarkslaB Dynamic Loader: Generic loader for ELF, PE and Mach-O","tags":["lief","loader"],"title":"QBDL","type":"project"},{"authors":["Adrien Guinet","Romain Thomas"],"categories":null,"content":" Slides   Talk (In French)  ","date":1622678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"1434f07c2f56abf03dc60cddf3203049","permalink":"https://www.romainthomas.fr/publication/21-sstic-qbdl/","publishdate":"2021-06-03T00:00:00Z","relpermalink":"/publication/21-sstic-qbdl/","section":"publication","summary":"The QuarkslaB Dynamic Loader (QBDL) library aims at providing a modular and portable way to dynamically load and link binaries","tags":null,"title":"QBDL: QuarkslaB Dynamic Loader","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":" Slides   Whitepaper   Talk     Demo #1: Snapchat    Demo #2: Legu Packer  Note: The videos are intentionally quick. Do not hesite to pause them.\n","date":1601510400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"be538b60cdac768ef1a4eb66140bfc9a","permalink":"https://www.romainthomas.fr/publication/20-bh-asia-dbi/","publishdate":"2020-10-01T00:00:00Z","relpermalink":"/publication/20-bh-asia-dbi/","section":"publication","summary":"Android applications are becoming more and more obfuscated to prevent reverse engineering. While obfuscation can be applied on both, the Dalvik bytecode and the native code, the former is more challenging to analyze due to the structure of the bytecode as well as the API provided by Android Runtime. The purpose of this talk is to present dynamic binary instrumentation techniques that can help reverse engineers to deal with obfuscated codes. These techniques aim to be obfuscator resilient so that it does not rely on a special kind of obfuscation neither a specific obfuscator.","tags":null,"title":"Dynamic Binary Instrumentation Techniques to Address Native Code Obfuscation","type":"publication"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" .green { color:green; font-family: 'Fira Code', monospace; font-size: 87.5%; } .blue { color: blue; font-family: 'Fira Code', monospace; font-size: 87.5%; } .orange { color: #FF6347; font-family: 'Fira Code', monospace; font-size: 87.5%; } .red { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-comment { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-keyword { color: #A90D91; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-literal { color: #1C01CE; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-preproc { color: #633820; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-strings { color: #C41A16; font-family: 'Fira Code', monospace; font-size: 87.5%; } .yellow { color: #CC7000; font-family: 'Fira Code', monospace; font-size: 87.5%; } #  Introduction In the first part of this write-up, we described the anti-frida, anti-debug and anti-root techniques used in the application and how to remove most of them.\nThis second part digs into the JNI function gXftm3iswpkVgBNDUp and the underlying whitebox implementation.\nLibrary Shimming The inputs of the function gXftm3iswpkVgBNDUp are provided by the GUI widgets and the function is triggered when we press the Generate R2Coin button. Nevertheless, the behavior of gXftm3iswpkVgBNDUp does not rely on UI features nor the application\u0026rsquo;s context1.\nTo take a closer look at the logic of gXftm3iswpkVgBNDUp, it would be pretty useful to be able to feed the function\u0026rsquo;s inputs with our own standalone binary. Basically, we would like to achieve this kind of interface:\n1int main(int argc, char** argv) { 2 void* dlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); 3 ... 4 jbyteArray out = gXftm3iswpkVgBNDUp(env, ...); 5 return 0; 6} This technique is not new and has been already described in a blog post by Caleb Fenton2. The idea is to get the JNIEnv* env variable with JNI_CreateJavaVM which is exported by the Android runtime: libart.so.\nOnce we have this variable, we can call the gXftm3iswpkVgBNDUp function as well as manipulating the JNI buffers:\n env-\u0026gt;NewByteArray() env-\u0026gt;GetArrayLength() \u0026hellip;  Long story short, we can instantiate the Android runtime with the following piece of code:\n1int main(int argc, char** argv) { 2 JavaVMOption opt[2]; 3 opt[0].optionString = \u0026#34;-Djava.class.path=/data/local/tmp/re.pwnme.1.0.apk\u0026#34;; 4 opt[1].optionString = \u0026#34;-Djava.library.path=/data/local/tmp\u0026#34;; 5 6 JavaVMInitArgs args; 7 args.version = JNI_VERSION_1_6; 8 args.options = opt; 9 args.nOptions = 2; 10 args.ignoreUnrecognized = JNI_FALSE; 11 12 void* handler = dlopen(\u0026#34;/system/lib64/libart.so\u0026#34;, RTLD_NOW); 13 auto JNI_CreateJavaVM_f = reinterpret_cast\u0026lt;decltype(JNI_CreateJavaVM)*\u0026gt;(dlsym(handler, \u0026#34;JNI_CreateJavaVM\u0026#34;)); 14 JNI_CreateJavaVM_f(\u0026amp;jvm, \u0026amp;env, \u0026amp;args); 15} Then, we can resolve the gXftm3iswpkVgBNDUp function with the base address of libnative-lib.so and its offset 0x9B41C:\n1void* hdl = dlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); 2uintptr_t base_address = get_base_address(\u0026#34;libnative-lib.so\u0026#34;); 3 4using gXftm3iswpkVgBNDUp_t = jbyteArray(*)(JNIEnv*, jobject, jbyteArray, jbyte); 5gXftm3iswpkVgBNDUp = reinterpret_cast\u0026lt;gXftm3iswpkVgBNDUp_t\u0026gt;(base_address + 0x9B41C); Finally, we can run the function with our own inputs:\n1std::string pin_amount = \u0026#34;0000123400004567\u0026#34;; 2jbyteArray array = convert_to_jbyteArray(pin_amount, ptr); 3jbyteArray jencrypted_buffer = gXftm3iswpkVgBNDUp(env, nullptr, array, 0xF0); 4const std::vector\u0026lt;uint8_t\u0026gt; encrypted_buffer = from_jbytes(jencrypted_buffer); 5std::string hex_str = to_hex(encrypted_buffer); 6LOG_INFO(\u0026#34;{} --\u0026gt; {}\u0026#34;, pin_amount, ref_str); The whole implementation is available here .  Function Tracing Now that we are able to run the gXftm3iswpkVgBNDUp function without the GUI layer, we can easily create an interface with QBDI:\n1VM vm; 2vm.addInstrumentedModule(\u0026#34;libnative-lib.so\u0026#34;); 3... 4jbyteArray array = to_jarray(pin_amount, ptr); 5jbyteArray qbdi_encrypted_buffer; 6 7vm.call( 8 /* ret */ reinterpret_cast\u0026lt;uintptr_t*\u0026gt;(\u0026amp;qbdi_encrypted_buffer), 9 /* target */ reinterpret_cast\u0026lt;uintptr_t\u0026gt;(gXftm3iswpkVgBNDUp), 10 /* params */ { 11 /* p_0: JNIEnv* */ reinterpret_cast\u0026lt;rword\u0026gt;(env), 12 /* p_1: jobject thiz */ reinterpret_cast\u0026lt;rword\u0026gt;(nullptr), 13 /* p_2: inbuffer */ reinterpret_cast\u0026lt;rword\u0026gt;(array), 14 0xF0 15 } 16); The execution in QBDI without user\u0026rsquo;s callbacks takes about 3min 30s which is quite huge compared to the real execution that takes about 853ms:\nThis overhead is mostly due to the function 0x1038f0 that is executed ~20 000 times. After a quick analysis, it turns out that this function is not relevant to instrument to break the whitebox. We can force its real execution (i.e. outside QBDI) by removing the function\u0026rsquo;s address from the instrumented range3.\n1static constexpr uintptr_t HEAVY_FUNCTION = 0x1038f0; 2vm.removeInstrumentedRange( 3 base_address + HEAVY_FUNCTION, 4 base_address + HEAVY_FUNCTION + 1 5); This small adjustment drops the execution to 3'30sec.\n Some cryptographic algorithms can be fingerprinted either with predefined constants or with their memory accesses. According to the Quarkslab\u0026rsquo;s blog post: Differential Fault Analysis on White-box AES Implementations, the whitebox lookup tables are likely to be stored in the .data, .rodata, ... sections.\nBy looking at the sizes of these sections, only the .data section seems to have an appropriate size. We can generate a memory trace on this section to see if we can outline some patterns. It can be made with the following piece of code:\n1vm.recordMemoryAccess(MEMORY_READ_WRITE); 2vm.addMemRangeCB( 3 /* .data start address */ base_address + 0x127000, 4 /* .data end address */ base_address + 0x127000 + 0x8e000, 5 /* Record both: reads and writes */ MEMORY_READ_WRITE, 6 7 /* Memory callback */ 8 [] (VM* vm, GPRState*, FPRState*, void* data) { 9 auto ctx = reinterpret_cast\u0026lt;qbdi_ctx*\u0026gt;(data); 10 /* 11* \u0026#39;for\u0026#39; loop since on AArch64 we can have multiple reads / writes 12* at once. (e.g. stp x0, x1, [sp, #128]) 13*/ 14 for (const MemoryAccess\u0026amp; mem_access : vm-\u0026gt;getInstMemoryAccess()) { 15 ctx-\u0026gt;trace-\u0026gt;push_back({ 16 mem_access.instAddress - base_address, 17 mem_access.accessAddress - base_address, 18 mem_access.size, 19 }); 20 } 21 22 return VMAction::CONTINUE; 23 }, \u0026amp;ctx); Generating the memory trace takes about 11sec which is acceptable.  It leads to the following graph in which we can notice a characteristic pattern at the end of the trace:\nFault Injection The pattern at the end of the trace is quite characteristic of AES-128 where we can identify 10 rounds. We now have all the necessary information to make a fault injection attack:\n We can identify the 9th round We can accurately fault the .data section thanks to the memory trace  The memory trace is available in the  mem_trace.json file of the repository.  To efficiently make the injection, we can first reduce the memory addresses to only keep those that are used in the last 2 rounds:\n1trace_file = CWD / \u0026#34;..\u0026#34; / \u0026#34;assets\u0026#34; / \u0026#34;mem_trace.json\u0026#34; 2trace = json.loads(trace_file.read_bytes())[0] 3 4# Keep the entries that are involved in the last 2-rounds (empirical number) 5nice_trace = trace[-1000:] Then, we can use our shim mechanism to inject the faults in the .data section with the addresses previously selected. Moreover, we can reduce the set of .data addresses with the faults that introduce exactly 4 differences in the ciphertext:\n1// Make sure the .data section is writable 2mprotect( 3 reinterpret_cast\u0026lt;void*\u0026gt;(base_address + /* .data */ 0x127000), 4 0x8e000, 5 PROT_READ | PROT_WRITE 6); 7 8for (uintptr_t fault_addr : selected_addresses) { 9 uint8_t\u0026amp; target_byte = *reinterpret_cast\u0026lt;uint8_t*\u0026gt;(base_address + fault_addr); 10 uint8_t backup = target_byte; 11 12 // Fault 1 byte: 13 target_byte ^= 0x33; 14 15 // Run the whitebox with the faulty byte 16 const std::vector\u0026lt;uint8_t\u0026gt; encrypted = encrypt(msg); 17 18 // Restore the original byte 19 target_byte = backup; 20 21 // Compute the number of errors 22 // ... 23} Finally, with the subset of the addresses that affect exactly 4 bytes, we can generate several faults for a given address:\n1for (uintptr_t nice_fault_addr : four_bytes_fault_addresses) { 2 for (size_t i = 0; i \u0026lt; 255; ++i) { 3 const std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; output = inject_fault(addr, PIN_AMOUNT, i); 4 const size_t nb_errors = get_error(genuine_value, output); 5 if (nb_errors == 4 and unique.insert(output).second) { 6 // Record the entry ... 7 } 8 } 9} The aforementioned code gives an idea about how to generate the faults. One can find the whole implementation in this file: shim-whitebox/src/main.cpp that produces this set of files assets/wb-traces.\nKey Extraction Thanks to the  Side-Channel Marvels project, we can use JeanGrey \u0026mdash; developed by Philippe Teuwen \u0026mdash; to recover the whitebox\u0026rsquo;s key from the faulty traces:\n1import pathlib 2import phoenixAES 3 4CWD = pathlib.Path(__file__).parent 5trace_dir = CWD / \u0026#34;..\u0026#34; / \u0026#34;assets\u0026#34; / \u0026#34;wb-traces\u0026#34; 6 7for f in trace_dir.iterdir(): 8 x = phoenixAES.crack_file(f) 9 if x is not None: 10 print(x, f.name) It provides the following results which enable to retrieve the key:\n1$ python wb_key_recovery.py 2..8D....7F............9A....79.. injection-1a930d.trace 3..8D....7F............9A....79.. injection-1a95bd.trace 4....19....62....B0............8F injection-1a91b2.trace 5....19....62....B0............8F injection-1a8fdf.trace 676............1E....D3....E1.... injection-1a8549.trace 7......E1....A0....CD....28...... injection-1a8978.trace 8....19....62....B0............8F injection-1a90ce.trace 9....19....62....B0............8F injection-1a8efd.trace 10r 2 p 4 y 1 s N 0 w S e c u r 3 Finally, we can verify that r2p4y1sN0wSecur3 is the right key by trying to decrypt 9497cdf1df2600e7f63778d0ae91dcbb4:\n1from Crypto.Cipher import AES 2WB_KEY = b\u0026#34;r2p4y1sN0wSecur3\u0026#34; 3 4cipher = AES.new(WB_KEY, AES.MODE_ECB) 5output = cipher.decrypt(bytes.fromhex(\u0026#34;9497cdf1df2600e7f63778d0ae91dcbb\u0026#34;)) 6print(output.decode()) 1$ python ./aes_test.py 20000123400004567 Side note about the .data section Most of the obfuscators encode strings so that we don\u0026rsquo;t have any clue about functions\u0026rsquo; logic. The obfuscator used in the challenge follows this rule and running the strings utility on the library does not reveal any interesting information.\nNevertheless, we can find a lot of .datadiv_decode\u0026lt;random hex\u0026gt; in the ELF constructors of the library. As explained in the previous part, they are generated by the obfuscator and aimed to decode the strings.\nSince these functions are in the ELF constructors, this means that they are executed as soon as the library is loaded. In particular, when calling dlopen(...) these constructors are executed. It can be confirmed by dumping the .data section right after dlopen():\n1dlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); 2std::ofstream ofs{fmt::format(\u0026#34;/data/local/tmp/{}\u0026#34;, output)}; 3auto start = reinterpret_cast\u0026lt;const char*\u0026gt;(base_address + 0x127000); 4ofs.write(start, /* sizeof(.data) */ 0x8d49f); Then, we can compare the bytes distribution with binvis.io:\nAt the end of the in-memory .data section, we can found interesting strings used to detect Frida and the device\u0026rsquo;s root state.\nConclusion Thanks again to Eduardo Novella (@enovella_) and Gautam Arvind (@darvincisec) for this second part of the challenge :)\nAlso thanks to Quarkslab that allowed this publication. One can find related blog posts about whitebox attacks on the Quarkslab\u0026rsquo;s blog:\n  Introduction to Whiteboxes and Collision-Based Attacks With QBDI  by Paul Hernault (@0xAcid)\n  When SideChannelMarvels meet LIEF \n  Differential Fault Analysis on White-box AES Implementations by Philippe Teuwen (@doegox). I used this blog post as a reference to resolve this part of the challenge.\n  References   https://developer.android.com/reference/android/content/Context\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n QBDI will execute the function using the ExecBroker mechanism.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n It is the output of the function when entering 1234 in the PIN field and 4567 in the amount field.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1601164800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"22a0d53d8bd74d4cfb25cc6fcaf6938b","permalink":"https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part2/","publishdate":"2020-09-27T00:00:00Z","relpermalink":"/post/20-09-r2con-obfuscated-whitebox-part2/","section":"post","summary":"This second blog post explains how to recover the whitebox's key from the obfuscated library libnative-lib.so","tags":["android","reverse engineering","write-up","obfuscation","whitebox","cryptography"],"title":"r2-pay: whitebox (part 2)","type":"post"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" .green { color:green; font-family: 'Fira Code', monospace; font-size: 87.5%; } .blue { color: blue; font-family: 'Fira Code', monospace; font-size: 87.5%; } .orange { color: #FF6347; font-family: 'Fira Code', monospace; font-size: 87.5%; } .red { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-comment { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-keyword { color: #A90D91; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-literal { color: #1C01CE; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-preproc { color: #633820; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-strings { color: #C41A16; font-family: 'Fira Code', monospace; font-size: 87.5%; } .yellow { color: #CC7000; font-family: 'Fira Code', monospace; font-size: 87.5%; } #  Introduction This series of blog posts explains one way to resolve the r2-pay challenge released during the r2con2020 conference. This first part is about the anti-analysis tricks used to hinder reverse-engineering while the second part will be more focused on breaking the whitebox.\nThe resolution took me more than a week-end but it covers nice topics that worth it: obfuscation \u0026amp; whitebox. It was also the opportunity to practice attacks against whiteboxes and to test SideChannelMarvels/JeanGrey developed by Philippe Teuwen (aka. @doegox).\nThe challenge has been resolved with the AArch64 version on a device running on Android 9 and rooted with Magisk.\n    Note Here are the files used in this write-up:\n re.pwnme.1.0.apk - af019d3016720592aade7bde9890110c\n libnative-lib.so (arm64-v8a version)\n    Overview When opening the application on a non-tempered device (or with Magisk hide enabled), we are asked to enter a PIN and an amount that is used to generate a token.\nTo resolve the challenge, we have to find the master key that is used to generate the token. Few days before the CTF I was told that one of the challenges would involve an obfuscated whitebox\u0026hellip;\nThe main interface of the APK is located in the Java class re.pwnme.MainActivity which forwards the user inputs (PIN \u0026amp; amount) to a JNI function named gXftm3iswpkVgBNDUp. This function takes the concatenated input $PIN\\ ||\\ Amount$ and returns the token as a byte array.\nThe static constructor of the class loads the \u0026ldquo;native-lib\u0026rdquo; library which is available for the architectures: arm64-v8a, armeabi-v7a, and x86_64. Unsurprisingly, this library is obfuscated and some symbols suggest that it has been compiled with a fork of O-LLVM 1.\nIn addition, the library does not export the expected symbol Java_re_pwnme_MainActivity_gXftm3iswpkVgBNDUp but prefers to use the JNI_OnLoad technique 2. JNI_OnLoad() is also obfuscated along with control-flow-flattening.\nThe main task of the challenge is to understand the logic of the gXftm3iswpkVgBNDUp function to figure out how the token is generated.\nAnti-Root \u0026amp; Anti-Frida Along with the libnative-lib.so library, the applications embeds another library libtool-checker.so whose name sounds quite familiar: it comes from the open-source project rootbeer which is used to detect if the device is rooted.\nSome of the root-checks are done in the MainActivity class and if the device is rooted the application raises an exception by dividing a number with 0.\nOn this point, we can disable the check by using Frida on the rootbeer\u0026rsquo;s functions involved in the detection:\n1// frida -U -l ./bypass-root.js --no-pause -f re.pwnme 2Java.perform(function () { 3 var RootCheck = Java.use(\u0026#39;\\u266b.\\u1d64\u0026#39;); 4 5 RootCheck[\u0026#39;â‚¤\u0026#39;].implementation = function () { 6 console.log(\u0026#34;Skip root\u0026#34;); 7 return false; 8 } 9 10 RootCheck[\u0026#39;Î¸\u0026#39;].overload().implementation = function () { 11 console.log(\u0026#34;Skip root\u0026#34;); 12 return false; 13 } 14}) Nevertheless, the application still crashes as soon as it starts and generates the following backtrace:\n1F libc : Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095 in tid 8875 (re.pwnme), pid 8849 (re.pwnme) 2F DEBUG : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** 3F DEBUG : Build fingerprint: \u0026#39;google/taimen/taimen:9/PQ3A.190801.002/5670241:user/release-keys\u0026#39; 4F DEBUG : Revision: \u0026#39;rev_10\u0026#39; 5F DEBUG : ABI: \u0026#39;arm64\u0026#39; 6F DEBUG : pid: 8849, tid: 8875, name: re.pwnme \u0026gt;\u0026gt;\u0026gt; com.google.android.gms \u0026lt;\u0026lt;\u0026lt; 7F DEBUG : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095 8F DEBUG : x0 0000007f041f6610 x1 0000007f2565c800 x2 0000007f25600000 x3 000000000000001d 9F DEBUG : x4 000000000000005c x5 0000000000000001 x6 0000000000000001 x7 0000000000000000 10F DEBUG : x8 0000007f041f6610 x9 0000007f041f6600 x10 00000000fa929095 x11 00000000000035b2 11F DEBUG : x12 00000000e34d79ac x13 00000000fffffff7 x14 00000000a139577d x15 0000000000000001 12F DEBUG : x16 0000007fa66af220 x17 0000007fa65e3608 x18 0000000000000000 x19 0000007f041f6680 13F DEBUG : x20 0000000000000000 x21 0000000000000000 x22 0000229100002291 x23 0000000000000000 14F DEBUG : x24 0000007f041ff570 x25 0000007f04102000 x26 0000007fab1ad5e0 x27 0000007f0421a690 15F DEBUG : x28 0000007f04209080 x29 0000007f041ff490 16F DEBUG : sp 0000007f041f65f0 lr 0000007f0423de04 pc 0000007f0423f980 17F DEBUG : 18F DEBUG : backtrace: 19F DEBUG : #00 pc 000000000003f980 /data/app/re.pwnme-7O3ynhSmMsg2_E5_uqbQxQ==/lib/arm64/libnative-lib.so The backtrace suggests that other checks are performed in the native library. By looking at the ELF\u0026rsquo;s constructors, we can notice two functions that differ from those generated by the obfuscator:\n.datadiv_decode13003153710004289592 functions are in the ELF constructors since they decode global strings that need to be available as soon as the library is loaded.  By tracing these functions with QBDI, we quickly understand that sub_9080 iterates over /proc/self/maps with the syscalls openat/read that are located at the addresses 0x009870 and 0x00b448.\nThen, we observe the following sequence:\n10x011fb0: syscall: openat(0xffffffffffffff9c, \u0026#39;/system/lib64/libc.so\u0026#39;) 2 30x012884: syscall: read(51, 0x7ffc006c58, 64): \u0026#39;ELF@)@8@\u0026#39; 4 50x013170: syscall: lseek(51, 0x112918, 0) 6 70x0145f8: syscall: read(51, 0x7ffc006c18, 64) 80x0145f8: syscall: read(51, 0x7ffc006c18, 64) 90x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;/ \u0026#39; 100x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;B88\u0026#39; 110x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;J\u0026gt;\u0026#39; 120x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;RoP)\u0026#39; 130x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;\\o((\u0026#39; 140x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;io\u0026#39; 150x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;xo0\u0026#39; 160x0145f8: syscall: read(51, 0x7ffc006c18, 64) 170x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;Bxx`-\u0026#39; 180x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;PP`\u0026#39; 19 200x0151f4: malloc(0x18): 0x7f0c21f4c0 210x0156e4: syscall: lseek(51, 0x1a650, 0) 220x015a68: malloc(0x1e60): 0x7f0acb2000 230x015fa0: syscall: read(51, 0x7f0acb2000, 0x1e60): \u0026#39;{n@b r@ v@ z@ ~@ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ A A\u0026#34; AB Ab A A A A \u0026#34;A \u0026amp;A\u0026#34; *AB .Ab 2A 6A :A \u0026gt;A BA FA\u0026#34; JAB NAb RA VA ZA ^A bA fA\u0026#34; jAB nAb rA vA zA ~A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A B B\u0026#34; BB Bb B B B B \u0026#34;B \u0026amp;B\u0026#34; *BB .Bb 2B 6B :B \u0026gt;B BB FB\u0026#34; JBB NBb RB VB ZB ^B bB fB\u0026#34; jBB nBb rB vB zB ~B B B\u0026#34; BB Bb B B B B B B\u0026#34; B ...\u0026#39; 240x016cfc: free(0x7f0acb2000) -\u0026gt; {n@b r@ v@ z@ ~@ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ A A\u0026#34; AB Ab A A A A \u0026#34;A \u0026amp;A\u0026#34; *AB .Ab 2A 6A :A \u0026gt;A BA FA\u0026#34; JAB NAb RA VA ZA ^A bA fA\u0026#34; jAB nAb rA vA zA ~A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A B B\u0026#34; BB Bb B B B B \u0026#34;B \u0026amp;B\u0026#34; *BB .Bb 2B 6B :B \u0026gt;B BB FB\u0026#34; JBB NBb RB VB ZB ^B bB fB\u0026#34; jBB nBb rB vB zB ~B B B\u0026#34; BB Bb B B B B B B\u0026#34; B ... 250x017118: syscall: close(51) From this output, we can infer the following logic:\n 0x011fb0: the function opens the libc 0x012884: it reads the ELF header 0x013170: it jumps to the ELF sections table 0x0145f8: it looks for the .plt section 0x015a68, 0x015fa0: it reads the content of the .plt section  These operations suggest that the function checks if the .plt of /system/lib64/libc.so is not tampered with. In particular, if we use Frida on a libc\u0026rsquo;s function this check won\u0026rsquo;t pass.\nAfter this check, the function sub_9080 spawns a thread:\n10x0195dc: pthread_create(0xf1079f10, 0x0, 0x1a690, 0x0) The libc integrity check makes more sense as it is probably used to protect the library against a hook of pthread_create().\nThe thread\u0026rsquo;s routine sub_1a690 starts by making two calls to the mathematical function tan():\n10x01b774: tan(0.): 0. 20x01b79c: tan(-7832.0): -0.00951489 30x01cc74: memcpy(0x7ffc006598, libnative-lib.so!0x1267f0, 80) -\u0026gt; !7Nl 40x01ceb8: rand() 50x01f774: tan(0.): 0. 60x01f79c: tan(-7832.0): -0.00951489 My understanding of these calls is that the application tries to protect against tools that would not support floating-point instructions such as FCMP or FMOV. In addition, I think that if we mock the behavior of tan() with a constant value it would trigger a crash.\nThen it follows a check of TracerPid value in /proc/self/status. This value is set when the process is ptrace-debugged (which is the case with gdb). Dynamically, we observe syscalls that open /proc/self/status and read the content byte-per-byte:\n10x020ee0: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/status\u0026#39;): 51 20x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;N\u0026#39; 30x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;a\u0026#39; 40x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;m\u0026#39; 50x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 60x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;:\u0026#39; 70x0231e8: syscall: read(51, 0x7ffc00656c, 1) 80x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;r\u0026#39; 90x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 100x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;.\u0026#39; 110x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;p\u0026#39; 120x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;w\u0026#39; 130x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;n\u0026#39; 140x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;m\u0026#39; 150x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 160x0231e8: syscall: read(51, 0x7ffc00656c, 1) 170x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;S\u0026#39; 180x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;t\u0026#39; 190x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;a\u0026#39; 200x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;t\u0026#39; 210x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 220x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;:\u0026#39; 23... Anti-Frida #1 Still in the thread\u0026rsquo;s routine sub_1a690, the function checks if Frida is running by looking at all the values of /proc/self/task/\u0026lt;tid\u0026gt;/status and by checking if one of the names is gmain. It turns out that it\u0026rsquo;s the case when Frida is used in the application :-)\n10x0368e4: snprintf(\u0026#39;/proc/self/task/9719/status\u0026#39;, \u0026#39;/proc/self/task/%s/status\u0026#39;): \u0026#39;/proc/self/task/9719/status\u0026#39; 20x036a1c: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/task/9719/status\u0026#39;) 30x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;N\u0026#39; 40x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;a\u0026#39; 50x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;m\u0026#39; 60x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;e\u0026#39; 70x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;:\u0026#39; 80x03897c: syscall: read(73, 0x7ffc400af4, 1) 90x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;g\u0026#39; 100x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;m\u0026#39; 110x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;a\u0026#39; 120x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;i\u0026#39; 130x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;n\u0026#39; 140x03897c: syscall: read(73, 0x7ffc400af4, 1) 150x03897c: closedir() 16# Crash! To bypass this check, one can statically patch the syscall or we can dynamically change the behavior of snprintf(..., '/proc/self/task/%s/status') in order to always returns the same status (e.g. /proc/self/task/123/status). Concretely, it could be done by hooking snprintf and by forcing the output string to /proc/self/task/123/status.\nAnti-Frida #2 Still in the sub_1a690 function, the anti-frida checks continue by inspecting the file descriptors of the process. It iterates over /proc/self/fd/%s and looks at the underlying symlink.\nFrida server \u0026mdash; which is running globally on the device \u0026mdash; and Frida agent \u0026mdash; which is injected in the process \u0026mdash; communicate with named pipes that are associated with a file descriptor.\nIf Frida server is running, we can observe the following values:\n10x04308c: lstat(\u0026#39;/proc/self/fd/32\u0026#39;) 20x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/32\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;anon_inode:[eventfd]\u0026#39; 30x041844: readdir(\u0026#39;33\u0026#39;) 40x043078: snprintf(\u0026#39;/proc/self/fd/33\u0026#39;, \u0026#39;/proc/self/fd/%s\u0026#39;): \u0026#39;/proc/self/fd/33\u0026#39; 50x04308c: lstat(\u0026#39;/proc/self/fd/33\u0026#39;) 60x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/33\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;anon_inode:[eventfd]\u0026#39; 7 80x041844: readdir(\u0026#39;34\u0026#39;) 90x043078: snprintf(\u0026#39;/proc/self/fd/34\u0026#39;, \u0026#39;/proc/self/fd/%s\u0026#39;): \u0026#39;/proc/self/fd/34\u0026#39; 100x04308c: lstat(\u0026#39;/proc/self/fd/34\u0026#39;) 110x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/34\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;/data/local/tmp/re.frida.server/linjector-500\u0026#39; 12# Crash! In this case, the file descriptor 34 is associated with /data/local/tmp/re.frida.server/linjector-500 which triggers the detection and the application crashes.\nAs for /proc/self/task/\u0026lt;tid\u0026gt;/status, one can disable this check by statically patching the syscalls or by dynamically changing the result of readlinkat(). For instance, we can use QBDI to instrument syscall instructions and process the result of readlinkat() in an user callback:\n1 2vm.addMnemonicCB(\u0026#34;SVC\u0026#34;, POST_INST, 3 [] (VMInstanceRef vm, GPRState* gprState, FPRState*, void* data) { 4 if (gprState-\u0026gt;x8 != __NR_readlinkat) { 5 return VMAction::CONTINUE; 6 } 7 8 std::string buf = reinterpret_cast\u0026lt;char*\u0026gt;(gprState-\u0026gt;x2); 9 if (buf.find(\u0026#34;re.frida.server\u0026#34;) != std::string::npos) { 10 static const std::string FAKE_VALUE = \u0026#34;anon_inode:[eventfd]\u0026#34;; 11 // Bypass Frida detection! 12 memcpy( 13 reinterpret_cast\u0026lt;void*\u0026gt;(gprState-\u0026gt;x2), 14 reinterpret_cast\u0026lt;void*\u0026gt;(FAKE_VALUE.c_str()), 15 FAKE_VALUE.size() + 1 16 ); 17 gprState-\u0026gt;x0 = FAKE_VALUE.size() + 1; 18 } 19 20 return VMAction::CONTINUE; 21 22 }, ctx); Anti-Frida #3 ? I\u0026rsquo;m not sure if the following calls sequence is used to check the libc\u0026rsquo;s integrity against Frida but at the end of the thread\u0026rsquo;s routine, we can observe these syscalls:\n10x048ff0: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/maps\u0026#39;): 51 20x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;1\u0026#39; 30x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;2\u0026#39; 40x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;c\u0026#39; 50x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 60x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 70x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 80x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 90x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 10... 110x0513f8: sscanf(\u0026#39;7fa65c0000-7fa65dc000 r-xp 00000000 08:07 1275/system/lib64/libc.so\u0026#39;, \u0026#39;%lx-%lx %s %s %s %s %s\u0026#39;) 120x056034: syscall: close(51) The result of sscanf() could be used to check the page permissions (e.g. rwxp) or to the libc\u0026rsquo;s base address (to check if it is consistent).\nAnti-Root In addition to the root-beer detection, the library embeds another root detection located in the second ELF constructor. This constructor \u0026mdash; sub_77D14 \u0026mdash; performs the same early checks as the first constructor on the libc\u0026rsquo;s .plt integrity before spawning another thread routine, sub_98c00.\n10x08861c: pthread_create(0xfa780b70, 0x0, 0x98c00, 0x0) By tracing the thread\u0026rsquo;s routine, we notice that it checks if su files are present on the device through three different calls:\n One call to open(): 0x099180: open(\u0026rsquo;/system/xbin/su\u0026rsquo;) One syscall to openat(): 0x0992a4: syscall: openat(\u0026hellip;, \u0026rsquo;/data/su\u0026rsquo;) One syscall to faccessat(): 0x0993f0: syscall: faccessat(\u0026rsquo;/sbin/su\u0026rsquo;)  10x099180: open(\u0026#39;/data/local/su\u0026#39;): -1 20x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/su\u0026#39;): -2 30x0993f0: syscall: faccessat(\u0026#39;/data/local/su\u0026#39;): -2 40x099180: open(\u0026#39;/data/local/bin/su\u0026#39;): -1 50x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/bin/su\u0026#39;): -2 60x0993f0: syscall: faccessat(\u0026#39;/data/local/bin/su\u0026#39;): -2 70x099180: open(\u0026#39;/data/local/xbin/su\u0026#39;): -1 80x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/xbin/su\u0026#39;): -2 90x0993f0: syscall: faccessat(\u0026#39;/data/local/xbin/su\u0026#39;): -2 100x099180: open(\u0026#39;/sbin/su\u0026#39;): 51 110x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/sbin/su\u0026#39;): 52 120x0993f0: syscall: faccessat(\u0026#39;/sbin/su\u0026#39;): 52 13Crash! By forcing the results of these functions to -1 or -2, we can disable the checks.\nHere is the list of the su-files that are used in this detection:\n /data/local/su /data/local/bin/su /data/local/xbin/su /sbin/su /su/bin/su /system/bin/su /system/bin/.ext/su /system/bin/failsafe/su /system/sd/xbin/su /system/usr/we-need-root/su /system/xbin/su /cache/su /data/su /dev/su  At the end of the thread\u0026rsquo;s routine, we can also observe the following calls that are probably used to check if the application is running on a real Android system.\n10x099e30: syscall: faccessat(\u0026#39;/system\u0026#39;) 20x099e30: syscall: faccessat(\u0026#39;/system/bin\u0026#39;) 30x099e30: syscall: faccessat(\u0026#39;/system/sbin\u0026#39;) 40x099e30: syscall: faccessat(\u0026#39;/system/xbin\u0026#39;) 50x099e30: syscall: faccessat(\u0026#39;/vendor/bin\u0026#39;) 60x099e30: syscall: faccessat(\u0026#39;/sbin\u0026#39;) 70x099e30: syscall: faccessat(\u0026#39;/etc\u0026#39;) Static bypass with LIEF In the previous sections, we described the anti-root, anti-debug and anti-frida checks made in the ELF constructors. The same dynamic checks are also performed in the gXftm3iswpkVgBNDUp function at the following locations:\n 0x09f2f8: /proc/self/status 0x0d4840: /proc/self/fd/ 0x0dec8c: /proc/self/task/\u0026lt;tid\u0026gt;/status  While the checks in gXftm3iswpkVgBNDUp can be dynamically disabled when instrumenting the function, the checks in the ELF constructors are annoying.\nOne way to disable the checks in the thread\u0026rsquo;s routines is to disable the pthread_create(...). It can be achieved by patching the .plt entry associated with the function:\n1mov x0, xzr; 2ret; Thanks to llvm-mc, we can get the raw bytes of these instructions:\n1$ echo \u0026#34;mov x0, xzr;ret;\u0026#34;|llvm-mc -arch=aarch64 -show-encoding 23.text 4mov x0, xzr // encoding: [0xe0,0x03,0x1f,0xaa] 5ret // encoding: [0xc0,0x03,0x5f,0xd6] Finally, we can patch the .plt with LIEF:\n1import lief 2lib = lief.parse(\u0026#34;./libnative-lib.so\u0026#34;) 3lib.patch_address(0x5870, [0xe0,0x03,0x1f,0xaa]) 4lib.patch_address(0x5874, [0xc0,0x03,0x5f,0xd6]) 5lib.write(\u0026#34;./libnative-lib-patched.so\u0026#34;) Using these patches and the Frida script exposed in the first section, we are able to load the application but the other detections are triggered in gXftm3iswpkVgBNDUp. Nevertheless, with the Frida\u0026rsquo;s stalker or QBDI we can trace the instructions and disable the other checks.\nIf one wants to completely bypass all the protections statically, here are the patches:\n1import lief 2lib = lief.parse(\u0026#34;./libnative-lib.so\u0026#34;) 3 4# Keys are str objects for a better understanding :) 5INST = { 6 \u0026#34;mov x0, #0\u0026#34;: [0xe0, 0x03, 0x1f, 0xaa], 7 \u0026#34;ret\u0026#34;: [0xc0, 0x03, 0x5f, 0xd6], 8 \u0026#34;nop\u0026#34;: [0x1f, 0x20, 0x03, 0xd5], 9} 10 11PATCHES = [ 12 # Patch the .plt entry of pthread_create 13 (0x5870, INST[\u0026#34;mov x0, #0\u0026#34;]), 14 (0x5874, INST[\u0026#34;ret\u0026#34;]), 15 16 # Disable anti-frida checks 17 (0x0d718c, INST[\u0026#34;mov x0, #0\u0026#34;]), # /proc/self/fd : patch the result of readlinkat syscall 18 (0x0e1940, INST[\u0026#34;mov x0, #0\u0026#34;]), # /proc/self/task/\u0026lt;tid\u0026gt;/status: patch the result of read syscall 19 20 # Disable .text integrity checks 21 (0xB64D0, INST[\u0026#34;nop\u0026#34;]), 22] 23 24for patch in PATCHES: 25 lib.patch_address(*patch) 26 27lib.write(\u0026#34;libnative-lib.so\u0026#34;) When writing this write-up, I realized that patching the syscalls involved in the anti-frida (/proc/self/fd/ and /proc/self/task/\u0026lt;tid\u0026gt;/status) makes the application crash.\nIt turns out that the library seems to implement code integrity on the .text section that I didn\u0026rsquo;t notice when running the function through QBDI. Nevertheless, by tracing the basic block3 we can identify the basic block involved in the integrity check and patch it.\nThe scripts and the patched library are available here .  Regarding JNI_OnLoad(), a trace generated with QBDI\u0026rsquo;s ExecBroker leads to following result:\n1JNI_OnLoad() { 2 0x09af3c: GetEnv(0x7fcb507460, 0x10006) 3 0x09b0ac: FindClass(\u0026#34;re/pwnme/MainActivity\u0026#34;): 537 4 0x09b1b4: RegisterNatives() 5 gXftm3iswpkVgBNDUp ([BB)[B -\u0026gt; \u0026#34;libnative-lib.so@0x9b41c\u0026#34; 6} Then, we can extract the function\u0026rsquo;s offset: gXftm3iswpkVgBNDUp: 0x9b41c.\nSummary \u0026amp; Conclusion Whilst Frida detections are usually based on sockets and library names in /proc/self/maps, this challenge introduces two detections based on named pipes:/proc/self/fd and thread status: /proc/self/task/\u0026lt;tid\u0026gt;/status which are pretty cool :-)\nThese checks are performed in two locations:\n The ELF constructors The function gXftm3iswpkVgBNDUp()  The implementation in the ELF constructors might be tricky to analyse since the functions are called before any other classical functions (which includes JNI_OnLoad()). Nevertheless, thanks to the interface of the ELF loader, it exposes the function call_array(...)4 which is handy to process the ELF constructors.\nThis function is mangled as __dl__ZL10call_arrayIPFviPPcS1_EEvPKcPT_mbS5_ in /system/bin/linker64  Since QBDI is not detected in this challenge, it\u0026rsquo;s a good opportunity to give it a try:\n   https://github.com/QBDI/QBDI  Acknowledgments Thanks to Eduardo Novella (@enovella_) and Gautam Arvind (@darvincisec) for this interesting and realistic challenge they created!\nAlso thanks to Quarkslab that allowed this publication. For those who are interested in similar topics, you can take a look at the Quarkslab\u0026rsquo;s blog.\nReferences   GoSSIP-SJTU/Armariris - StringObfuscation.cpp#L140\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developer.android.com/training/articles/perf-jni#native-libraries\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n addVMEventCB(VMEvent::BASIC_BLOCK_ENTRY, ...);\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n linker/linker_soinfo.cpp:420\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":160056e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"9caa668feaa147d7e3172fbb0748659d","permalink":"https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part1/","publishdate":"2020-09-20T00:00:00Z","relpermalink":"/post/20-09-r2con-obfuscated-whitebox-part1/","section":"post","summary":"This first blog post describes the protections in the challenge r2-pay.","tags":["android","reverse engineering","write-up","obfuscation","whitebox"],"title":"r2-pay: anti-debug, anti-root \u0026 anti-frida (part 1)","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"Legu Unpacker Scripts to unpack Android applications protected by Tencent Legu. It only works with versions 4.1.0.15 and 4.1.0.18 of Legu.\nBlog post: https://www.romainthomas.fr/post/a-glimpse-into-tencents-legu-packer/\nOverview The original DEX files are located in assets/0OO00l111l1l with the following layout:\nOne can find the details of this structure in the Kaitai file: legu_packed_file.ks\nThe hashmap embedded in the second part is described in the legu_hashmap.ks file:\npylegu pylegu contains the Python bindings to decrypt and uncompress the data embedded in assets/0OO00l111l1l.\nTo compile and install pylegu:\n1$ cd pylegu 2$ python3.7 ./setup.py build -j4 install --user 3$ python -c \u0026#34;import pylegu\u0026#34; One could also use jap/pyucl to decompress the data and aguinet/dragonffi to bind the custom implementation of XTEA.\nGet Started The sample com.intotherain.voicechange.apk is a suspicious application that can be unpacked as follows:\n1$ python ./unpack.py ./samples/com.intotherain.voicechange.apk 2 3[+] Legu version: 4.1.0.15 4[+] Password is \u0026#39;IPk2Hw7AKTuIQBlc\u0026#39; 5[+] Number of dex files: 1 6[+] Unpacking #1 DEX files ... 7[+] dex 0 compressed size: 0x1619a3 8[+] dex 0 uncompressed size: 0x5671f8 9 10[+] Unpacking #1 hashmap ... 11[+] hashmap 0 compressed size: 0x4399c 12[+] hashmap 0 uncompressed size: 0x95558 13 14[+] Unpacking #1 packed methods ... 15[+] packed methods 0 compressed_size: 0xf4636 16[+] packed methods 0 uncompressed_size: 0x1e3072 17 18[+] Stage 2: Patching DEX files 19[+] Unpacked APK: unpacked.apk The unpacked DEX files are located in the unpacked.apk file.\nRequirements  Python \u0026gt;= 3.7 Kaitai Struct LIEF pylegu  ","date":1579737600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"a456ba06b0f13adb55cc423bbaa4319d","permalink":"https://www.romainthomas.fr/project/legu_unpacker/","publishdate":"2020-01-23T00:00:00Z","relpermalink":"/project/legu_unpacker/","section":"project","summary":"Scripts to unpack Android applications protected by Tencent Legu","tags":["android"],"title":"Tencent Legu Unpacker","type":"project"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" .packedfile { color:green; font-family: 'Lucida Console', monospace; } .keyfile { color: blue; font-family: 'Lucida Console', monospace; } .libshell { color: #FF6347; font-family: 'Lucida Console', monospace; } .tencentclass { color: #df2b04; font-family: 'Lucida Console', monospace; }      This post has been originally posted on the Quarkslab\u0026rsquo;s Blog      Introduction This blog post deals with the Legu packer, an Android protector developed by Tencent that is currently one of the state-of-the-art solutions to protect APK DEX files. The packer is updated frequently and this blog post focuses on versions 4.1.0.15 and 4.1.0.18.\nOverview An application protected with Legu is composed of two native libraries: libshell-super.2019.so and libshella-4.1.0.XY.so as well as raw binary files embedded in the resources of the APK:\n tosversion 0OO00l111l1l 0OO00oo01l1l o0oooOO0ooOo.dat  The main logic of the packer is located in the native library libshell-super.2019.so which basically unpacks and loads the protected DEX files from the resources.\nSome functions of the library are obfuscated but thanks to Frida/QBDI their analysis is not a big deal.\nInternals Basically, the original DEX files are located in the assets/0OO00l111l1l file along with the information required to unpack them.\nThe following figure lays out the structure of this file.\nIn the assets/0OO00l111l1l file, the first part contains the original DEX files with the same number of classes\u0026lt;N\u0026gt;.dex according to the multi-DEX feature of the original APK. These DEX files are not exactly the original ones, as their Dalvik bytecode have been NOP-ed by Legu. Therefore, a dump of these files only gives information about the classes\u0026rsquo; names, not the code logic:\nThen follows what we called a hashmap that is used to link a class name (e.g. Lcom/tencent/mmkv/MMKV;) to an offset in the data block located in the third part of the file. This data block contains the original Dalvik bytecode of the methods.\nActually, the first part that contains the altered DEX files, is compressed with NRV 1. The second part â€” the hashmap â€” is also compressed with NRV but the packer adds a layer of encryption through a slightly modified version of XTEA 2. Finally, the last part is compressed and encrypted with the same algorithms as the previous one.\nRegarding the hashmap, it uses a custom structure that has been reversed and lead to a Kaitai structure available here: legu_packed_file.ksy, legu_hashmap.ksy\nIts overall layout is exposed in the next figure:\nUnpacking process Let\u0026rsquo;s say that the application needs to use the packed Java class Lcom/tencent/mmkv/MMKV;.\nFirst, the packer\u0026rsquo;s runtime transforms the class name into an integer with the dvmComputeUtf8Hash() hash function 3. This integer is then used as an index into the hashmap whose value is a structure that contains information about the class in the packed data (blue area in the figure). The first attribute of this structure â€” utf8_hash â€” is a copy of the hash value which is used to check that it is the right key/value association.\nThe class_info structure (blue block in the figure) next contains the packed method information (yellow area in the figure) whose size is the same as the original number of methods in the class. This structure makes the relationship between the NOP-ed bytecode offset in the altered DEX files and the offset in the original bytecode (red block). Finally, the packer copies the original bytecode into the altered DEX files.\nTo summarize, the first part contains the original DEX files with the Dalvik bytecode removed (NOP-ed). The last part contains the missing Dalvik bytecode and the second part makes the bridge between the altered DEX files and the Dalvik bytecode.\nCompression \u0026amp; Encryption To decrypt the hashmap and the Dalvik bytecode, the packer uses the first 16 bytes of assets/tosversion xored with a hard-coded key: ^hHc7Ql]N9Z4:+1m~nTcA\u0026amp;3a7|?GB1z@.\n1LIB_KEY = b\u0026#34;^hHc7Ql]N9Z4:+1m~nTcA\u0026amp;3a7|?GB1z@\u0026#34; 2 3def key_derivation(key: bytes) -\u0026gt; bytes: 4 return bytes(x1 ^ x2 for x1, x2 in zip(LIB_KEY, cycle(key))) Then, it uses a slightly modified version of XTEA that is given in the next listing:\n1int xtea_decrypt(uint32_t* key, uint32_t* buf, size_t ilen, size_t nb_round) { 2 const size_t count = ilen / 8; 3 const size_t key_off = (ilen \u0026amp; 8) / 4; 4 static constexpr uint32_t DELTA = 0x9e3779b9; 5 6 const uint32_t key_0 = key[key_off + 0]; 7 const uint32_t key_1 = key[key_off + 1]; 8 9 for (size_t i = 0; i \u0026lt; count * 2; i += 2) { 10 buf[i + 0] ^= key_0; 11 buf[i + 1] ^= key_1; 12 13 uint32_t sum = DELTA * nb_round; 14 uint32_t temp0 = buf[i + 0]; 15 uint32_t temp1 = buf[i + 1]; 16 17 for (size_t j = 0; j \u0026lt; nb_round; ++j) { 18 temp1 -= (key[2] + (temp0 \u0026lt;\u0026lt; 4)) ^ (key[3] + (temp0 \u0026gt;\u0026gt; 5)) ^ (temp0 + sum); 19 temp0 -= (key[0] + (temp1 \u0026lt;\u0026lt; 4)) ^ (key[1] + (temp1 \u0026gt;\u0026gt; 5)) ^ (temp1 + sum); 20 sum -= DELTA; 21 } 22 buf[i + 0] = temp0; 23 buf[i + 1] = temp1; 24 } 25 return 0; 26} After the decryption routine, the packer decompresses the data with NRV, the same algorithm used to compress the altered DEX files:\n1key = key_derivation(open(\u0026#34;assets/tosversion\u0026#34;, \u0026#34;rb\u0026#34;).read()[:16]) 2for i in range(nb_dex_files): 3 hashmap[i] = nrv_decompress(xtea_decrypt(blob1, key)) 4 dalvik_bytecodes[i] = nrv_decompress(xtea_decrypt(blob2, key)) Unpacking Putting all the pieces together, we can statically unpack protected APKs and recover the original bytecode:\nHence, as we can automatically unpack such APKs, the unpacking process could be integrated into an automatic analysis pipeline.\nThe script and the Kaitai structures are available on the Quarkslab\u0026rsquo;s repository: legu_unpacker_2019, along with a suspicious application 4, packed and unpacked.\nAcknowledgments Thanks to my colleagues who proofread this article.\nReferences   http://www.oberhumer.com/opensource/ucl/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/XTEA\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://androidxref.com/4.4.4_r1/xref/dalvik/vm/UtfString.cpp#88\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.virustotal.com/gui/file/708e6967920dcf2789b7183d714e73ab79a2f8b3ca71929b12aadeb2c58c2867/detection\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1574726400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"a2bb3b32975c74e42cac7b55165ddd60","permalink":"https://www.romainthomas.fr/post/a-glimpse-into-tencents-legu-packer/","publishdate":"2019-11-26T00:00:00Z","relpermalink":"/post/a-glimpse-into-tencents-legu-packer/","section":"post","summary":"Analysis of Tencent Legu: a packer for Android applications.","tags":["android","reverse engineering","packer"],"title":"A Glimpse Into Tencent's Legu Packer","type":"post"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":"    This post has been originally posted on the Quarkslab\u0026rsquo;s Blog      Introduction During the past few months we improved the ARM support in QBDI. More precisely, we enhanced the QBDI\u0026rsquo;s engine to support Thumb and Thumb2 instructions as well as Neon registers.\nDevelopment is still in progress and we need to clean the code and add non-regression tests compared to the x86-64 support.\nTo add Thumb and Thumb2 support, we tested the DBI against well-known obfuscators such as Epona, O-LLVM or Arxan, as we could expect good instruction coverage, corner cases and nice use cases. The native code came from Android JNI libraries embedded in different APKs.\nThis blog post introduces some QBDI features that could be useful to assess native code and speedup reverse engineering. To expose these features, we analyzed an Android SDK that aims to protect applications against API misuse.\nDynamic Instrumentation on Android Frida is one of the Android day-to-day dynamic instrumentation framework widely used to instrument applications. It can address both native code with inline hooking and Java side thanks to ART instrumentation 1.\nFrida works at the function level and in some cases we may need to have a finer granularity at the basic-block level or at the instruction level (i.e. have hooks on instructions)\nTo address this limitation, one trick commonly used is to combine hooking with emulation. One can use Frida to hook the function that we are interested in, then we can dump the CPU context and the memory state of the process and eventually continue the execution through an emulator like Miasm or Unicorn\nThis approach works pretty well but has a few limitations:\n Speed: For large sets of functions. External calls: One needs to mock external calls behavior (e.g. strlen, malloc, \u0026hellip;). Some behaviors can be difficult to emulate: Thread, Android internal frameworks, \u0026hellip;  Moreover, while it is quite simple to mock the behavior of strlen, it may be more challenging to mock JNI functions behavior like FindClass(), GetMethodID(), RegisterNatives(), \u0026hellip;\nThe design of QBDI provides a good trade-off between full instrumentation and partial emulation thanks to the ExecBrocker that enables to switch between instrumented code â€” our function â€” and non-instrumented code: strlen(), FindClass(), pthread_call_once(), \u0026hellip;\nThis diagram represents the instrumentation flow for the different scenarios:\nFor those who are interested in QBDI internals you can look at the 34C3 talk by Charles and CÃ©dric 2. There are also examples in the GitHub repository 3.\nTo summarize, we can bootstrap QBDI as follows:\n1// QBDI main interface 2QBDI::VM vm; 3 4// QBDI CPU state for GPR registers 5GPRState* state = vm.getGPRState(); 6 7// Setup virtual stack 8uint8_t *fakestack = nullptr; 9QBDI::allocateVirtualStack(state, /* size */0x100000, \u0026amp;fakestack); 10 11// { 12// Setup instrumentation ranges, callbacks etc, ... 13// } 14 15// Start Instrumentation: 16uintptr_t retval; 17bool ok = vm.call(\u0026amp;retval, /* Address of the function to instrument */); 18// Instrumentation Finished SDK Overview Among the QBDI tests, we analyzed an SDK that aims to protect applications against API abuses. This kind of protection is used to protect API endpoints against illegitimate uses: emulator, bots, \u0026hellip;\nTo protect the main application, the solution collects information about the device state: rooted, debugged, custom, then encodes this information with a proprietary algorithm and sends the encoded data to a server.\nThe server decodes the information sent by the device collector, performs analyses to check the device integrity and sends back a token that handles the information about whether the device is corrupted or not.\nThe following figure summarizes this process:\nSuch architecture is robust and similar to the one in Safetynet 4. On the other hand, the SDK has fewer permissions than Safetynet, therefore it cannot collect as much data about the device as SafetyNet does.\nWe started the analysis by monitoring the network traffic between the SDK and its server. At some point, we can observe the following request:\nIt is JSON encoded and the characters that look like random values are the encoded information sent by the device collector.\nThe analysis of the SDK aims to address these questions:\n How the SDK checks if the device is rooted or not ? How the SDK detects if the application is being debugged ? What kind of information is collected from the device and how it is encoded ?  After a look at the Java layer, we found that the logic of the solution is implemented in a JNI library that will be named libApp.so 5. The library exposes the following JNI functions:\n!Â \nWith static analysis, we can identify that the function Java_XXX_JNIWrapper_ca3_14008() is the one involved in the generation of the sequence \u0026quot;QJRR{JJJGQJ~|MJJJ...\u0026quot;. It returns the encoded data as a java.lang.String and takes two parameters that are not mandatory: bArr, iArr 6.\nThe library as a whole is not especially obfuscated. Nonetheless, we find strings encoding and syscall replacement on well-known libc functions:\n read openat close \u0026hellip;  This technique is commonly used to avoid hooking but the fact is that the given syscalls are wrapped in functions that are not inlined. Hence, one can hook the functions that wrap the associated syscall.\nGet Started with QBDI In order to fully understand the logic of this function, we instrumented the function through QBDI 7 associated with a set of instrumentation callbacks.\nThese callbacks aim to provide different kinds of information that will be useful to the analyst to understand the function logic. For instance, we can setup a first callback that records all the syscall instructions, we can also add a callback that records memory access.\nThe purpose of this blog post is to show how few â€” but well chosen â€” callbacks enable to understand the logic of the function.\nFirst of all, the native library embedded in the SDK can be loaded outside of the original APK using dlopen() / dlsym(). Moreover, one can instantiate a JVM thanks to the ART runtime (libart.so):\n1int main(int argc, char** argv) { 2 3 static constexpr const char* TARGET_LIB = \u0026#34;libApp.so\u0026#34;; 4 void* hdl = dlopen(TARGET_LIB, RTLD_NOW); 5 6 using jni_func_t = jstring(*)(JNIEnv* /* Other parameters are not required */); 7 auto jni_func = reinterpret_cast\u0026lt;jni_func_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14008\u0026#34;)); 8 9 JavaVM* jvm, JNIEnv* env; 10 ART_Kitchen(jvm, env); // Instantiate the JVM and initialize the jvm and env pointers 11} At this point, the jni_func() function is tied to Java_XXX_JNIWrapper_ca3_14008 and ready to be executed in main():\n1jstring output = jni_func(env); 2const char* cstring = env-\u0026gt;GetStringUTFChars(output, nullptr); 3console-\u0026gt;info(\u0026#34;Real Output: {}\u0026#34;, cstring); The output seems consistent with the network capture and the value \u0026quot;root: 1\u0026quot; too since we are on a rooted device 8\nNow, let\u0026rsquo;s run the function through QBDI:\n1console-\u0026gt;info(\u0026#34;Initializing VM ...\u0026#34;); 2QBDI::VM vm; 3GPRState* state = vm.getGPRState(); 4 5uint8_t *fakestack = nullptr; 6QBDI::allocateVirtualStack(state, 0x100000, \u0026amp;fakestack); 7 8console-\u0026gt;info(\u0026#34;Instument module: {}\u0026#34;, TARGET_LIB); 9vm.addInstrumentedModule(TARGET_LIB); 10 11console-\u0026gt;info(\u0026#34;Simulate call in QBDI\u0026#34;); 12jstring dbioutput; 13bool ok = vm.call(\u0026amp;dbioutput, reinterpret_cast\u0026lt;rword\u0026gt;(jni_func), {reinterpret_cast\u0026lt;rword\u0026gt;(env)}); 14if (ok and dbioutput != nullptr) { 15 console-\u0026gt;info(\u0026#34;DBI output {:x}\u0026#34;, env-\u0026gt;GetStringUTFChars(dbioutput, nullptr)); 16} This code provides the following output:\nEverything looks good, QBDI managed to fully instrument the function (which includes ARM / Thumb switch) and the result is similar to the real execution.\nAnalysis Now that we are able to run and instrument the function, we can start to add instrumentation callbacks to analyze its behavior.\nOne of the first callbacks that is useful to setup is a callback that instruments syscall instructions (i.e. svc #0). To do so, we can use the vm.addSyscallCB(position, callback, data).\n position - It stands for the position of the callback: Before or after the syscall. callback - The callback itself. data - Pointer to user data (e.g. user context that register dynamic information)  It leads to the following piece of code:\n1auto syscall_enter_cbk = [] (VMInstanceRef vm, GPRState *gprState, FPRState *fprState, void *data) { 2 3 const InstAnalysis* analysis = vm-\u0026gt;getInstAnalysis(ANALYSIS_INSTRUCTION | ANALYSIS_DISASSEMBLY); 4 rword syscall_number = gprState-\u0026gt;r7; 5 /* 6* std::string sys_str = lookup[syscall_number]; // Lookup table that convert syscall number to function 7*/ 8 console-\u0026gt;info(\u0026#34;0x{:06x} {} ({})\u0026#34;, addr, analysis-\u0026gt;disassembly, sys_str); 9 10 return VMAction::CONTINUE; 11} 12 13vm.addSyscallCB(PREINST, syscall_enter_cbk, /* data */ nullptr); Before any syscall instructions, we perform a basic lookup on the syscall number stored in the R7 register to resolve its name.\nIt results in the following output:\nSince we are able to resolve syscall numbers into function names, we can improve the logic of callback to dispatch and print function parameters:\n1auto syscall_enter_cbk = [] (...) { 2 ... 3 /* 4* Lookup table (syscall number, function pointer) 5* { 6* 322 -\u0026gt; on_openat 7* } 8*/ 9 auto function_wrapper = func_lookup[syscall_number]; 10 return function_wrapper(...) 11} 12 13// Wrapper for openat syscall 14VMAction on_openat(VMInstanceRef vm, GPRState *gprState, ...) { 15 auto path = reinterpret_cast\u0026lt;const char*\u0026gt;(gprState-\u0026gt;r1); 16 console-\u0026gt;info(\u0026#34;openat({})\u0026#34;, path); 17 return VMAction::CONTINUE; 18} By doing so on the common syscalls number, we get this new trace:\nBased on this output, we can figure out how root check (orange area) is done. It is performed by checking the existence of the following binaries:\n /system/bin/su /system/xbin/su /sbin/su \u0026hellip;  The function also checks if some directories are present on the device (faccessat syscall):\n /data /tmp /system \u0026hellip;  Especially, it would be suspicious if the directory /tmp were present on the device while it is standard to have /system and /data directories.\nRegarding the debug state of the process (blue area), it is done by looking at /proc/self/status. After analysis, the function checks the TracerPID attribute (cf More Android Anti-Debugging Fun - B. Mueller)\nFinally, the function processes the output of /proc/self/maps right before to returning the encoded values. It suggests that the data collected by the solution are based on this resource.\nEncoding Routine In the previous part we got a global overview about how the solution achieves root detection, debug detection and what kind of data is collected (i.e. process memory map).\nHowever, some questions are pending:\n What part of the process memory map is used: Base addresses ? Module paths ? Permissions ? How the data are encoded (i.e. how QJRR{JJJGQJ~|MJJJ... is generated) ?  Along with the QBDI ARM support, we also added ARM support to resolve memory addresses during the instrumentation. It means that QBDI is now able to resolve the effective memory address of instructions such as:\n1LDR R0, [R1, R2]; # Resolve R1 + R2 2STR R1, [R2, R3, LSL #2]; # Resolve R2 + R3 * 4 3LDRB [PC, #4]; # Resolve **real** PC + 4 Moreover, QBDI is also able to get the effective memory value that is read or written. This feature is quite useful in the case of conditional instructions such as:\n1ITT LS; 2LDRLS R0, [R4]; 3LDRLS R1, [R0, #4] The effective value of R0 and R1 is stored in QBDI. It may not be *(r4) and *(r0 + 4) since the LS condition may not be verified.\nTo add a callback on memory accesses, we can use the addMemAccessCB(...) function on the VM instance:\n1vm.addMemAccessCB(MEMORY_READ_WRITE, memory_callback, /* data */ nullptr); In the given memory_callback(...) function, we perform the following actions:\n Track memory byte accesses. Check if the value is printable. Pretty print the R/W value.  The idea of this callback is to track memory accesses that are performed on printable characters. It enables to quickly identify strings encoding/decoding routines.\nHere is the implementation of the callback:\n1VMAction memory_callback(VMInstanceRef vm, GPRState *gprState, ...) { 2 auto\u0026amp;\u0026amp; acc = vm-\u0026gt;getInstMemoryAccess(); 3 4 // Get last memory access 5 MemoryAccess maccess = acc.back(); 6 7 // Retrieve access information: 8 rword addr = maccess.accessAddress; // Address accessed 9 rword value = maccess.value; // Value read or written 10 rword size = maccess.size; // Access size 11 12 // Only look for byte access 13 if (size != sizeof(char)) { 14 return VMAction::CONTINUE; 15 } 16 17 // Read / Write operation as a string 18 const std::string kind = maccess.type == MemoryAccessType::MEMORY_READ ? \u0026#34;[R]\u0026#34; : \u0026#34;[W]\u0026#34;; 19 20 // Cast the value into a char 21 const char cvalue = static_cast\u0026lt;char\u0026gt;(value); 22 23 // Check if the value read or written is printable 24 if (::isprint(cvalue)) { 25 logger-\u0026gt;info(\u0026#34;0x{:x} {}: {}\u0026#34;, addr, kind, cvalue); // Pretty print 26 } 27 28 // Continue this execution 29 return VMAction::CONTINUE; 30} With this new callback, we can observe such output between two openat() syscalls involved in the root check routine:\nIt is basically the string decoding routine in action. Note that some read operations are missing since we only track printable characters. However all write operations are present.\nThe routine loads characters with the instruction at address 0x295e and stores the decoded value at address 0x2972. If we look at the function that handles these two addresses, we find the decoding routine:\nIn the above figure, the green section highlights the memory load access while the red one highlights the write operation. The blue area is the decoding logic.\nThe output of all read / write accesses turns out to be quite verbose on the whole execution of the function. We can improve the instrumentation by adding two callbacks before and after function calls with this purpose:\n Before calls, we print the target address (e.g. 0x123: blx r3 -\u0026gt; .text!0xABC). After calls we print all printable characters being read or written within the called function.  The addCallCB(...) is still in experimentation but it aims to put callbacks before or after call instructions:\n1// Callback before ``call`` instructions 2vm.addCallCB(PRECALL, on_call_enter, nullptr); 3 4// Callback when a ``call`` returns 5vm.addCallCB(POSTCALL, on_call_exit, nullptr); With these two callbacks we get the following output:\nBy going further in the memory trace, we can observe this output:\nFrom this output we can infer the behavior of the collector (pseudo-code):\n1f = open(\u0026#34;/proc/self/maps\u0026#34;) 2for line in f.readlines(): 3 if not \u0026#34;/\u0026#34; in line: # Avoid entries such as XXX-YYY ... [anon:linker_alloc] 4 continue 5 6 if not \u0026#34;-xp\u0026#34; in line # Process executable segments only 7 continue 8 9 buffer += encode(line) We can also observe a sequence of\n READ line[i] CALL .text!0xd2ba WRITE encoded(line[i])  It suggests that the logic of the encode() function is implemented at address 0xd2ba.\nThe CFG of this function is compounded by instructions that compare the input against magic printable values and we manually checked that it is the encoding function. Moreover this function is â€” by design â€” reversible since the server side algorithm needs to process the encoded data.\nLibrary lifting In the previous parts, we targeted the ARM version of the library. It turns out that SDKs which use native libraries usually provide the libraries for all architectures (arm, arm64, x86, x86-64).\nIndeed, they do not want to limit developers to some architectures. The solution previously analyzed also comes with a x86-64 version of libApp.so with the exact same interface.\nMoreover, the analysis done in the previous sections shows that there are no real dependencies to the Android system:\n Syscall are standards and available on Linux. /proc/self/maps and /proc/self/status are available on Linux.  Thus, we can lift the library and run it on Linux. This technique has already been described in this blog post: When SideChannelMarvels meet LIEF.\nIn a first step, we have to patch the library with LIEF:\n1import lief 2 3libApp = lief.parse(\u0026#34;libApp.so\u0026#34;) 4 5# Patch library names 6# =================== 7libApp.get_library(\u0026#34;libc.so\u0026#34;).name = \u0026#34;libc.so.6\u0026#34; 8libApp.get_library(\u0026#34;liblog.so\u0026#34;).name = \u0026#34;libc.so.6\u0026#34; 9libApp.get_library(\u0026#34;libm.so\u0026#34;).name = \u0026#34;libm.so.6\u0026#34; 10libApp.get_library(\u0026#34;libdl.so\u0026#34;).name = \u0026#34;libdl.so.2\u0026#34; 11 12# Patch dynamic entries 13# ===================== 14 15# 1. Remove ELF constructors 16libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAY].array = [] 17libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAY].tag = lief.ELF.DYNAMIC_TAGS.DEBUG 18libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAYSZ].value = 0 19 20libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAY].array = [] 21libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAY].tag = lief.ELF.DYNAMIC_TAGS.DEBUG 22libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAYSZ].value = 0 23 24# 2. Remove symbol versioning 25libApp[lief.ELF.DYNAMIC_TAGS.VERNEEDNUM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG 26libApp[lief.ELF.DYNAMIC_TAGS.VERNEED].tag = lief.ELF.DYNAMIC_TAGS.DEBUG 27libApp[lief.ELF.DYNAMIC_TAGS.VERDEFNUM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG 28libApp[lief.ELF.DYNAMIC_TAGS.VERDEF].tag = lief.ELF.DYNAMIC_TAGS.DEBUG 29libApp[lief.ELF.DYNAMIC_TAGS.VERSYM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG 30 31libApp.write(\u0026#34;libApp-x86-64.so\u0026#34;) Then, we can instantiate a Linux JVM and run the native function:\n1int main() { 2 3 JavaVM *jvm = nullptr; 4 JNIEnv* env = nullptr; 5 6 // JVM options 7 JavaVMOption opt[1]; 8 JavaVMInitArgs args; 9 ... 10 11 // JVM instantiation 12 JNI_CreateJavaVM(\u0026amp;jvm, reinterpret_cast\u0026lt;void**\u0026gt;(\u0026amp;env), \u0026amp;args); 13 14 // Load the library 15 void* hdl = dlopen(\u0026#34;libApp-x86-64.so\u0026#34;, RTLD_LAZY | RTLD_LOCAL); 16 17 // Resolve the functions 18 using abi_t = jint(*)(JNIEnv*); 19 using jni_func_t = jstring(*)(JNIEnv*); 20 21 auto\u0026amp;\u0026amp; jni_get_abi = reinterpret_cast\u0026lt;abi_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14007\u0026#34;)); 22 auto\u0026amp;\u0026amp; jni_func = reinterpret_cast\u0026lt;jni_func_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14008\u0026#34;)); 23 24 // Execute 25 jint abi = jni_get_abi(env); 26 console-\u0026gt;info(\u0026#34;ABI: {:d}\u0026#34;, abi); 27 28 jstring encoded = jni_func(env); 29 console-\u0026gt;info(\u0026#34;ca3_14008(): {}\u0026#34;, env-\u0026gt;GetStringUTFChars(encoded, nullptr)); 30 31 return EXIT_SUCCESS; 32} By executing this code, we get a similar output as seen in the previous parts:\nWe can also run the strace utility to inspect the syscalls:\nSince we are able to run the function on Linux, we could also use gdb, Intel PIN or QBDI(x86-64) to analyze the library.\nConclusion While it has been quite challenging to add the whole ARM support in QBDI, it starts to work pretty well on real use cases. Such support should also lead to interesting applications among which:\n HongFuzz / QBDI for Android. SideChannelMarvels integration for CPA attacks. Trustlets instrumentation.  The raw traces used in this blog post are available here: traces.zip\nAcknowledgments Many thanks to Charles Hubain and CÃ©dric Tessier who developed and designed QBDI. It is really pleasant to work on the concepts involved in this DBI.\nThanks to the LLVM community to provide such framework without which this project would not be possible.\nThanks to my Quarkslab colleagues who proofread this article.\nReferences   Frida modifies fields of the art::ArtMethod object associated with the Java method.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Slides - Talk\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/QBDI/QBDI/blob/master/examples\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n DroidGuard being the SafetyNet module that collects information about the device.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The name has been intentionally changed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Plus the this parameter which is a jclass object for a static method.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Even though static analysis would be enough in this case.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Nexus 5X - Android 8.1.0 - Rooted with Magisk.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":155952e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"80507e111d02e96ebba18f081a8df969","permalink":"https://www.romainthomas.fr/post/android-native-library-analysis-with-qbdi/","publishdate":"2019-06-03T00:00:00Z","relpermalink":"/post/android-native-library-analysis-with-qbdi/","section":"post","summary":"This blog post deals with QBDI and how it can be used to reverse an Android JNI library","tags":["android","qbdi"],"title":"Android Native Library Analysis with QBDI","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"PoC that demonstrates how to disable runtime restrictions (hidden-api and dlopen namespaces) in user-land.\n   https://github.com/quarkslab/android-restriction-bypass  ","date":1553644800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"d539026e0a71b974dd820beadbc99bf0","permalink":"https://www.romainthomas.fr/project/android-runtime-restrictions-bypass/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/project/android-runtime-restrictions-bypass/","section":"project","summary":"Android application that disables Android restrictions without root privileges","tags":["android"],"title":"Android Runtime Restrictions Bypass (PoC)","type":"project"},{"authors":["Romain Thomas"],"categories":null,"content":"    Note This publication is also available on the Quarkslab Blog.     With the release of Android Nougat, Google introduced restriction about native libraries that can be loaded from an Android application. Basically, it prevents developers to link against some internal libraries such as libart.so.\nLater on and with the release of Android Pie, they introduced a new restriction on the access to internal Java methods (or fields). Basically, these restrictions are used to prevent developers to access parts of the Android internal framework.\nWhereas these limitations aim to be used for compatibility purposes, this article shows how we can take advantage of Android internal to disable them. We briefly explain how these restrictions work and how to disable them from an application without privileges.\nThe first part deals with the native library loading restriction while the second is about Java internal framework restriction.\n ","date":1553299200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"f66d0c032de15b286b9719768258637a","permalink":"https://www.romainthomas.fr/publication/android-restrictions-bypass/","publishdate":"2019-03-23T00:00:00Z","relpermalink":"/publication/android-restrictions-bypass/","section":"publication","summary":"This paper explains how to disable runtime restrictions without root privileges","tags":null,"title":"Android Runtime Restrictions Bypass","type":"publication"},{"authors":["Romain Thomas"],"categories":["Android","Challenge"],"content":"    This post has been originally posted on the Quarkslab\u0026rsquo;s Blog      Here is an Android crackme developed for the Android training given at Quarkslab.\nThe objective is to find the correct phone number that leads to the following message:\nThe application can be run on an emulator or a real device (whatever the architecture) but the Android version must be at least Marshmallow (\u0026gt; 6.0).\ncrackme-telegram.apk - SHA256: d66b82ebc14708b214a581760e99894af17e10598bcef95e75441a12b948bbf0\n","date":1542672e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"d724397d35a350dc535a41153c0ffe34","permalink":"https://www.romainthomas.fr/post/android-crackme/","publishdate":"2018-11-20T00:00:00Z","relpermalink":"/post/android-crackme/","section":"post","summary":"Android crackme that uses system's internals","tags":["android","challenge","crackme"],"title":"Android crackme challenge","type":"post"},{"authors":["Romain Thomas"],"categories":["Android"],"content":"Here are internal structures of Android OAT:\nOAT 124 PDF Version\nOAT 79 PDF Version\nOAT 64 PDF Version\n","date":1529884800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"cafaa1cdcbc4a0c195df4fe91329d011","permalink":"https://www.romainthomas.fr/post/android-oat/","publishdate":"2018-06-25T00:00:00Z","relpermalink":"/post/android-oat/","section":"post","summary":"Internal structures of OAT format","tags":["android","oat"],"title":"Android OAT formats","type":"post"},{"authors":["Romain Thomas"],"categories":["Android"],"content":"Here are internal structures of Android VDEX:\nVDEX 10 PDF Version\nVDEX 06 PDF Version\n","date":1529884800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"0253840aba4cfb0a98dbd91c16c8b583","permalink":"https://www.romainthomas.fr/post/android-vdex/","publishdate":"2018-06-25T00:00:00Z","relpermalink":"/post/android-vdex/","section":"post","summary":"Internal structures of VDEX format","tags":["android","vdex","format"],"title":"Android VDEX formats","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"Many instrumentation techniques are based on modifying code or system environment of the target. It can be suitable for scenarios but it could not work under certain circumstance (integrity checking, non-rooted environmentâ€¦) In this talk we propose similar techniques by only modifying the executable format. This enables to be architecture independent, injection and hooking does not require privileged environment.\n ","date":1529452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"8ad68419c7751ad4bcd1540adbaf29a9","permalink":"https://www.romainthomas.fr/publication/static-instrumentation/","publishdate":"2018-06-20T00:00:00Z","relpermalink":"/publication/static-instrumentation/","section":"publication","summary":"Talk given at Recon MontrÃ©al and PassTheSalt18 about static instrumentation and its use cases.","tags":null,"title":"Static Instrumentation Based on Executable Formats","type":"publication"},{"authors":["Philippe Teuwen","Romain Thomas"],"categories":["Android","LIEF"],"content":"    This post has been originally posted on the Quarkslab\u0026rsquo;s Blog      Introduction For those of you following our SideChannelMarvels1, you know that whenever we stumble on a non-commercial white-box implementation, we like to add it to the Deadpool project, a repository of various public white-box cryptographic implementations and their practical attacks.\nThis time, we wanted to have a look at the white-box created by Sanghwan (h2spice) Ahn and proposed during SECCON2016 CTF2. Apparently only PPP solved it during the competition and Sanghwan wrote himself a write-up3.\nThe challenge consists in an Android APK. When you launch it, it displays a flag encrypted a random number of times (between 1 and 3601). When encrypted only once, the flag is g1UlZafiuGdCgpTkWYjaZg3kE6qCd7kF3kV+nMKcGHc=.\nTo be able to â€˜plugâ€™ the challenge into our tools, we need to get an easy access to the input and output of the AES encryption function. A quick look reveals that the actual cryptographic operations are done in a native library called libnative-lib.so, conveniently available for several architectures. The function TfcqPqf1lNhu0DC2qGsAAeML0SEmOBYX4jpYUnyT8qYWIlEq(unsigned char*, unsigned char*) is the AES encryption function we want to attack. Note that the library is obfuscated with Obfuscator-LLVM 3.6.1, as we can see from its .comment section.\nBut we\u0026rsquo;re lazy, so we\u0026rsquo;d like to reuse the x86-64 version of libnative-lib.so under a Linux environment, where all the SideChannelMarvels toolchain is ready to crunch white-boxes. That\u0026rsquo;s not that simple because, even if they look alike, dynamic libraries compiled for Android or for Linux have a number of differences and a naive attempt to load an Android dynamic library under Linux will simply fail.\nFortunately, we have a nifty tool for parsing and modifying binaries. We\u0026rsquo;re talking about LIEF4 of course!\nConverting an Android library to Linux with LIEF The white-box is implemented in the libnative-lib.so which is available for ARM, AMR64, x86 and x86-64 architectures. It\u0026rsquo;s a tiny library exporting one JNI function: Java_kr_repo_h2spice_crypto500_MainActivity_a and importing three functions from external libraries.\nLifting this library to Linux is possible because the three imported functions (__cxa_finalize, __cxa_atexit, __stack_chk_fail) are not specific to Android.\nThe linked libraries of libnative-lib.so are standard: libc, libstdc++ \u0026hellip; except for liblog. But libnative-lib.so doesn\u0026rsquo;t use any of liblog functions, as we can see in readelf output:\n$ readelf -s -d -W ./libnative-lib.so Dynamic section at offset 0x2ad00 contains 31 entries: Tag Type Name/Value ... 0x01 (NEEDED) Shared library: [liblog.so] 0x01 (NEEDED) Shared library: [libm.so] 0x01 (NEEDED) Shared library: [libstdc++.so] 0x01 (NEEDED) Shared library: [libdl.so] 0x01 (NEEDED) Shared library: [libc.so] ... Symbol table \u0026#39;.dynsym\u0026#39; contains 32 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000 0 NOTYPE LOCAL DEFAULT UND 1: 00000 0 FUNC GLOBAL DEFAULT UND __cxa_finalize@LIBC (2) 2: 00000 0 FUNC GLOBAL DEFAULT UND __cxa_atexit@LIBC (2) 3: 04fe0 865 FUNC GLOBAL DEFAULT 11 Java_kr_repo_h2spice_crypto500_MainActivity_a 4: 02070 2281 FUNC GLOBAL DEFAULT 11 _Z48APtMDGO79Go3cbIkFca2rN0KszanZXOZ7dIPsxDBletW5gdoPcPKci 5: 01100 3916 FUNC GLOBAL DEFAULT 11 _Z48DENCPKY6hzMem3SuzgIXu4u6vxbF1sajPOJ75aN2VTdc7SCLPcPKc 6: 00bb0 1345 FUNC GLOBAL DEFAULT 11 _Z48KwUmSQBCaOVJKeqvABGpVnuErM7j8YCSOagNYBmr2ah0NZBePKc 7: 03860 6011 FUNC GLOBAL DEFAULT 11 _Z48TfcqPqf1lNhu0DC2qGsAAeML0SEmOBYX4jpYUnyT8qYWIlEqPhS_ 8: 02050 30 FUNC GLOBAL DEFAULT 11 _Z48h8AU0jPcyu9vXF9Kvg0bGDSl6H3TtcJIoOoU1ZOObCvegZ84i 9: 00000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@LIBC (2) 10: 02960 3836 FUNC GLOBAL DEFAULT 11 _Z48lrsFdMdlAT0vSMVedxmqOkCBF7sCTbhCjYEp1rLP8vatWEGDPh 29: 2c008 0 NOTYPE GLOBAL DEFAULT ABS _edata 30: 2c008 0 NOTYPE GLOBAL DEFAULT ABS __bss_start 31: 2c050 0 NOTYPE GLOBAL DEFAULT ABS _end  Thus we can simply remove the liblog library by setting its dynamic tag to DT_NULL:\n1 2 3 4 5  import lief libnative = lief.parse(\u0026#34;libnative-lib.so\u0026#34;)  liblog = libnative.get_library(\u0026#34;liblog.so\u0026#34;) liblog.tag = lief.ELF.DYNAMIC_TAGS.NULL   We also notice that the libc is named libc.so while the one on the current Linux version is named libc.so.6. To address this issue, one solution would be to create a symbol link of libc.so.6 to libc.so and set the environment variable LD_LIBRARY_PATH to the directory that contains the symlink.\nA more elegant solution is to rename the library with LIEF:\nlibnative.get_library(\u0026#34;libc.so\u0026#34;).name = \u0026#34;libc.so.6\u0026#34; Lastly, libnative-lib.so imports __cxa_finalize, __cxa_atexit and __stack_chk_fail with a specific version. The version can be seen in the imported names, next to the @ character. For these symbols, the associated version is \u0026ldquo;LIBC\u0026rdquo; and, during the loading step, the loader will look for the __cxa_finalize in libc.so.6 with this exact version.\nBut the Linux libc.so.6 defines these symbols with a \u0026ldquo;GLIBC_2.2.5\u0026rdquo; version:\n$ readelf -s -W /usr/lib64/libc.so.6|grep __cxa_finalize 1944: 00037cf0 535 FUNC GLOBAL DEFAULT 12 __cxa_finalize@@GLIBC_2.2.5  To fix the version issue, we can simply change the version to unspecified by setting its value to 1:\nfor s in filter(lambda e: e.has_version, libnative.dynamic_symbols):  if s.symbol_version.value \u0026gt; 1: # Library-defined version  s.symbol_version.value = 1 # Set to unspecified And then build the modified library:\nlibnative.write(\u0026#34;libnative-fixed.so\u0026#34;) Finally, we can load and execute the lifted library with dlopen / dlsym: (error handling being stripped for readability)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  using fnc_t = uint64_t(*)(unsigned char*, unsigned char*);  int main(void) {  void* h = dlopen(\u0026#34;./libnative-fixed.so\u0026#34;, RTLD_NOW);  void* sh = dlsym(h, \u0026#34;_Z48TfcqPqf1lNhu0DC2qGsAAeML0SEmOBYX4jpYUnyT8qYWIlEqPhS_\u0026#34;);   fnc_t AES_128_encrypt = reinterpret_cast\u0026lt;fnc_t\u0026gt;(sh);   unsigned char plaintext[16];  unsigned char ciphertext[16];  fread(plaintext, 1, 16, stdin);  AES_128_encrypt(plaintext, ciphertext);  fwrite(ciphertext, 1, 16, stdout);  return 0; }   This native library has a special structure that enables the transformation:\n It doesn\u0026rsquo;t use functions specific to Android. It doesn\u0026rsquo;t use packed relocations. It doesn\u0026rsquo;t use exceptions. It doesn\u0026rsquo;t use Thread Local Storage (TLS).  The first point is very uncommon for JNI libraries and this transformation won\u0026rsquo;t be possible for usual libraries.\nEventually breaking the white-box Now that we got a Linux binary of the AES white-box with standardized input/output, we\u0026rsquo;re back into usual white-box attacks business. The Differential Fault Analysis attack on white-box using our tools is largely explained in a previous blogpost. In short, we inject statically some faults in the white-box tables (here, we\u0026rsquo;ll shoot on the entire .rodata section of the dynamic library), execute the AES on a constant input, and observe the output for faults. These steps are automated in the deadpool_dfa.Acquisition function, part of our SideChannelMarvels/Deadpool repository. Once we collected enough faulty outputs, we can apply a well-known DFA attack to recover the AES key, which is implemented in the phoenixAES.crack function from the SideChannelMarvels/JeanGrey repository.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import deadpool_dfa import phoenixAES  def processinput(iblock, blocksize):  return (bytes.fromhex(\u0026#39;%0*x\u0026#39; % (2*blocksize, iblock)), None)  def processoutput(output, blocksize):  return int.from_bytes(output, byteorder=\u0026#39;big\u0026#39;, signed=False)  engine = deadpool_dfa.Acquisition(  # main white-box executable  targetbin=\u0026#39;./main64\u0026#39;,  # file where to inject faults, and a reference copy  targetdata=\u0026#39;./libnative-fixed.so\u0026#39;, goldendata=\u0026#39;./libnative-fixed.so.gold\u0026#39;,  # hook to the DFA library, to validate faulty outputs  dfa=phoenixAES,  # hooks to process I/O as expected by the white-box executable  processinput=processinput, processoutput=processoutput,  # some tuning, telling we want to try up to single byte faults  verbose=2, minleaf=1, minleafnail=1,  # the libnative-fixed.so .rodata section address range  addresses=[0x6350,0x2b490] ) outputs = engine.run()[0][0] phoenixAES.crack(outputs)   Execution:\n... Lvl 016 [0x000226DF-0x000226E0[ xor 0x86 -\u0026gt; B25BE351AD6986FF15D1E152E7802EC7 GoodEncFault Column:1 Logged Lvl 016 [0x000226DF-0x000226E0[ xor 0x69 -\u0026gt; B235E351806986FF15D1E1A4E780A6C7 GoodEncFault Column:1 Logged Saving 17 traces in dfa_enc_20180427_112029-112038_17.txt Last round key #N found: 040D08DA68001026F3DC0D68897148B4 The DFA recovers the last (tenth) round key but the AES key schedule is invertible so we can go back to the original AES key:\n$ aes_keyschedule 040D08DA68001026F3DC0D68897148B4 10 K00: 6C2893F21B6185E8567238CB78184945  The key falls in 10.2s and 3300 executions. This is indeed the correct AES key:\n$ echo g1UlZafiuGdCgpTkWYjaZg3kE6qCd7kF3kV+nMKcGHc=|base64 -d|\\ openssl enc -d -aes-128-ecb -nopad -K 6C2893F21B6185E8567238CB78184945 SECCON{owSkwPeH1CHQdPV9KWrSmz9n}  Final Words We hope this little exercise will make you feel like using our tools!\nThe whitebox and all the scripts to convert the library and apply the attack are available online 5 and LIEF has its own website4.\nThanks to all Quarkslab colleagues who proofread this article and provided valuable feedback.\n  Side-Channel Marvels repository, on GitHub.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n SECCON2016 Online CTF-Binary / Crypto500 Obfuscated AES, archived here.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Sanghwan\u0026rsquo;s Obfuscated AES Write-Up, in english, korean and japanese\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Library to Instrument Executable Formats\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n SECCON 2016 Obfuscated AES artifacts in Deadpool\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1525305600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"bd3c92041dc1c7e4c0ba7bb28e668f24","permalink":"https://www.romainthomas.fr/post/18-05-when-sidechannelmarvels-meets-lief/","publishdate":"2018-05-03T00:00:00Z","relpermalink":"/post/18-05-when-sidechannelmarvels-meets-lief/","section":"post","summary":"On how we used LIEF to lift an Android x86_64 library to Linux to perform our usual white-box attacks on it.","tags":[""],"title":"When SideChannelMarvels meets LIEF","type":"post"},{"authors":["Romain Thomas"],"categories":["LIEF","Android"],"content":"This post is a part of the LIEF tutorials. It explains how to combine Frida and LIEF to run frida-gadget on a non rooted device.\nSee more\n","date":1520035200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"07879a4dd6943de00d78e7d1ff0f0307","permalink":"https://www.romainthomas.fr/post/how-to-use-frida-on-a-non-rooted-device/","publishdate":"2018-03-03T00:00:00Z","relpermalink":"/post/how-to-use-frida-on-a-non-rooted-device/","section":"post","summary":"This post explains how to use Frida gadget on a non-rooted device.","tags":["lief"],"title":"How to use frida on a non-rooted device","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"    This post has been originally posted on the Quarkslab\u0026rsquo;s blog      This blog post introduces new features of LIEF as well as some uses cases.\nTl;DR: LIEF v0.8.3 is out. The main changelog is available here and packages can be downloaded on the official website.  To install the Python package:\n$ pip install lief  Development process We attach a great importance to the automation of some development tasks like testing, distributing, packaging, etc. Here is a summary of these processes:\nEach commits is tested on\n Linux - x86-64 - Python{2.7, 3.5, 3.6} Windows - x86 / x86-64 - Python{2.7, 3.5, 3.6} OSX - x86-64 - Python{2.7, 3.5, 3.6}  The test suite includes:\n Tests on the Python API Tests on the C API Tests on the parsers Tests on the builders  If tests succeeds packages are automatically uploaded on the https://github.com/lief-project/packages repository.\nFor tagged version, packages are uploaded on the Github release page: https://github.com/lief-project/LIEF/releases. Dockerlief\nDockerlief To facilitate the compilation and the use of LIEF, we created the Dockerlief repo which includes various Dockerfiles as well as the dockerlief utility. dockerlief is basically a wrapper on docker build .\nAmong Dockerfiles, we provide a Dockerfile to cross compile LIEF for Android (ARM, AARCH64, x86, x86-64)\nTo cross compile LIEF for Android ARM, one can run:\n$ dockerlief build --api-level 21 --arm lief-android [INFO] - Location of the Dockerfiles: ~/dockerfiles [INFO] - Building Dockerfile: \u0026#39;lief-android\u0026#39; [INFO] - Target architecture: armeabi-v7a [INFO] - Target API Level: 21  The SDK package LIEF-0.8.3-Android_API21_armeabi-v7a.tar.gz is automatically pulled from the Docker to the current directory.\nIntegration of LibFuzzer Fuzzing our own library is a good way to detect bugs, memory leak, unsanitized inputs \u0026hellip;\nThus, we integrated LibFuzzer in the project. Fuzzing the LIEF ELF, PE, Mach-O parser is as simple as:\n1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;LIEF/LIEF.hpp\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;memory\u0026gt; extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {  std::vector\u0026lt;uint8_t\u0026gt; raw = {data, data + size};  try {  std::unique_ptr\u0026lt;LIEF::Binary\u0026gt; b{LIEF::Parser::parse(raw)};  } catch (const LIEF::exception\u0026amp; e) {  std::cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl;  }  return 0; }   To launch the fuzzer, one can run the following commands:\n$ make fuzz-elf # Launch ELF Fuzzer $ make fuzz-pe # Launch PE Fuzzer $ make fuzz-macho # Launch MachO Fuzzer $ make fuzz # Launch ELF, PE and MachO Fuzzer  ELF Play with ELF symbols - Part 2 In the tutorial #03 we demonstrated how to swap dynamic symbols between a binary and a library. In this part, we will see how we can rename these symbols.\nChanging symbol names is not a trivial modification, since modifying the string table of the PT_DYNAMIC segment has side effects:\n It requires to update the hash table (GNU Hash / SYSV). It usually requires to extend the DYNAMIC part of the ELF format.  The previous version of LIEF already implements the rebuilding of the hash table but not the extending of the DYNAMIC part.\nWith the v0.8.3 we can extend the DYNAMIC part. Therefore:\n We can add new entries in the .dynamic section We can change dynamic symbols names We can change DT_RUNPATH and DT_RPATH without length restriction  We will rename all imported functions of gpg that are imported from libgcrypt.so.20 into a_very_long_name_of_function_XX and all exported functions of libgcrypt.so.20 into the same name (XX is the symbol index). 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import lief  # Load targets gpg = lief.parse(\u0026#34;/usr/bin/gpg\u0026#34;) libgcrypt = lief.parse(\u0026#34;/usr/lib/libgcrypt.so.20\u0026#34;)  # Change names for idx, lsym in enumerate(filter(lambda e : e.exported, libgcrypt.dynamic_symbols)):  new_name = \u0026#39;a_very_long_name_of_function_{:d}\u0026#39;.format(idx)  print(\u0026#34;New name for \u0026#39;{}\u0026#39;: {}\u0026#34;.format(lsym.name, new_name))  for bsym in filter(lambda e : e.name == lsym.name, gpg.dynamic_symbols):  bsym.name = new_name  lsym.name = new_name  # Write back binary.write(gpg.name) libgcrypt.write(libgcrypt.name)   By using readelf we can check that function names have been modified:\n$ readelf -s ./gpg|grep \u0026#34;a_very_long_name\u0026#34; 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND a_very_long_name_of_funct@GCRYPT_1.6 (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND a_very_long_name_of_funct@GCRYPT_1.6 (2) 11: 0000000000000000 0 FUNC GLOBAL DEFAULT UND a_very_long_name_of_funct@GCRYPT_1.6 (2) 13: 0000000000000000 0 FUNC GLOBAL DEFAULT UND a_very_long_name_of_funct@GCRYPT_1.6 (2) ... $ readelf -s ./libgcrypt.so.20|grep \u0026#34;a_very_long_name\u0026#34; 88: 000000000000d050 6 FUNC GLOBAL DEFAULT 10 a_very_long_name_of_funct@@GCRYPT_1.6 89: 000000000000dcd0 69 FUNC GLOBAL DEFAULT 10 a_very_long_name_of_funct@@GCRYPT_1.6 90: 000000000000d310 34 FUNC GLOBAL DEFAULT 10 a_very_long_name_of_funct@@GCRYPT_1.6 91: 000000000000de70 81 FUNC GLOBAL DEFAULT 10 a_very_long_name_of_funct@@GCRYPT_1.6 ...  Now if we run the new gpg binary, we get the following error:\n$ ./gpg --output bar.txt --symmetric ./foo.txt relocation error: ./gpg: symbol a_very_long_name_of_function_8, version GCRYPT_1.6 not defined in file libgcrypt.so.20 with link time reference  Because the Linux loader tries to resolve the function a_very_long_name_of_function_8 against /usr/lib/libgcrypt.so.20 and that library doesn\u0026rsquo;t include the updated names we get the error.\nOne way to fix this error is to set the environment variable LD_LIBRARY_PATH to the current directory:\n$ LD_LIBRARY_PATH=. ./gpg --output bar.txt --symmetric ./foo.txt $ xxd ./bar.txt|head -n1 00000000: 8c0d 0407 0302 c5af 9fba cab1 9545 ebd2 .............E.. $ LD_LIBRARY_PATH=. ./gpg --output foo_decrypted.txt --decrypt ./bar.txt $ xxd ./foo_decrypted.txt|head -n1 00000000: 4865 6c6c 6f20 576f 726c 640a Hello World.  Another way to fix it is to add a new entry in .dynamic section.\nAs mentioned at the beginning, we can now add new entries in the .dynamic so let\u0026rsquo;s add a DT_RUNPATH entry with the $ORIGIN value so that the Linux loader resolves the modified libgcrypt.so.20 instead of the system one:\n1 2 3 4 5 6 7  ... # Add a DT_RUNPATH entry gpg += lief.ELF.DynamicEntryRunPath(\u0026#34;$ORIGIN\u0026#34;)  # Write back binary.write(gpg.name) libgcrypt.write(libgcrypt.name)   And we don\u0026rsquo;t need the LD_LIBRARY_PATH anymore:\n$ readelf -d ./gpg|grep RUNPATH 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN] $ ./gpg --decrypt ./bar.txt gpg: AES encrypted data gpg: encrypted with 1 passphrase Hello World  Hiding its symbols While IDA v7.0 has been released recently, among the changelog one can notice two changes:\n  ELF: describe symbols using symtab from DYNAMIC section ELF: IDA now uses the PHT by default instead of the SHT to load segments from ELF files   These changes are partially true. Let\u0026rsquo;s see what go wrong in IDA with the following snippet:\n1 2 3 4  id = lief.parse(\u0026#34;/usr/bin/id\u0026#34;) dynsym = id.get_section(\u0026#34;.dynsym\u0026#34;) dynsym.entry_size = dynsym.size // 2 id.write(\u0026#34;id_test\u0026#34;)   This snippet defines the size of one symbol as the entire size of .dynsym section divided by 2. The normal size of ELF symbols would be:\n\u0026gt;\u0026gt;\u0026gt; print(int(lief.ELF.ELF32.SIZES.SYM)) # For 32-bits 16 \u0026gt;\u0026gt;\u0026gt; print(int(lief.ELF.ELF64.SIZES.SYM)) # For 64-bits 24 In the case of the 64-bits id binary, we set this size to 924.\nWhen opening id_test in IDA and forcing to use Segment for parsing and not Sections we get the following imports:\n   Only one import is resolved and the others are hidden.\nNote that id_test is still executable:\n$ id_test uid=1000(romain) gid=1000(romain) ...  By using readelf we can still retrieve the symbols and we have an error indicating that symbol size is corrupted.\n$ readelf -s id_test readelf: Error: Section 5 has invalid sh_entsize of 000000000000039c readelf: Error: (Using the expected size of 24 for the rest of this dump) Symbol table \u0026#39;.dynsym\u0026#39; contains 77 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND endgrent@GLIBC_2.2.5 (2) 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __uflow@GLIBC_2.2.5 (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND getenv@GLIBC_2.2.5 (2) 4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND free@GLIBC_2.2.5 (2) 5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND abort@GLIBC_2.2.5 (2) ...  In LIEF the (dynamic) symbol table address is computed through the DT_SYMTAB from the PT_DYNAMIC segment.\nTo compute the number of dynamic symbols LIEF uses three heuristics:\n Based on hash tables (GNU Hash / Sysv Hash) Based on relocations Based on sections  Malwares start to use this kind of corruption as we will see in the next part.\nRootnik Malware Rootnik is a malware targeting Android devices. It has been analyzed by Fortinet security researcher.\nA full analysis of the malware is available on the Fortinet blog.\nThis part is focused on the ELF format analysis of one component: libshell.\nActually there are two libraries libshella_2.10.3.1.so and libshellx_2.10.3.1.so. As they have the same purpose, we will use the x86 version.\nFirst if we look at the ELF sections of libshellx_2.10.3.1.so we can notice that the address, offset and size of some sections like .text, .init_array, .dynstr, .dynsym are set to 0.\nThis kind of modification is used to disturb tools that rely on sections to parse some ELF structures (like objdump, readelf, IDA \u0026hellip;)\n$ readelf -S ./libshellx-2.10.3.1.so There are 21 section headers, starting at offset 0x2431c: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .dynsym DYNSYM 00000114 000114 000300 10 A 2 1 4 [ 2] .dynstr STRTAB 00000414 000414 0001e2 00 A 0 0 1 [ 3] .hash HASH 00000000 000000 000000 04 A 1 0 4 [ 4] .rel.dyn REL 00000000 000000 000000 08 A 1 0 4 [ 5] .rel.plt REL 00000000 000000 000000 08 AI 1 6 4 [ 6] .plt PROGBITS 00000000 000000 000000 04 AX 0 0 16 [ 7] .text PROGBITS 00000000 000000 000000 00 AX 0 0 16 [ 8] .code PROGBITS 00000000 000000 000000 00 AX 0 0 16 [ 9] .eh_frame PROGBITS 00000000 000000 000000 00 A 0 0 4 [10] .eh_frame_hdr PROGBITS 00000000 000000 000000 00 A 0 0 4 [11] .fini_array FINI_ARRAY 00000000 000000 000000 00 WA 0 0 4 [12] .init_array INIT_ARRAY 00000000 000000 000000 00 WA 0 0 4 [13] .dynamic DYNAMIC 0000ce50 00be50 0000f8 08 WA 2 0 4 [14] .got PROGBITS 00000000 000000 000000 00 WA 0 0 4 [15] .got.plt PROGBITS 00000000 000000 000000 00 WA 0 0 4 [16] .data PROGBITS 00000000 000000 000000 00 WA 0 0 16 [17] .bss NOBITS 0000d398 00c395 000000 00 WA 0 0 4 [18] .comment PROGBITS 00000000 00c395 000045 01 MS 0 0 1 [19] .note.gnu.gold-ve NOTE 00000000 00c3dc 00001c 00 0 0 4 [20] .shstrtab STRTAB 00000000 024268 0000b1 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), p (processor specific)  If we open the given library in IDA we have no exports, no imports and no sections:\nBased on the segments and dynamic entries we can recover most of these information:\n .init_array address and size are available through the DT_INIT_ARRAY and DT_INIT_ARRAYSZ entries .dynstr address and size are available through the DT_STRTAB and DT_STRSZ .dynsym address is available through the DT_SYMTAB  The script recover_shellx.py recovers the missing values, patch sections and rebuild a fixed library.\nNow if we open the new libshellx-2.10.3.1_FIXED.so we have access to imports / exports and some sections. The .init_array section contains 2 functions:\n tencent652524168491435794009 sub_60C0  The tencent652524168491435794009 function basically do a stack alignment and the sub_60C0 is one of the decryption routines2. This function is obfuscated with graph flattening and looks like to O-LLVM graph flattening passe3:\nFortunately there are few \u0026ldquo;relevant blocks\u0026rdquo; and there are not obfuscated.\nThe function sub_60C0 basically iterates over the program headers to find the encrypted one and decrypt it using a custom algorithm (based on shift, xor, etc).\nTriggering CVE-2017-1000249 The CVE-2017-1000249 is a stack based buffer overflow in the file utility. It affects the versions 5.29, 5.30 and 5.31.\nBasically the overflow occurs in the size of the note description.\nUsing LIEF we can trigger the overflow as follow:\n1 2 3 4 5 6  import lief  target = lief.parse(\u0026#34;/usr/bin/id\u0026#34;) note_build_id = target[lief.ELF.NOTE_TYPES.BUILD_ID] note_build_id.description = [0x41] * 30 target.write(\u0026#34;id_overflow\u0026#34;)   $ file --version file-5.29 magic file from /usr/share/file/misc/magic $ id_overflow uid=1000(romain) gid=1000(romain) ... $ file id_overflow *** buffer overflow detected ***: file terminated ./id_overflow: [1] 3418 abort (core dumped) file ./id_overflow  Here is the commit that introduced the bug: 9611f3.\nPE The Load Config directory is now parsed into the LoadConfiguration object. This structure evolves with the Windows versions and LIEF has been designed to support this evolution. You can take a look at LoadConfigurationV0, LoadConfigurationV6.\nOne can find the different versions of this structure in the following directories:\n include/LIEF/PE/LoadConfigurations src/PE/LoadConfigurations  The current version of LIEF is able to parse the structure up to Windows 10 build 15002 with the hotpatch table offset.\nHere are some examples of the LoadConfiguration API:\n\u0026gt;\u0026gt;\u0026gt; target = lief.parse(\u0026#34;PE64_x86-64_binary_WinApp.exe\u0026#34;) \u0026gt;\u0026gt;\u0026gt; target.has_configuration True \u0026gt;\u0026gt;\u0026gt; config = target.load_configuration \u0026gt;\u0026gt;\u0026gt; config.version WIN_VERSION.WIN10_0_15002 \u0026gt;\u0026gt;\u0026gt; hex(config.guard_rf_failure_routine) \u0026#39;0x140001040\u0026#39; LIEF also provides an API to serialize any ELF or PE objects into JSON4\nFor examples to transform LoadConfiguration object into JSON:\n\u0026gt;\u0026gt;\u0026gt; from lief import to_json \u0026gt;\u0026gt;\u0026gt; to_json(config) \u0026#39;{\u0026#34;characteristics\u0026#34;:248,\u0026#34;code_integrity\u0026#34;:{\u0026#34;catalog\u0026#34;:0,\u0026#34;catalog_offset\u0026#34;:0 ... }}\u0026#39; # Not fully printed One can also serialize the whole Binary object:\n\u0026gt;\u0026gt;\u0026gt; to_json(target) \u0026#39;{\u0026#34;data_directories\u0026#34;:[{\u0026#34;RVA\u0026#34;:0,\u0026#34;size\u0026#34;:0,\u0026#34;type\u0026#34;:\u0026#34;EXPORT_TABLE\u0026#34;},{\u0026#34;RVA\u0026#34;:62584,\u0026#34;section\u0026#34; ...}}\u0026#39; # # Not fully printed Mach-O For Mach-O binary, dynamic executables embed the LC_DYLD_INFO command which is associated with the dyld_info_command structure.\nThe structure is basically a list of offsets and sizes pointing to other data structures.\nFrom /usr/lib/mach-o/loader.h the structure looks like this:\nstruct dyld_info_command {  uint32_t cmd;  uint32_t cmdsize;  uint32_t rebase_off;  uint32_t rebase_size;  uint32_t bind_off;  uint32_t bind_size;  uint32_t weak_bind_off;  uint32_t weak_bind_size;  uint32_t lazy_bind_off;  uint32_t lazy_bind_size;  uint32_t export_off;  uint32_t export_size; }; The dyld loader uses this structure to:\n Rebase the executable Bind symbols to addresses Retrieve exported functions (or symbols)  Whereas in the ELF and PE format relocations are basically a table, Mach-O format uses byte streams to rebase the image and to bind symbols with addresses. For exports it uses a trie as subjacent structure.\nIn the new version of LIEF, the Mach-O parser is able to handle these underlying structures to provide an user-friendly API:\nThe export trie is represented by the ExportInfo object which is usually tied to a Symbol. The binding byte stream is represented trough the BindingInfo object.\nFor the rebase byte stream, the parser create virtual relocations to model the rebasing process. These virtual relocations are represented by the RelocationDyld object and among other attributes it contains address, size and type5.\nHere is an example using the Python API:\n\u0026gt;\u0026gt;\u0026gt; id = lief.parse(\u0026#34;/usr/bin/id\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print(id.relocations[0]) 100002000 POINTER 64 DYLDINFO __DATA.__eh_frame dyld_stub_binder \u0026gt;\u0026gt;\u0026gt; print(id.has_dyld_info) True \u0026gt;\u0026gt;\u0026gt; dyldinfo = id.dyld_info \u0026gt;\u0026gt;\u0026gt; print(dyldinfo.bindings[0]) Class: STANDARD Type: POINTER Address: 0x100002010 Symbol: ___stderrp Segment: __DATA Library: /usr/lib/libSystem.B.dylib \u0026gt;\u0026gt;\u0026gt; print(dyldinfo.exports[0]) Node Offset: 18 Flags: 0 Address: 0 Symbol: __mh_execute_header Conclusion In this release we did a large improvement of the ELF builder. Mach-O and PE parts gain new objects and new functions. LIEF is now available on pypi and can be added in the requirements of Python projects whatever the Python version and the target platform.\nSince the v0.7.0 LIEF has been presented at RMLL and the MISP project uses it for its PyMISP objects.\nSome may complain about the C API. They are right! Until the v1.0.0 we will provide a minimal C API. Once C++ API is stable we plan to provide full APIs for Python, C, Java, OCaml6, etc.\nNext version should be focused on the Mach-O builder especially for adding sections and segments. We also plan to support PE .NET headers and fix some performances issues.\nFor questions you can join the Gitter channel.\n  All Python examples are done with the 3.5 version\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n As mentioned in the Fortinet blog post, the library is packed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n See the blog post about O-LLVM analysis: https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n This feature is not yet available for MachO objects\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Due to the inheritance relationship and abstraction these attributes are located in the MachO::Relocation and LIEF::Relocation objects.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/aziem/LIEF-ocaml\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1509580800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"cf00a4f3c76204c3d8227e79af543ab0","permalink":"https://www.romainthomas.fr/post/17-11-have-fun-with-lief-and-executable-formats/","publishdate":"2017-11-02T00:00:00Z","relpermalink":"/post/17-11-have-fun-with-lief-and-executable-formats/","section":"post","summary":"This blog post introduces new features of LIEF as well as some uses cases.","tags":["lief"],"title":"Have fun with LIEF and Executable Formats","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"When analyzing executable, the first layer of information is the format in which the executable is wrapped. It turns out that a lot of tools and libraries exist to analyze and instrument machine code wrapped by the format, but there is not such library to handle the three mainstream executable formats and to both read and modify these formats. LIEF has been developed to that end.\nIn the talk we will explain the rationale behind LIEF architecture choices, what LIEF allows to do and have a look at use cases.\nLIEF is a cross platform library and it can be used through a Python, C++ and C API. The library enables to parse standard structures as well as more complex ones like PE Signature (Authenticode) and ELF hash table. As use cases we can inject code into a binary or a library, we can also redirect the control flow to hook functions and it can be used to obfuscate some parts of a binary. Another feature of LIEF is that common characteristics of these formats are factorized so that we can develop a single script which works for the three formats.\n Slides of the talk given at RMLL  You can also grab the slides of the talk given at Cybersecurity France-Japan: 17-04-cybersecurity-frjp-LIEF.pdf\n","date":1499126400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"b4e3c965220814581b363ec08db9d7ae","permalink":"https://www.romainthomas.fr/publication/lief/","publishdate":"2017-07-04T00:00:00Z","relpermalink":"/publication/lief/","section":"publication","summary":"When analyzing executable, the first layer of information is the format in which the executable is wrapped. It turns out that a lot of tools and libraries exist to analyze and instrument machine code wrapped by the format, but there is not such library to handle the three mainstream executable formats and to both read and modify these formats. LIEF has been developed to that end.\nIn the talk we will explain the rationale behind LIEF architecture choices, what LIEF allows to do and have a look at use cases.","tags":null,"title":"LIEF: Library to Instrument Executable Formats","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":"    This post has been originally posted on the Quarkslab\u0026rsquo;s blog      Executable File Formats in a Nutshell When dealing with executable files, the first layer of information is the format in which the code is wrapped. We can see an executable file format as an envelope. It contains information so that the postman (i.e. Operating System) can handle and deliver (i.e. execute) it. The message wrapped by this envelope would be the machine code.\nThere are mainly three mainstream formats, one per OS:\n Portable Executable (PE) for Windows systems Executable and Linkable Format (ELF) for UN*X systems (Linux, Android\u0026hellip;). Mach-O for OS-X, iOS\u0026hellip;  Other executable file formats, such as COFF, exist but they are less relevant.\nUsually each format has a header which describes at least the target architecture, the program\u0026rsquo;s entry point and the type of the wrapped object (executable, library\u0026hellip;) Then we have blocks of data that will be mapped by the OS\u0026rsquo;s loader. These blocks of data could hold machine code (.text), read-only data (.rodata) or other OS specific information.\nFor PE there is only one kind of such block: Section. For ELF and Mach-O formats, a section has a different meaning. In these formats, sections are used by the linker at the compilation step, whereas segments (second type of block) are used by the OS\u0026rsquo;s loader at execution step. Thus sections are not mandatory for ELF and Mach-O formats and can be removed without affecting the execution.\nPurpose of LIEF It turns out that many projects need to parse executable file formats but don\u0026rsquo;t use a standard library and re-implement their own parser (and the wheel). Moreover, these parsers are usually bound to one language.\nOn Unix system one can find the objdump and objcopy utilities but they are limited to Unix and the API is not user-friendly.\nThe purpose of LIEF is to fill this void:\n Providing a cross platform library which can parse and modify (in a certain extent) ELF, PE and Mach-O formats using a common abstraction Providing an API for different languages (Python, C++, C\u0026hellip;) Abstract common features from the different formats (Section, header, entry point, symbols\u0026hellip;)  The following snippets show how to obtain information about an executable using different API of LIEF:\n1 import lief 2 # ELF 3 binary = lief.parse(\u0026#34;/usr/bin/ls\u0026#34;) 4 print(binary) 5 6 #Â PE 7 binary = lief.parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;) 8 print(binary) 9 10 # Mach-O 11 binary = lief.parse(\u0026#34;/usr/bin/ls\u0026#34;) 12 print(binary) With the C++ API:\n1 2 #include \u0026lt;LIEF/LIEF.hpp\u0026gt;3 int main(int argc, const char** argv) { 4 LIEF::ELF::Binary* elf = LIEF::ELF::Parser::parse(\u0026#34;/usr/bin/ls\u0026#34;); 5 LIEF::PE::Binary* pe = LIEF::PE::Parser::parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;); 6 LIEF::MachO::Binary* macho = LIEF::MachO::Parser::parse(\u0026#34;/usr/bin/ls\u0026#34;); 7 8 std::cout \u0026lt;\u0026lt; *elf \u0026lt;\u0026lt; std::endl; 9 std::cout \u0026lt;\u0026lt; *pe \u0026lt;\u0026lt; std::endl; 10 std::cout \u0026lt;\u0026lt; *macho \u0026lt;\u0026lt; std::endl; 11 12 delete elf; 13 delete pe; 14 delete macho; 15 } And finally with the C API:\n1 2 #include \u0026lt;LIEF/LIEF.h\u0026gt;3 int main(int argc, const char** argv) { 4 5 Elf_Binary_t* elf_binary = elf_parse(\u0026#34;/usr/bin/ls\u0026#34;); 6 Pe_Binary_t* pe_binary = pe_parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;); 7 Macho_Binary_t** macho_binaries = macho_parse(\u0026#34;/usr/bin/ls\u0026#34;); 8 9 Pe_Section_t** pe_sections = pe_binary-\u0026gt;sections; 10 Elf_Section_t** elf_sections = elf_binary-\u0026gt;sections; 11 Macho_Section_t** macho_sections = macho_binaries[0]-\u0026gt;sections; 12 13 for (size_t i = 0; pe_sections[i] != NULL; ++i) { 14 printf(\u0026#34;%s\\n\u0026#34;, pe_sections[i]-\u0026gt;name) 15 } 16 17 for (size_t i = 0; elf_sections[i] != NULL; ++i) { 18 printf(\u0026#34;%s\\n\u0026#34;, elf_sections[i]-\u0026gt;name) 19 } 20 21 for (size_t i = 0; macho_sections[i] != NULL; ++i) { 22 printf(\u0026#34;%s\\n\u0026#34;, macho_sections[i]-\u0026gt;name) 23 } 24 25 elf_binary_destroy(elf_binary); 26 pe_binary_destroy(pe_binary); 27 macho_binaries_destroy(macho_binaries); 28 } LIEF supports FAT-MachO and one can iterate over binaries as follows:\n1 import lief 2 binaries = lief.MachO.parse(\u0026#34;/usr/lib/libc++abi.dylib\u0026#34;) 3 for binary in binaries: 4 print(binary)     Note The above script uses the lief.MachO.parse function instead of the lief.parse function because lief.parse returns a single lief.MachO.binary object whereas lief.MachO.parse returns a list of lief.MachO.binary (according to the FAT-MachO format).     Along with standard format components like headers, sections, import table, load commands, symbols, etc. LIEF is also able to parse PE Authenticode:\n1 2 import lief 3 driver = lief.parse(\u0026#34;driver.sys\u0026#34;) 4 5 for crt in driver.signature.certificates: 6 print(crt) 12Version: 3 3Serial Number: 61:07:02:dc:00:00:00:00:00:0b 4Signature Algorithm: SHA1_WITH_RSA_ENCRYPTION 5Valid from: 2005-9-15 21:55:41 6Valid to: 2016-3-15 22:5:41 7Issuer: DC=com, DC=microsoft, CN=Microsoft Root Certificate Authority 8Subject: C=US, ST=Washington, L=Redmond, O=Microsoft Corporation, CN=Microsoft Windows Verification PCA 9... Full API documentation is available here\n Python API C++ API C API  Architecture In the LIEF architecture, each format implements at least the following classes:\n Parser: Parse the format and decompose it into a Binary class Binary: Modelize the format and provide an API to modify and explore it. Builder: Transform the binary object into a valid file.   To factor common characteristics in formats we have an inheritance relationship between these characteristics.\nFor symbols it gives the following diagram:\n It enables to write cross-format utility like nm. nm is a Unix utility to list symbols in an executable. The source code is available here: binutils\nWith the given inheritance relationship one can write this utility for the three formats in a single script:\n1 import lief 2 import sys 3 4 def nm(binary): 5 for symbol in binary.symbols: 6 print(symbol) 7 8 return 0 9 10 if __name__ == \u0026#34;__main__\u0026#34;: 11 r = nm(sys.argv[1]) 12 sys.exit(r) Conclusion As LIEF is still a young project we hope to have feedback, ideas, suggestions and pull requests.\nThe source code is available here: https://github.com/lief-project (under Apache 2.0 license) and the associated website: http://lief.quarkslab.com\nIf you are interested in use cases, you can take a look at these tutorials:\n Parse and manipulate formats Create a PE from scratch Play with ELF symbols Hooking Infecting the PLT/GOT  The project will be presented at the Third French Japanese Meeting on Cybersecurity\nContact  lief [at] quarkslab [dot] com Gitter: lief-project  Thanks Thanks to Serge Guelton and Adrien Guinet for their advice about the design and their code review. Thanks to Quarkslab for making this project open-source.\n","date":1491264e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"b9bd4190cd2fa4a30e4a6592ed242529","permalink":"https://www.romainthomas.fr/post/lief-release/","publishdate":"2017-04-04T00:00:00Z","relpermalink":"/post/lief-release/","section":"post","summary":"We are open-sourcing LIEF, a library to parse and manipulate ELF, PE and Mach-O binary formats. This blog post explains the purpose of this project and some parts of its architecture.","tags":["lief"],"title":"Open-sourcing LIEF","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" Slides   Video  ","date":1478736e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"1a0735ba90301927102613b40ff00d89","permalink":"https://www.romainthomas.fr/publication/triton-vm-protection/","publishdate":"2016-11-10T00:00:00Z","relpermalink":"/publication/triton-vm-protection/","section":"publication","summary":"The first part of the talk is going to be an introduction to the Triton framework to expose its components and to explain how they work together. Then, the second part will include demonstrations on how it's possible to reverse virtual machine based protections using taint analysis, symbolic execution, SMT simplifications and LLVM-IR optimizations. ","tags":null,"title":"How Triton can help to reverse virtual machine based software protections","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":"The purpose of this project is to provide a cross platform library to parse, modify and abstract ELF, PE and MachO formats.\nIt turns out that many projects need to parse executable formats and they usually re-implement their own parser. Moreover these parsers are usually bound to one language.\nLIEF attempts to fill this void.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"27b392443c4beb74582d91fdf0b881e8","permalink":"https://www.romainthomas.fr/project/lief/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/lief/","section":"project","summary":"LIEF is a Library to Instrument Executable Formats","tags":["lief","parser"],"title":"LIEF","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"466702894b9681de603c2d20894ce92c","permalink":"https://www.romainthomas.fr/projects-images/qlist/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/projects-images/qlist/","section":"projects-images","summary":"QList object layout from Qt 5.11.2","tags":["Qt","diagram"],"title":"QList","type":"projects-images"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"079a1531ec30efe31f620e573d057fa0","permalink":"https://www.romainthomas.fr/projects-images/qstring/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/projects-images/qstring/","section":"projects-images","summary":"QString object layout from Qt 5.11.2","tags":["Qt","diagram"],"title":"QString","type":"projects-images"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" ","date":1460073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"f5b338a9867ab7600598bc82969348e5","permalink":"https://www.romainthomas.fr/publication/dynamic-binary-analysis-and-obfuscation/","publishdate":"2016-04-08T00:00:00Z","relpermalink":"/publication/dynamic-binary-analysis-and-obfuscation/","section":"publication","summary":"At this presentation we will talk about how a DBA (Dynamic Binary Analysis) may help a reverse engineer to reverse obfuscated code. We will first introduce some basic obfuscation techniques and then expose how it's possible to break some stuffs (using our open-source DBA framework - Triton) like detect opaque predicates, reconstruct CFG, find the original algorithm, isolate sensible data and many more... Then, we will conclude with a demo and few words about our future work. ","tags":null,"title":"Dynamic Binary Analysis and Obfuscated Codes","type":"publication"},{"authors":["Romain Thomas"],"categories":["cryptography","write-up"],"content":"Introduction The crypto 300 challenge was about RSA with a special generation of the prime numbers $p$ and $q$. We were given a mail mail.msg which has been encrypted with RSA and whose the public key is in the hitbctf.crt certificate.\nRSA\u0026rsquo;s Parameters Construction The modulus $N$ is built by choosing randomly a first prime number $p$, the second prime number $q$ is constructed in the following way:\n$$\\alpha \\cdot (p - 1) \\equiv 1 \\pmod{e}$$\n$$q = (p\\alpha \\bmod e) + k\\cdot e$$\n$k$ is a positive integer such as $q$ is a prime number and $e$ is the public exponent which is also a random prime number.\nThe following code is the implementation in Python:\n1def gen_rsa_parameters(): 2 r = os.urandom(63) 3 e = int(r.encode(\u0026#39;hex\u0026#39;), 16) 4 e = next_prime(e) 5 r = os.urandom(64) 6 p = int(r.encode(\u0026#39;hex\u0026#39;), 16) 7 p = next_prime(p) 8 q = (p*modinv(p-1, e)%e) 9 while not is_prime(q): 10 q += e 11 N = p*q 12 phi = (p-1)*(q-1) 13 d = modinv(e,phi) 14 return N,e,d,p,q Theoretical attack Let\u0026rsquo;s $N^{\\prime} = N \\bmod{e}$. So we have\n\\begin{align} N^{\\prime} \u0026amp; \\equiv \u0026amp; p \\cdot q \\pmod{e} \\\\\\ \u0026amp; \\equiv \u0026amp; p \\cdot ((p\\alpha \\bmod e) + k\\cdot e) \\pmod{e} \\\\\\ \u0026amp; \\equiv \u0026amp; p^2\\alpha \\pmod{e} \\\\\\ \\end{align}\nWe have $\\alpha$ in the equation so we can introduce $p - 1$ to remove $\\alpha$\n\\begin{align} N^{\\prime} \u0026amp; \\equiv \u0026amp; (p - 1 + 1)^2\\alpha \\pmod{e} \\\\\\ \u0026amp; \\equiv \u0026amp; (p - 1)^2\\alpha + 2(p - 1)\\alpha + \\alpha \\pmod{e} \\\\\\ \u0026amp; \\equiv \u0026amp; (p - 1) + 2 + \\alpha \\pmod{e} \\\\\\ (p - 1)N^{\\prime} \u0026amp; \\equiv \u0026amp; (p - 1)^2 + 2(p - 1) + 1 \\pmod{e} \\end{align}\n$$\\boxed{(p - 1)^2 - (N^{\\prime} - 2)(p - 1) + 1 \\equiv 0 \\pmod{e}}$$\nNow we have a quadratic equation which only depends on $p$.\nLet\u0026rsquo;s $X = p - 1$ and suppose that $N^{\\prime} - 2$ is even and $N^{\\prime} - 2 = 2b$.\n\\begin{align} X^2 - 2bX + 1 \u0026amp; \\equiv \u0026amp; 0 \u0026amp; \\pmod{e} \\\\\\ (X - b)^2 - b^2 + 1 \u0026amp; \\equiv \u0026amp; 0 \u0026amp; \\pmod{e}\\\\\\ (X - b)^2 \u0026amp; \\equiv \u0026amp; b^2 - 1 \u0026amp; \\pmod{e} \\end{align}\nby using quadratic residue we can find a solution. We can also use SAGE and the sqrt() function:\n1Np = N % e 2b = (Np - 2) / 2 3p = Mod(pow(b, 2) - 1, e).sqrt() + b + 1 At this point, we find $p \\bmod{e}$ but not $p$ !\nI tried to find $p$ by adding some $e$ but the distance between $p$ and $p \\bmod{e}$ is huge. So I had to find another way.\nBy knowing $p \\bmod{e}$ we can compute $\\alpha$. Remember $$\\alpha \\cdot (p - 1) \\equiv 1 \\pmod{e}$$ and by having $\\alpha$ and $p \\bmod{e}$ we can brute force $q$ by adding $e$ until $(p\\alpha \\bmod e) + k\\cdot e$ is prime and it divide $N$.\nWe did the assumption that $N^{\\prime} - 2$ has to be even (so $N^{\\prime}$ must be even) and in the certificate $N^{\\prime}$ is even so everything is right.\nPratical Attack First we have to extract the modulus $N$ and the public key $e$ from the certificate:\n1$ openssl x509 -in hitbctf.crt -text -noout 23Certificate: 4Data: 5Version: 1 (0x0) 6Serial Number: 18379438180976429416 (0xff10e1a5ac5a0968) 7Signature Algorithm: sha1WithRSAEncryption 8Issuer: C=NL, ST=Noord-Holland, L=Amsterdam, O=HITB, OU=CTF 9Validity 10Not Before: May 24 09:58:26 2015 GMT 11Not After : May 23 09:58:26 2016 GMT 12Subject: C=NL, ST=Noord-Holland, L=Amsterdam, O=HITB, OU=CTF 13Subject Public Key Info: 14Public Key Algorithm: rsaEncryption 15Public-Key: (1024 bit) 16Modulus: 1700:e6:eb:89:c1:8d:49:c9:a2:02:2b:e0:b4:65:14: 186e:0f:90:45:1e:a3:4c:6b:60:56:00:4e:bd:15:59: 1955:b1:35:96:c2:d6:83:ad:2f:23:6b:0b:2c:0e:0b: 2088:83:b5:d6:cb:8a:0b:4f:f9:b7:eb:64:8c:95:2b: 216b:ef:5a:6f:04:f5:64:17:f5:1c:a9:14:d9:ea:73: 22e7:dd:c5:f2:0d:ce:c3:9c:e8:4b:72:2a:0c:f3:d8: 235e:80:ce:78:64:63:e1:44:f6:1d:b5:9c:cf:45:ff: 240e:d3:7f:d0:ce:bd:37:a5:8d:8a:4b:08:33:9e:a3: 252c:bc:ab:61:64:03:fd:2c:c5 26Exponent: 2769:60:2d:93:8a:81:5f:14:cf:9f:b8:36:c2:e0:4d: 284d:De:82:ba:fc:8d:56:c2:6d:8c:89:ef:3c:40:69: 295d:d5:d4:ef:a7:36:36:43:15:14:95:f3:8c:bf:24: 30ae:94:30:92:40:79:12:00:1b:17:f5:53:33:9e:92: 3170:70:49 32Signature Algorithm: sha1WithRSAEncryption 3317:2b:ea:be:90:ad:98:f2:2b:ff:f5:61:d3:ea:af:fb:35:3a: 3467:10:91:13:db:60:55:d9:09:8b:c2:1a:cf:6b:c6:1f:f2:10: 357a:d1:7b:9d:ff:10:f2:f2:c0:a9:f5:aa:2e:09:93:40:88:92: 367d:98:ff:e1:cb:dc:db:35:8d:e0:4b:21:99:76:bf:db:04:a2: 3762:a4:18:4e:fc:bb:a7:53:be:6a:a1:ef:ec:15:86:c1:f1:1e: 3887:6a:e9:af:fe:d1:08:eb:de:22:28:c4:5e:be:f1:41:0a:ca: 39cf:cf:da:63:b1:c1:56:e8:0c:8e:56:7f:08:94:0d:2b:2a:08: N = 1621575882314321757502664197090844942567381491984167028188381926885851 995558397927547394115469298694885747314992315746872071523931715177680193273 386465775883129725436206653605910592810579794603402792446164893148622893121 957048204358672599654432857497196823273138934901636721473789115585263150131 66594183212229\ne = 21558488234539889837938770635971330903489839146766895224490179041465516 1931455822669631548838317075220811407344210520390992334648372016602816069805 30249\nWith SAGE:\n1sage: Np = N % e 2sage: b = (Np - 2) / 2 3sage: pp = int(Mod(pow(b, 2) - 1, e).sqrt()) + b + 1 4sage: alpha = inverse_mod(int(X), int(e)) 5sage: q = (pp * alpha) % e 6sage: while not is_prime(q) and N % q != 0: 7....: q += e 8sage: p = N / q 9sage: p 1013317713478157317654574552532079837937895228108820477140030796245493222349714497856652987583926206280627498615972491072112647669795345566943409669535038641 11sage: q 1212176083266650126897170100375931110708350668494730113414987801764299563774952801449439933220072280766145748279998832962142839152786620322097065894585706069 We can now generate the private key by using rsatool:\n1$ ./rsatools.py -o private.pem \\ 2-e 21558488234539889837938770635971330903489839146766895224490179041465516193145582266963154883831707522081140734421052039099233464837201660281606980530249 \\ 3-p 13317713478157317654574552532079837937895228108820477140030796245493222349714497856652987583926206280627498615972491072112647669795345566943409669535038641 \\ 4-q 12176083266650126897170100375931110708350668494730113414987801764299563774952801449439933220072280766145748279998832962142839152786620322097065894585706069 Finally, we can decrypt the message:\n1openssl smime -decrypt -in mail.msg -inkey private.pem 2hitb{0b21cc2025534dbd2965390d2bcef45d} The sources are available here\n","date":1446508800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"bfd9a832e015cbe54fb5349a493df00d","permalink":"https://www.romainthomas.fr/post/15-11-hitb2015-crypto300/","publishdate":"2015-11-03T00:00:00Z","relpermalink":"/post/15-11-hitb2015-crypto300/","section":"post","summary":"Write-up for the Crypto 300 challenge","tags":["write-up","cryptography"],"title":"HITB 2015 Write-up - Crypto 300","type":"post"},{"authors":["Romain Thomas"],"categories":["write-up","cryptography"],"content":"Introduction The crypto 400 challenge deals with the Even Mansour cryptosystem. To validate this challenge we have to send the flag to a server. The server checks if the answer matches the flag by encrypting the flag and the given message with a random key. If both are equal the flag is correct otherwise it fails and the encrypted message is printed.\n1key = os.urandom(32) 2enc_flag = encrypt(flag, key) 3enc = encrypt(answer, key) 4 5if enc == enc_flag: 6 response = \u0026#34;You lucky bastard, %sis indeed the correct flag!\\n\u0026#34; % flag 7else: 8 response = \u0026#34;Unfortunately that is not our flag :(\\n\u0026#34; 9 response += \u0026#34;Your guess encrypts as\\n%s\u0026#34; % enc 10 response += \u0026#34;whereas our flag encrypts as\\n%s\u0026#34; % enc_flag Even Mansour scheme In this Even-Masour scheme the size of a block is 16-bytes and the key \u0026mdash; on 32-bytes \u0026mdash; is split in two: $k_1$ and $k_2$ each one on 16-bytes. At first, the message $M$ is xor-ed with $k_1$ then $M \\oplus k_1$ is going through a $F$ function which will be discussed later. Finally the output is xor-ed with $k_2$.\nSo we have:\n$$C = F(M \\oplus k_1) \\oplus k_2$$\n1def EvenMansour(block, key): 2 block = xor(block, key[:16]) 3 block = F(block) 4 block = xor(block, key[16:]) 5 return block In this challenge, the weakness comes from the $F$ function.\n$F$ function The $F$ function is composed of 64-rounds that perform the step(...) transformation:\n1def F(block): 2 for i in range(64): 3 block = step(block) 4 return block step uses a S-Box to transform the block in this way:\n$\\begin{cases} \\text{block}^{n+1}_0 = \\text{SBox}(\\text{block}^{n}_{10} \\oplus \\text{block}^{n}_{12} \\oplus \\text{block}^{n}_{13} \\oplus \\text{block}^{n+1}_{15}) \u0026amp; k = 0 \\\\\\ \\text{block}^{n+1}_k = \\text{block}^{n}_{k - 1} \u0026amp; k \u0026gt; 0 \\end{cases}$\n$\\text{block}^{n}_k$ is the byte $k$ of the block at round $n$ ($0 \\leq k \u0026lt; 16$ and $0 \\leq n \u0026lt; 64$)\n1def step(block): 2 return chr( S[ ord(block[10]) ^ ord(block[12]) ^ ord(block[13]) ^ ord(block[15]) ] ) + block[:15] By ploting $y = \\text{S-Box}(x)$ we can notice that the S-Box has a special construction:\nI thought about computing the differential characteristics which is the probability that given the input difference $\\Delta = x \\oplus y$ we get the output delta: $\\delta = S(x) \\oplus S(y)$. We will call this probability $P(\\Delta | \\delta)$ and with following function, we can compute this probability:\n1def P(dx ,dy): 2 count = 0; 3 for x in range(len(SBox)): 4 dY = SBox[x] ^ SBox[x ^ dx] 5 if dY == dy: 6 count += 1; 7 return float(count) / float(256) For all $\\Delta$ and $\\delta$, we notice that this probability is either 0 or 1. Consequently if we know $\\delta$ we are sure to find $\\Delta$. This will be useful for the differential attack.\nDifferential Attack To find the flag, we will perform a differential attack. We have a message $M_1$ that we know and we have an unknown second message $M_2$ that is the flag. We also know $C_1$ and $C_2$ such as:\n$$\\begin{align} C_1 \u0026amp; = \u0026amp; F(M_1 \\oplus k_1) \\oplus k_2 \\\\\\ C_2 \u0026amp; = \u0026amp; F(M_2 \\oplus k_1) \\oplus k_2 \\end{align}$$\nBy xor-ing $C_1$ and $C_2$ we can get $\\Delta W = W_1 \\oplus W_2 = C_1 \\oplus C_2$. If somehow we can resolve $\\Delta V$:\n$$\\begin{align} \\Delta V \u0026amp; = \u0026amp; V_1 \\oplus V_2 \\\\\\ \u0026amp; = \u0026amp; M_1 \\oplus k_1 \\oplus M_2 \\oplus k_1\\\\\\ \u0026amp; = \u0026amp; M_1 \\oplus M_2. \\end{align}$$\nWe can extract $M_2$ with:\n$$M_2 = \\Delta V \\oplus M_1$$\nRecovering $\\Delta V$ Now, let\u0026rsquo;s see how to resolve $\\Delta V$ from $\\Delta W$.\nFrom the step function, we know that $\\text{block}^{n+1}_k = \\text{block}^{n}_{k - 1}$ therefore:\n$$\\Delta W^{n-1}_k = \\Delta W^{n}_{k + 1} \\forall k \u0026lt; 15$$\nWe know also $\\Delta W^{n-1}_{0,1,2 \\ldots 14}$ but not $\\Delta W^{n-1}_{15}$\nTo find $\\Delta W^{n-1}_{15}$ we will use the fact that $P(\\Delta X | \\Delta W^{n-1}_{15}) = 1$ for a given $\\Delta X$. Concretely, I built a table diffTable which maps $\\delta$ to $\\Delta$.\n\\begin{align} \\text{diffTable}(\\Delta W^{n}_{0}) \u0026amp; = \u0026amp; \\Delta W^{n-1}_{10} \\oplus \\Delta W^{n-1}_{12} \\oplus \\Delta W^{n-1}_{13} \\oplus \\Delta W^{n-1}_{15} \\\\\\ \u0026amp; = \u0026amp; \\Delta W^{n}_{11} \\oplus \\Delta W^{n}_{13} \\oplus \\Delta W^{n}_{14} \\oplus \\Delta W^{n-1}_{15}\\\\\\ \\Delta W^{n-1}_{15} \u0026amp; = \u0026amp; \\text{diffTable}(\\Delta W^{n}_{0}) \\oplus \\Delta W^{n}_{11} \\oplus \\Delta W^{n}_{13} \\oplus \\Delta W^{n}_{14} \\end{align}\nWhich enables to recover $\\Delta W^{n - 1}$ from $\\Delta W^{n}$. Then, with recursion we can compute $\\Delta W^{0} = \\Delta V$\nImplementation The following script is the implementation of the attack:\n1#!/usr/bin/python2.7 2# -*- coding: utf-8 -*- 3import os 4 5S = [ 6 0xa5,0xc6,0x62,0x01,0x49,0x2a,0x8e,0xed,0x1f,0x7c,0xd8,0xbb,0xf3,0x90,0x34,0x57, 7 0xb3,0xd0,0x74,0x17,0x5f,0x3c,0x98,0xfb,0x09,0x6a,0xce,0xad,0xe5,0x86,0x22,0x41, 8 0x89,0xea,0x4e,0x2d,0x65,0x06,0xa2,0xc1,0x33,0x50,0xf4,0x97,0xdf,0xbc,0x18,0x7b, 9 0x9f,0xfc,0x58,0x3b,0x73,0x10,0xb4,0xd7,0x25,0x46,0xe2,0x81,0xc9,0xaa,0x0e,0x6d, 10 0xfd,0x9e,0x3a,0x59,0x11,0x72,0xd6,0xb5,0x47,0x24,0x80,0xe3,0xab,0xc8,0x6c,0x0f, 11 0xeb,0x88,0x2c,0x4f,0x07,0x64,0xc0,0xa3,0x51,0x32,0x96,0xf5,0xbd,0xde,0x7a,0x19, 12 0xd1,0xb2,0x16,0x75,0x3d,0x5e,0xfa,0x99,0x6b,0x08,0xac,0xcf,0x87,0xe4,0x40,0x23, 13 0xc7,0xa4,0x00,0x63,0x2b,0x48,0xec,0x8f,0x7d,0x1e,0xba,0xd9,0x91,0xf2,0x56,0x35, 14 0x14,0x77,0xd3,0xb0,0xf8,0x9b,0x3f,0x5c,0xae,0xcd,0x69,0x0a,0x42,0x21,0x85,0xe6, 15 0x02,0x61,0xc5,0xa6,0xee,0x8d,0x29,0x4a,0xb8,0xdb,0x7f,0x1c,0x54,0x37,0x93,0xf0, 16 0x38,0x5b,0xff,0x9c,0xd4,0xb7,0x13,0x70,0x82,0xe1,0x45,0x26,0x6e,0x0d,0xa9,0xca, 17 0x2e,0x4d,0xe9,0x8a,0xc2,0xa1,0x05,0x66,0x94,0xf7,0x53,0x30,0x78,0x1b,0xbf,0xdc, 18 0x4c,0x2f,0x8b,0xe8,0xa0,0xc3,0x67,0x04,0xf6,0x95,0x31,0x52,0x1a,0x79,0xdd,0xbe, 19 0x5a,0x39,0x9d,0xfe,0xb6,0xd5,0x71,0x12,0xe0,0x83,0x27,0x44,0x0c,0x6f,0xcb,0xa8, 20 0x60,0x03,0xa7,0xc4,0x8c,0xef,0x4b,0x28,0xda,0xb9,0x1d,0x7e,0x36,0x55,0xf1,0x92, 21 0x76,0x15,0xb1,0xd2,0x9a,0xf9,0x5d,0x3e,0xcc,0xaf,0x0b,0x68,0x20,0x43,0xe7,0x84 22] 23 24def xor(block1, block2): 25 return \u0026#34;\u0026#34;.join( chr(ord(a) ^ ord(b)) for (a,b) in zip(block1, block2)) 26 27def step(block): 28 return chr(S[ord(block[10]) ^ ord(block[12]) ^ ord(block[13]) ^ ord(block[15])]) + block[:15] 29 30def F(block): 31 for i in xrange(64): 32 block = step(block) 33 return block 34 35def EvenMansour(block, key): 36 block = xor(block, key[:16]) 37 block = F(block) 38 block = xor(block, key[16:]) 39 return block 40 41def encrypt(data, key): 42 data, num_blocks = pad(data) 43 res = \u0026#34;\u0026#34; 44 for i in xrange(num_blocks): 45 block = EvenMansour(data[16*i:16*i+16], key) 46 res += block 47 return res 48 49def pad(data): 50 while True: 51 data += \u0026#39;\\x00\u0026#39; 52 if len(data) % 16 == 0: 53 return data, len(data) / 16 54 55# 56# Table T[a] = b such as 57# S[x] ^ S[y] = a and b = x ^ y 58# 59def DiffTable(S): 60 table = [0 for i in range(len(S))] 61 for delta in range(len(S)): 62 for x in range(len(S)): 63 dY = S[x] ^ S[x ^ delta] 64 table[dY] = delta 65 return table 66 67 68def main(): 69 key = os.urandom(32) 70 M1 = \u0026#34;hitb{0123456789abcdef}\u0026#34; 71 M2 = \u0026#34;aaaaaaaaaaaaaaaaaaaaaa\u0026#34; 72 73 C1 = encrypt(M1, key) 74 C2 = encrypt(M2, key) 75 76 numberOfBlocks = len(C2) / 16 77 diffTable = DiffTable(S) 78 clearText = \u0026#34;\u0026#34; 79 80 for block in range(numberOfBlocks): 81 dW = xor(C1,C2)[16 * block : 16 * (block + 1)] 82 for i in range(64): 83 dWtemp = [dW[i + 1] for i in range(15)] 84 85 delta = diffTable[ord(dW[0])] 86 dW15 = chr(ord(dW[11]) ^ ord(dW[13]) ^ ord(dW[14]) ^ delta) 87 dWtemp.append(dW15) 88 89 dW = \u0026#34;\u0026#34;.join(dWtemp) 90 M = xor(dW, M2[16 * block : 16 * (block + 1)]) 91 clearText += M 92 print clearText 93 94if __name__ == \u0026#39;__main__\u0026#39;: 95 main() Conclusion In fact by noticing that\n$$F(x \\oplus y) = F(x) \\oplus F(y) \\oplus C^{te}$$\n1for b in xrange(10): 2 u = os.urandom(16); 3 v = os.urandom(16); 4 d = xor(F(xor(u,v)), xor(F(u), F(v))) 5 print d.encode(\u0026#34;hex\u0026#34;) We have:\n\\begin{align} F(M_1 \\oplus k_1) \\oplus F(M_2 \\oplus k_1) \u0026amp; = \u0026amp; F(M_1) \\oplus F(M_2)\\ M_2 \u0026amp; = \u0026amp; F^{-1}(F(M_1) \\oplus C_1 \\oplus C_2) \\end{align}\nWhich is far more easier to resolve.\nThanks to jb^ who help me and who find the previous technique.\nSources are available here\n","date":1446508800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"6632e421a5370b9bd27f6a6e74ebe4c8","permalink":"https://www.romainthomas.fr/post/15-11-hitb2015-crypto400/","publishdate":"2015-11-03T00:00:00Z","relpermalink":"/post/15-11-hitb2015-crypto400/","section":"post","summary":"Write up","tags":["write-up","cryptography"],"title":"HITB 2015 Write-up - Crypto 400","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":"Introduction Code coverage is mainly used in the vulnerability research area. The goal is to generate inputs which will reach different parts of the program\u0026rsquo;s code. Then, if an input makes the program crash, we check if the crash can be exploited or not. A lot of methods exist to perform code coverage - like random testing or mutation generation - but in this short blog post, we will focus on code coverage using a dynamic symbolic execution (DSE) and explain why it\u0026rsquo;s not a trivial task. Please, note that covering up the code doesn\u0026rsquo;t mean finding every possible bugs. Some bugs do not make the program crash and this talk from slides 35 to 38 explains why. However, if we perform model checking associated with code coverage, it starts to get interesting =).\nCode coverage and DSE Note that unlike a SSE (static symbolic execution), a DSE is applied on a trace and can discover new branches only if these ones are reached during the execution. To go through another path, we must solve one of the last branch constraints discovered from the last trace. Then, we repeat this operation until all branches are taken.\nFor example, let\u0026rsquo;s assume a program $P$ which takes an input called $I$, where I may be a model $M$ or a random seed $R$. An execution is denoted $P(I)$ and returns a set of constraints $PC$. All $\\varphi_{i}$ represent basic blocks and $\\pi_i$ represent the branches constraint. A model $M_i$ is (at least) one valid solution of a constraint $\\pi_i$. For example, $M_1 = Solution(\\neg\\pi_1 \\land \\pi_2)$. To discover all paths, we maintain a worklist denoted $W$ which is a set of $M$.\nAt the first iteration, $I = R, W = \\emptyset$ and $P(I) \\rightarrow PC$. Then, $\\forall \\pi \\in PC, W = W \\cup { Solution(\\pi) }$ and we execute once again the program such that $\\forall M \\in W, P(M)$. When a model $M$ is injected in the program\u0026rsquo;s input, it is deleted from the worklist $W$. Then, we repeat this operation until $W$ is empty.\nSymbolic code coverage implies some pros and cons. For us, it is really useful when we work on a obfuscated binary. Indeed, applying symbolic coverage can detect opaque predicates or unreachable code but also repair a flattened graph (we will release soon another blog post about Triton and o-llvm). The worst con about the symbolic execution is when your expressions are too complexes which implies a timeout from the SMT solver or an impressive memory consumption (in the past, our bigger symbolic expression has consumed ~450 Go of RAM before timeout). This scenario mainly occurs when we analyse real large binaries or obfuscated binaries which contain polynomial functions. Some of these cons may partially be fixed by optimizing symbolic expressions but this subject will be another story to come later :).\nPerforming code coverage using Triton Since the version v0.1 build 633 (commit 474fe2), Triton integrates everything we need to perform code coverage. These new features allow us to deal and compute the SMT2-Lib representation over an AST. In the rest of the blog post, we will focus on the design and the algorithm used to perform code coverage.\nAlgorithm As an introduction (and to not turn our brain upside down), let assume this following sample of code which comes from the samples directory.\n1char *serial = \u0026#34;\\x31\\x3e\\x3d\\x26\\x31\u0026#34;; 2int check(char *ptr) 3{ 4 int i = 0; 5 while (i \u0026lt; 5){ 6 if (((ptr[i] - 1) ^ 0x55) != serial[i]) 7 return 1; 8 i++; 9 } 10 return 0; 11} Basically, this function checks if the input is equal to elite, and returns 0 if it is true, otherwise it returns 1. The control flow graph of this function is described below. It\u0026rsquo;s an interesting first example, because to cover all basic blocks we need to find the good input.\nWe can see that only one variable can be controlled, the one located at the address rbp+var_18 which refers to the argv[1] \u0026rsquo;s pointer. The goal is to reach all the basic blocks in the function check by computing the constraints and using the snapshot engine until that every basic blocks are reached. For instance, the constraint to reach the basic block located at the address 0x4005C3 is [rbp+var_4] \u0026gt; 4 but we do not control this variable directly. In the other hand, the jump at the address 0x4005B0 depends on the user input and this constraint can be solved by performing a symbolic execution.\nThe algorithm which generalizes the previous idea is based on the Microsoft\u0026rsquo;s fuzzer algorithm (SAGE) and the next diagram represents our check function with its constraints. The start and end nodes represent respectively the function\u0026rsquo;s prologue (0x40056D) and the function\u0026rsquo;s epilogue (0x4005C8).\nBefore the first execution, we know nothing about branches\u0026rsquo; constraints. So, as explained in the previous chapter, we inject some random seeds to collect the first $PC$ and build our set $W$. The trace of the first execution $P(I)$ is represented by the basic blocks in blue.\nThis execution gives us our first path constraint $P(I) \\rightarrow (\\pi_0 \\land \\neg \\pi_1)$.\nBased on our first trace, we know that there are two branches ($\\pi_0 \\land \\neg \\pi_1$) discovered and so 2 others undiscovered. To reach the basic bloc $\\varphi_3$, we compute the negation of the first branch constraint. If and only if the solution $Solution(\\neg \\pi_0)$ is SAT, we add the model to the worklist W.\nSame for $\\varphi_4$ such that $W = W \\cup {Solution(\\pi_0 \\land \\neg(\\neg \\pi_1))}$. Once all solutions have been generated and models added to the worklist, we execute every models from the worklist.\nImplementation One condition to perform code coverage, is to predict the next instruction address when we are on a jump instruction. This condition is necessary to build the path constraint.\nWe can not put a callback after a branch instruction because the RIP register has already changed. As Triton creates semantics expressions for all registers, the idea is to evaluate RIP when we are on a branch instruction.\nIn a first time, we have developed a SMT evaluator to compute the RIP but we saw a little bit later that Pin provides IARG_BRANCH_TARGET_ADDR and IARG_BRANCH_TAKEN which can be used to know the next RIP values. With Pin, computing the next address is very easy, nevertheless the SMT evaluator was useful to check instruction\u0026rsquo;s semantics.\nTo perform the evaluation, we implemented the visitor pattern to transform the SMT abstract syntax tree (AST) to a Z3 AST. This design can be used to transform our SMT AST into any others representations.\nThe Z3 AST is easier to handle and can be evaluated or simplified with Z3 API. The transformation is performed by src/smt2lib/z3AST.h and src/smt2lib/z3AST.cpp.\n We will now explain how the code coverage\u0026rsquo;s tool works. Let\u0026rsquo;s assume that inputs come from command\u0026rsquo;s line. Firstly, we have:\n199 200 201 202 203  def run(inputSeed, entryPoint, exitPoint, whitelist = []):  ...  if __name__==\u0026#39;__main__\u0026#39;:  TritonExecution.run(\u0026#34;bad !\u0026#34;, 0x400480, 0x40061B, [\u0026#34;main\u0026#34;, \u0026#34;check\u0026#34;]) # crackme_xor   At line 176, we define the input seed bad ! which is the first program\u0026rsquo;s argument (argv[1]). Then, we give the address from the beginning of the code coverage (start block) - it\u0026rsquo;s at this address that we will take a snapshot. The third argument matches with the end block - it\u0026rsquo;s at this address that we will restore the snapshot. Finally, we can set a whitelist to avoid specific functions like library\u0026rsquo;s functions, cryptographic\u0026rsquo;s function and so on.\n134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155  def mainAnalysis(threadId):   print \u0026#34;[+] In main\u0026#34;  rdi = getRegValue(IDREF.REG.RDI) # argc  rsi = getRegValue(IDREF.REG.RSI) # argv   argv0_addr = getMemValue(rsi, IDREF.CPUSIZE.QWORD) # argv[0] pointer  argv1_addr = getMemValue(rsi + 8, IDREF.CPUSIZE.QWORD) # argv[1] pointer   print \u0026#34;[+] In main() we set :\u0026#34;  od = OrderedDict(sorted(TritonExecution.input.dataAddr.items()))   for k,v in od.iteritems():  print \u0026#34;\\t[0x%x] = %x%c\u0026#34; % (k, v, v)  setMemValue(k, IDREF.CPUSIZE.BYTE, v)  convertMemToSymVar(k, IDREF.CPUSIZE.BYTE, \u0026#34;addr_%d\u0026#34; % k)   for idx, byte in enumerate(TritonExecution.input.data):  if argv1_addr + idx not in TritonExecution.input.dataAddr: # Not overwrite the previous setting  print \u0026#34;\\t[0x%x] = %x%c\u0026#34; % (argv1_addr + idx, ord(byte), ord(byte))  setMemValue(argv1_addr + idx, IDREF.CPUSIZE.BYTE, ord(byte))  convertMemToSymVar(argv1_addr + idx, IDREF.CPUSIZE.BYTE, \u0026#34;addr_%d\u0026#34; % idx)   The next code being executed is the mainAnalysis callback, we inject values to the inputs selected (line 148, 154) and we convert these inputs as symbolic variables (line 149, 155).\nAll inputs selected are stored in a global variable called TritonExecution.input. Then, we can begin the code exploration.\n58 59 60 61  if instruction.getAddress() == TritonExecution.entryPoint and not isSnapshotEnabled():  print \u0026#34;[+] Take Snapshot\u0026#34;  takeSnapshot()  return   When we are at the entry point, we take a snapshot in order to replay code exploration with a new input.\n63 64 65 66 67 68 69 70 71 72 73 74  if instruction.isBranch() and instruction.getRoutineName() in TritonExecution.whitelist:   addr1 = instruction.getAddress() + 2 # Address next to this one  addr2 = instruction.getOperands()[0].getValue() # Address in the instruction condition   # [PC id, address taken, address not taken]  if instruction.isBranchTaken():  TritonExecution.myPC.append([ripId, addr2, addr1])  else:  TritonExecution.myPC.append([ripId, addr1, addr2])   return   This test above checks if we are on a branch instruction like (jnz, jle \u0026hellip;) and if we are in a function which is into the white list. If so, we get the two possible addresses (addr1 and addr2) and the effective address is computed by isBranchTaken() (line 69).\nThen, we store into the path constraint the RIP expression, the address taken and the address not taken (line 73-76).\n81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126  if instruction.getAddress() == TritonExecution.exitPoint:  print \u0026#34;[+] Exit point\u0026#34;   # SAGE algorithm  # http://research.microsoft.com/en-us/um/people/pg/public_psfiles/ndss2008.pdf  for j in range(TritonExecution.input.bound, len(TritonExecution.myPC)):  expr = []  for i in range(0,j):  ripId = TritonExecution.myPC[i][0]  symExp = getFullExpression(getSymExpr(ripId).getAst())  addr = TritonExecution.myPC[i][1]  expr.append(smt2lib.smtAssert(smt2lib.equal(symExp, smt2lib.bv(addr, 64))))   ripId = TritonExecution.myPC[j][0]  symExp = getFullExpression(getSymExpr(ripId).getAst())  addr = TritonExecution.myPC[j][2]  expr.append(smt2lib.smtAssert(smt2lib.equal(symExp, smt2lib.bv(addr, 64))))    expr = smt2lib.compound(expr)  model = getModel(expr)   if len(model) \u0026gt; 0:  newInput = TritonExecution.input  newInput.setBound(j + 1)   for k,v in model.items():  symVar = getSymVar(k)  newInput.addDataAddress(symVar.getKindValue(), v)  print newInput.dataAddr   isPresent = False   for inp in TritonExecution.worklist:  if inp.dataAddr == newInput.dataAddr:  isPresent = True  break  if not isPresent:  TritonExecution.worklist.append(newInput)   # If there is input to test in the worklist, we restore the snapshot  if len(TritonExecution.worklist) \u0026gt; 0 and isSnapshotEnabled():  print \u0026#34;[+] Restore snapshot\u0026#34;  restoreSnapshot()   return   The last step happens when we are on the exit point. Lines 84 to 120 are the SAGE implementation. In few words, we browse the path constraints\u0026rsquo; list and for each PC, we try to get the model which satisfies the negation. If there is a valid model to reach the new target basic block, we add the model into the worklist.\nOnce all models are inserted into the worklist, we restore the snapshot and we re-inject each model as input seed.\nThe full code can be found here and its execution on our example looks like this:\n$ ./triton ./tools/code_coverage.py ./samples/crackmes/crackme_xor abc [+] Take Snapshot [+] In main [+] In main() we set :  [0x7ffd5ef8254d] = 62 b  [0x7ffd5ef8254e] = 61 a  [0x7ffd5ef8254f] = 64 d  [0x7ffd5ef82550] = 20  [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774221: 101} [+] Restore snapshot [+] In main [+] In main() we set :  [0x7ffd5ef8254d] = 65 e  [0x7ffd5ef8254e] = 61 a  [0x7ffd5ef8254f] = 64 d  [0x7ffd5ef82550] = 20  [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774221: 101, 140726196774222: 108} [+] Restore snapshot [+] In main [+] In main() we set :  [0x7ffd5ef8254d] = 65 e  [0x7ffd5ef8254e] = 6c l  [0x7ffd5ef8254f] = 64 d  [0x7ffd5ef82550] = 20  [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774221: 101, 140726196774222: 108, 140726196774223: 105} [+] Restore snapshot [+] In main [+] In main() we set :  [0x7ffd5ef8254d] = 65 e  [0x7ffd5ef8254e] = 6c l  [0x7ffd5ef8254f] = 69 i  [0x7ffd5ef82550] = 20  [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774224: 116, 140726196774221: 101, 140726196774222: 108, 140726196774223: 105} [+] Restore snapshot [+] In main [+] In main() we set :  [0x7ffd5ef8254d] = 65 e  [0x7ffd5ef8254e] = 6c l  [0x7ffd5ef8254f] = 69 i  [0x7ffd5ef82550] = 74 t  [0x7ffd5ef82551] = 21 ! loose [+] Exit point {140726196774224: 116, 140726196774225: 101, 140726196774221: 101, 140726196774222: 108, 140726196774223: 105} [+] Restore snapshot [+] In main [+] In main() we set :  [0x7ffd5ef8254d] = 65 e  [0x7ffd5ef8254e] = 6c l  [0x7ffd5ef8254f] = 69 i  [0x7ffd5ef82550] = 74 t  [0x7ffd5ef82551] = 65 e Win [+] Exit point [+] Done ! Further improvement Currently, the evaluator is quite slow and we loose a lot of time to evaluate expressions. One feature that should improve the evaluator speed is a SMT simplifier. We plan to develop a passes system (like LLVM) to simplify the SMT tree.\nThe goal is to register some expressions transformation rules before sending expressions to the evaluator or the solver. For example, that\u0026rsquo;s what miasm2 already does.\nThere are a lot of mini tricks to lighten symbolic expressions which are easy to implement and really beneficial. For example, the transformation of the expression rax1 = (bvxor rax0 rax0) -\u0026gt; rax1 = (_ bv64 0) will break the rax\u0026rsquo;s symbolic expression chain.\nConclusion Although the code coverage using a symbolic resolution is a nice way to cover a code without guessing the inputs, it\u0026rsquo;s clearly not a trivial task. The paths explosion implies the memory consumption and in several cases the expressions are too complex to be computed but this method remains truly effective on short parts of code.\n    Note To improve the symbolic coverage, it could be interesting to deal with bits-flip/random seeds when expressions are too complex or to deal with symbolic execution and abstract domains.     ","date":1444608e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1652536515,"objectID":"656395ca2a0463a0cac1f5ee6f7e2c61","permalink":"https://www.romainthomas.fr/post/15-10-triton-code-coverage/","publishdate":"2015-10-12T00:00:00Z","relpermalink":"/post/15-10-triton-code-coverage/","section":"post","summary":"This blog post introduces code coverage with Triton","tags":[""],"title":"Code coverage using a dynamic symbolic execution","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" ","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650903950,"objectID":"e47dace0552b838319d6e65e53b32139","permalink":"https://www.romainthomas.fr/publication/triton/","publishdate":"2015-09-01T00:00:00Z","relpermalink":"/publication/triton/","section":"publication","summary":"Binary obfuscation is used to protect software's intellectual property. There exist different kinds of obfucation but roughly, it transforms a binary structure into another binary structure by preserving the same semantic. The aim of obfuscation is to ensure that the original information is 'drown' in useless information that will make reverse engineering harder. In this article we will show how we can analyse an ofbuscated program and break some obfuscations using the Triton framework","tags":null,"title":"How Triton may help to analyse obfuscated binaries","type":"publication"}]