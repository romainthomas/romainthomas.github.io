<!doctype html><html lang=en-us prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=manifest href=manifest.webmanifest><link rel=icon type=image/png href=/img/favicon/favicon_hu2a60c33e6cc729e53465c846fe50d8b2_13867_32x32_fill_box_center_3.png><link rel=apple-touch-icon type=image/png href=/img/favicon/favicon_hu2a60c33e6cc729e53465c846fe50d8b2_13867_192x192_fill_box_center_3.png><meta name=description content="This second blog post explains how to recover the whitebox's key from the obfuscated library libnative-lib.so"><meta name=keywords content="android,reverse engineering,write-up,obfuscation,whitebox,cryptography"><meta property="og:type" content="article"><meta property="og:description" content="This second blog post explains how to recover the whitebox's key from the obfuscated library libnative-lib.so"><meta property="og:title" content="r2-pay: whitebox (part 2) | Romain Thomas"><meta property="og:site_name" content="Romain Thomas"><meta property="og:image" content="https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part2/featured.png"><meta property="og:url" content="https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part2/"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2020-09-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-14T15:55:15+02:00"><meta property="article:tag" content="android"><meta property="article:tag" content="reverse engineering"><meta property="article:tag" content="write-up"><meta property="article:tag" content="obfuscation"><meta property="article:tag" content="whitebox"><meta property="article:tag" content="cryptography"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@rh0main"><meta name=twitter:creator content="@rh0main"><meta name=twitter:title content="r2-pay: whitebox (part 2) | Romain Thomas"><meta name=twitter:description content="This second blog post explains how to recover the whitebox's key from the obfuscated library libnative-lib.so"><meta name=twitter:domain content="https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part2/"><meta property="twitter:image" content="https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part2/featured.png"><title>Romain Thomas</title><link rel=canonical href=https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part2/><link rel=stylesheet href=/css/fa-all.min.css><link rel=stylesheet href=/vendor/@glidejs/glide/dist/css/glide.core.min.css><link rel=stylesheet href=/vendor/@glidejs/glide/dist/css/glide.theme.min.css><link rel=stylesheet href=/css/theme.bundle.css><style>.hide{opacity:0}</style><noscript><style>.hide{opacity:1;!important}</style></noscript><style>.hero_background{position:relative;overflow:hidden}.hero_background:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:90%;z-index:1;opacity:.2;background-image:url(/img/bg_home.svg);background-repeat:repeat;background-position:50%;background-size:100%;transform:rotate(180deg)}.project_bg{position:relative;overflow:hidden}.project_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;opacity:.1;background-image:url(/img/bg_project.svg);background-repeat:repeat;background-position:50%;background-size:100%;transform:rotate(180deg)}.experience_bg{position:relative;overflow:hidden}.experience_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;opacity:.1;background-image:url(/img/bg_experience.svg);background-position:0 0;background-size:100%}.post_bg{position:relative;overflow:hidden}.post_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:80%;z-index:1;opacity:.6;background-image:url(/img/bg_post.svg);background-position:0 0;background-size:100%}.contact_bg{position:relative;overflow:hidden}.contact_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:80%;z-index:1;opacity:.2;background-image:url(/img/bg_contact.svg);background-position:0 0;background-size:100%}.footnotes p{margin-bottom:0}.highlight{padding-left:20px;border-left:1px solid rgba(0,0,0,.1);border-radius:2px 2px}</style></head><body><header class=header-global><nav id=navbar-main aria-label="Primary navigation" class="navbar navbar-main navbar-expand-lg navbar-theme-primary headroom navbar-dark"><div class="container position-relative"><a class="navbar-brand me-lg-5" href=https://www.romainthomas.fr/><span class="navbar-brand-dark ft-ananda">R. T</span>
<span class="navbar-brand-light ft-ananda">R. T</span></a><div class="navbar-collapse collapse me-auto" id=navbar_global><div class=navbar-collapse-header><div class=row><div class="col-6 collapse-close"><a href=#navbar_global class="fas fa-times" data-bs-toggle=collapse data-bs-target=#navbar_global aria-controls=navbar_global aria-expanded=false title=close aria-label="Toggle navigation"></a></div></div></div><ul class="navbar-nav navbar-nav-hover align-items-lg-center"><li class=nav-item><a href=https://www.romainthomas.fr/#about class="nav-link fw-bold"><span class="fa-regular fa-person-swimming"></span> About</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#posts class="nav-link fw-bold"><span class="fa-regular fa-blog"></span> Posts</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#projects class="nav-link fw-bold"><span class="fa-regular fa-terminal"></span> Projects</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#publications class="nav-link fw-bold"><span class="far fa-book-open-cover"></span> Publications</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#work-experience class="nav-link fw-bold"><span class="fa-regular fa-briefcase"></span> Work Experience</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#misc class="nav-link fw-bold"><span class="fa-regular fa-chart-network"></span> Misc</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#contact class="nav-link fw-bold"><span class="fa-regular fa-binary-lock"></span> Contact</a></li></ul></div><div class="d-flex align-items-center"><button class="navbar-toggler ms-2 collapsed" type=button data-bs-toggle=collapse data-bs-target=#navbar_global aria-controls=navbar_global aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button></div></div></nav></header><main><section class="section-header pb-5 pb-sm-7 bg-primary text-white post_bg"><div class=container><div class="row justify-content-center"><div class="col-12 col-lg-10 text-center"><div class=mb-4><a href=/categories/android/><span class="me-2 badge alert-info text-uppercase px-3 btn-outline-primary">Android</span>
</a><a href=/categories/reverse-engineering/><span class="me-2 badge alert-info text-uppercase px-3 btn-outline-primary">Reverse Engineering</span></a></div><h1 class="display-3 mb-4 px-lg-5">r2-pay: whitebox (part 2)</h1><div class=post-meta><span class="fw-bold me-3">Romain Thomas</span>
<span class="post-date me-3">September 27, 2020</span>
<span class=fw-bold>7 min read</span></div></div></div></div><figure class="position-absolute bottom-0 left-0 w-100 d-none d-md-block mb-n2"><svg class="fill-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 3e3 185.4"><path d="M3e3.0v185.4H0V0c496.4 115.6 996.4 173.4 15e2 173.4S2503.6 115.6 3e3.0z"/></svg></figure></section><section class="section section-lg pt-0 pb-0" id=featured><div class="container mt-n8 mt-lg-n10 z-2 pb-0"><div class="row mt-7 mx-10"><img src=/post/20-09-r2con-obfuscated-whitebox-part2/featured.png class="rounded img-fluid" alt=featured.png></div></div></section><div class="section section-sm bg-white pt-4 pt-lg-4 text-black"><article class=container><div class="row justify-content-center"><div class="col-12 col-lg-9"><p><style>.green{color:green;font-family:fira code,monospace;font-size:87.5%}.blue{color:blue;font-family:fira code,monospace;font-size:87.5%}.orange{color:tomato;font-family:fira code,monospace;font-size:87.5%}.red{color:#df2b04;font-family:fira code,monospace;font-size:87.5%}.hl-comment{color:#df2b04;font-family:fira code,monospace;font-size:87.5%}.hl-keyword{color:#a90d91;font-family:fira code,monospace;font-size:87.5%}.hl-literal{color:#1c01ce;font-family:fira code,monospace;font-size:87.5%}.hl-preproc{color:#633820;font-family:fira code,monospace;font-size:87.5%}.hl-strings{color:#c41a16;font-family:fira code,monospace;font-size:87.5%}.yellow{color:#cc7000;font-family:fira code,monospace;font-size:87.5%}#</style><h2 id=introduction>Introduction</h2><p>In the <a href=/post/20-09-r2con-obfuscated-whitebox-part1/>first part</a> of this write-up, we described the
anti-frida, anti-debug and anti-root techniques used in the application and how to remove most of them.</p><p>This second part digs into the JNI function <code>gXftm3iswpkVgBNDUp</code> and the underlying whitebox implementation.</p><h2 id=library-shimming>Library Shimming</h2><p>The inputs of the function <code>gXftm3iswpkVgBNDUp</code> are provided by the GUI widgets and the function
is triggered when we press the <em>Generate R2Coin</em> button.
Nevertheless, the behavior of <code>gXftm3iswpkVgBNDUp</code> does not rely on UI features nor
the application&rsquo;s context<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>To take a closer look at the logic of <code>gXftm3iswpkVgBNDUp</code>, it would be pretty useful to be able to feed
the function&rsquo;s inputs with our <strong>own standalone binary</strong>. Basically, we would like to achieve this kind
of interface:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>(<span style=color:#b00040>int</span> argc, <span style=color:#b00040>char</span><span style=color:#666>**</span> argv) {
</span></span><span style=display:flex><span>  <span style=color:#b00040>void</span><span style=color:#666>*</span> dlopen(<span style=color:#ba2121>&#34;libnative-lib.so&#34;</span>, RTLD_NOW);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  jbyteArray out <span style=color:#666>=</span> gXftm3iswpkVgBNDUp(env, ...);
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This technique is not new and has been already described in a blog post by <a href=https://twitter.com/caleb_fenton>Caleb Fenton</a><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. The idea is to get
the <code>JNIEnv* env</code> variable with <code>JNI_CreateJavaVM</code> which is exported by the Android runtime: <code>libart.so</code>.</p><p>Once we have this variable, we can call the <code>gXftm3iswpkVgBNDUp</code> function as well as manipulating the JNI buffers:</p><ul><li><code>env->NewByteArray()</code></li><li><code>env->GetArrayLength()</code></li><li>&mldr;</li></ul><p><img src=shim_mechanism.png alt="Shimming of whitebox library"></p><p>Long story short, we can instantiate the Android runtime with the following piece of code:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>(<span style=color:#b00040>int</span> argc, <span style=color:#b00040>char</span><span style=color:#666>**</span> argv) {
</span></span><span style=display:flex><span>  JavaVMOption opt[<span style=color:#666>2</span>];
</span></span><span style=display:flex><span>  opt[<span style=color:#666>0</span>].optionString <span style=color:#666>=</span> <span style=color:#ba2121>&#34;-Djava.class.path=/data/local/tmp/re.pwnme.1.0.apk&#34;</span>;
</span></span><span style=display:flex><span>  opt[<span style=color:#666>1</span>].optionString <span style=color:#666>=</span> <span style=color:#ba2121>&#34;-Djava.library.path=/data/local/tmp&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  JavaVMInitArgs args;
</span></span><span style=display:flex><span>  args.version            <span style=color:#666>=</span> JNI_VERSION_1_6;
</span></span><span style=display:flex><span>  args.options            <span style=color:#666>=</span> opt;
</span></span><span style=display:flex><span>  args.nOptions           <span style=color:#666>=</span> <span style=color:#666>2</span>;
</span></span><span style=display:flex><span>  args.ignoreUnrecognized <span style=color:#666>=</span> JNI_FALSE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#b00040>void</span><span style=color:#666>*</span> handler <span style=color:#666>=</span> dlopen(<span style=color:#ba2121>&#34;/system/lib64/libart.so&#34;</span>, RTLD_NOW);
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>auto</span> JNI_CreateJavaVM_f <span style=color:#666>=</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span><span style=color:green;font-weight:700>decltype</span>(JNI_CreateJavaVM)<span style=color:#666>*&gt;</span>(dlsym(handler, <span style=color:#ba2121>&#34;JNI_CreateJavaVM&#34;</span>));
</span></span><span style=display:flex><span>  JNI_CreateJavaVM_f(<span style=color:#666>&amp;</span>jvm, <span style=color:#666>&amp;</span>env, <span style=color:#666>&amp;</span>args);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, we can resolve the <code>gXftm3iswpkVgBNDUp</code> function with the base address of <code>libnative-lib.so</code>
and its offset <code>0x9B41C</code>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#b00040>void</span><span style=color:#666>*</span> hdl <span style=color:#666>=</span> dlopen(<span style=color:#ba2121>&#34;libnative-lib.so&#34;</span>, RTLD_NOW);
</span></span><span style=display:flex><span>uintptr_t base_address <span style=color:#666>=</span> get_base_address(<span style=color:#ba2121>&#34;libnative-lib.so&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>using</span> gXftm3iswpkVgBNDUp_t <span style=color:#666>=</span> jbyteArray(<span style=color:#666>*</span>)(JNIEnv<span style=color:#666>*</span>, jobject, jbyteArray, jbyte);
</span></span><span style=display:flex><span>gXftm3iswpkVgBNDUp <span style=color:#666>=</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>gXftm3iswpkVgBNDUp_t<span style=color:#666>&gt;</span>(base_address <span style=color:#666>+</span> <span style=color:#666>0x9B41C</span>);
</span></span></code></pre></div><p>Finally, we can run the function with our own inputs:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#666>::</span>string pin_amount <span style=color:#666>=</span> <span style=color:#ba2121>&#34;0000123400004567&#34;</span>;
</span></span><span style=display:flex><span>jbyteArray array <span style=color:#666>=</span> convert_to_jbyteArray(pin_amount, ptr);
</span></span><span style=display:flex><span>jbyteArray jencrypted_buffer <span style=color:#666>=</span> gXftm3iswpkVgBNDUp(env, <span style=color:green;font-weight:700>nullptr</span>, array, <span style=color:#666>0xF0</span>);
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>const</span> std<span style=color:#666>::</span>vector<span style=color:#666>&lt;</span><span style=color:#b00040>uint8_t</span><span style=color:#666>&gt;</span> encrypted_buffer <span style=color:#666>=</span> from_jbytes(jencrypted_buffer);
</span></span><span style=display:flex><span>std<span style=color:#666>::</span>string hex_str <span style=color:#666>=</span> to_hex(encrypted_buffer);
</span></span><span style=display:flex><span>LOG_INFO(<span style=color:#ba2121>&#34;{} --&gt; {}&#34;</span>, pin_amount, ref_str);
</span></span></code></pre></div><div class="alert alert-info" role=alert style=border:none!important;background-color:#fafcff>The whole implementation is available <a href=https://github.com/romainthomas/r2pay/blob/master/shim-whitebox>here <i class="fab fa-github"></i></a>.</div><h2 id=function-tracing>Function Tracing</h2><p>Now that we are able to run the <code>gXftm3iswpkVgBNDUp</code> function without the GUI layer, we can easily
create an interface with <a href=https://qbdi.quarkslab.com>QBDI</a>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>VM vm;
</span></span><span style=display:flex><span>vm.addInstrumentedModule(<span style=color:#ba2121>&#34;libnative-lib.so&#34;</span>);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>jbyteArray array <span style=color:#666>=</span> to_jarray(pin_amount, ptr);
</span></span><span style=display:flex><span>jbyteArray qbdi_encrypted_buffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vm.call(
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>/* ret    */</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>uintptr_t<span style=color:#666>*&gt;</span>(<span style=color:#666>&amp;</span>qbdi_encrypted_buffer),
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>/* target */</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>uintptr_t<span style=color:#666>&gt;</span>(gXftm3iswpkVgBNDUp),
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>/* params */</span> {
</span></span><span style=display:flex><span>      <span style=color:#408080;font-style:italic>/* p_0: JNIEnv* */</span>      <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>rword<span style=color:#666>&gt;</span>(env),
</span></span><span style=display:flex><span>      <span style=color:#408080;font-style:italic>/* p_1: jobject thiz */</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>rword<span style=color:#666>&gt;</span>(<span style=color:green;font-weight:700>nullptr</span>),
</span></span><span style=display:flex><span>      <span style=color:#408080;font-style:italic>/* p_2: inbuffer */</span>     <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>rword<span style=color:#666>&gt;</span>(array),
</span></span><span style=display:flex><span>                              <span style=color:#666>0xF0</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>The execution in QBDI <strong>without user&rsquo;s callbacks</strong> takes about <strong>3min 30s</strong> which is quite huge compared to
the <strong>real execution</strong> that takes about <strong>853ms</strong>:</p><p><img src=benchmark.svg alt="Performances with different configurations"></p><p>This overhead is mostly due to the function <code>0x1038f0</code> that is executed ~20 000 times. After a quick
analysis, it turns out that this function is not relevant to instrument to break the whitebox.
We can force its <em>real</em> execution
(i.e. outside QBDI) <strong>by removing the function&rsquo;s address from the instrumented range</strong><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:green;font-weight:700>static</span> <span style=color:green;font-weight:700>constexpr</span> uintptr_t HEAVY_FUNCTION <span style=color:#666>=</span> <span style=color:#666>0x1038f0</span>;
</span></span><span style=display:flex><span>vm.removeInstrumentedRange(
</span></span><span style=display:flex><span>  base_address <span style=color:#666>+</span> HEAVY_FUNCTION,
</span></span><span style=display:flex><span>  base_address <span style=color:#666>+</span> HEAVY_FUNCTION <span style=color:#666>+</span> <span style=color:#666>1</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>This small adjustment <strong>drops the execution to 3'30sec</strong>.</p><hr><p>Some cryptographic algorithms can be fingerprinted either with predefined constants or with their memory accesses.
According to the Quarkslab&rsquo;s blog post: <a href=https://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html>Differential Fault Analysis on White-box AES Implementations</a>,
the whitebox lookup tables are likely to be stored in the <code>.data, .rodata, ...</code> sections.</p><p>By looking at the sizes of these sections, only the <code>.data</code> section seems to have an appropriate size.
We can generate a memory trace on this section to see if we can outline some patterns.
It can be made with the following piece of code:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vm.recordMemoryAccess(MEMORY_READ_WRITE);
</span></span><span style=display:flex><span>vm.addMemRangeCB(
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>/* .data start address           */</span> base_address <span style=color:#666>+</span> <span style=color:#666>0x127000</span>,
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>/* .data end address             */</span> base_address <span style=color:#666>+</span> <span style=color:#666>0x127000</span> <span style=color:#666>+</span> <span style=color:#666>0x8e000</span>,
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>/* Record both: reads and writes */</span> MEMORY_READ_WRITE,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>/* Memory callback */</span>
</span></span><span style=display:flex><span>    [] (VM<span style=color:#666>*</span> vm, GPRState<span style=color:#666>*</span>, FPRState<span style=color:#666>*</span>, <span style=color:#b00040>void</span><span style=color:#666>*</span> data) {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>auto</span> ctx <span style=color:#666>=</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>qbdi_ctx<span style=color:#666>*&gt;</span>(data);
</span></span><span style=display:flex><span>      <span style=color:#408080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>       * &#39;for&#39; loop since on AArch64 we can have multiple reads / writes
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>       * at once. (e.g. stp x0, x1, [sp, #128])
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>       */</span>
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>for</span> (<span style=color:green;font-weight:700>const</span> MemoryAccess<span style=color:#666>&amp;</span> <span style=color:#a0a000>mem_access</span> : vm<span style=color:#666>-&gt;</span>getInstMemoryAccess()) {
</span></span><span style=display:flex><span>        ctx<span style=color:#666>-&gt;</span>trace<span style=color:#666>-&gt;</span>push_back({
</span></span><span style=display:flex><span>            mem_access.instAddress   <span style=color:#666>-</span> base_address,
</span></span><span style=display:flex><span>            mem_access.accessAddress <span style=color:#666>-</span> base_address,
</span></span><span style=display:flex><span>            mem_access.size,
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>return</span> VMAction<span style=color:#666>::</span>CONTINUE;
</span></span><span style=display:flex><span>    }, <span style=color:#666>&amp;</span>ctx);
</span></span></code></pre></div><div class="alert alert-info" role=alert style=border:none!important;background-color:#fafcff>Generating the memory trace takes about 11sec which is acceptable.</div><p>It leads to the following graph in which we can notice a characteristic pattern at the end of the trace:</p><p><img src=memory_trace.png alt="Memory trace generated with QBDI"></p><h2 id=fault-injection>Fault Injection</h2><p>The pattern at the end of the trace is quite characteristic of AES-128 where we can identify 10 rounds.
<img src=rounds.png alt="AES rounds"></p><p>We now have all the necessary information to make a <em>fault injection attack</em>:</p><ol><li>We can identify the 9th round</li><li>We can <strong>accurately</strong> fault the <code>.data</code> section thanks to the memory trace</li></ol><p><img src=injection.png alt="Fault injection in the 9th round"></p><div class="alert alert-info" role=alert style=border:none!important;background-color:#fafcff>The memory trace is available in the <a href=https://github.com/romainthomas/r2pay/blob/master/assets/mem_trace.json><i class="fab fa-github"></i> mem_trace.json</a> file of the repository.</div><p>To efficiently make
the injection, we can first reduce the memory addresses to only keep those that are used in the last 2 rounds:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>trace_file <span style=color:#666>=</span> CWD <span style=color:#666>/</span> <span style=color:#ba2121>&#34;..&#34;</span> <span style=color:#666>/</span> <span style=color:#ba2121>&#34;assets&#34;</span> <span style=color:#666>/</span> <span style=color:#ba2121>&#34;mem_trace.json&#34;</span>
</span></span><span style=display:flex><span>trace <span style=color:#666>=</span> json<span style=color:#666>.</span>loads(trace_file<span style=color:#666>.</span>read_bytes())[<span style=color:#666>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic># Keep the entries that are involved in the last 2-rounds (empirical number)</span>
</span></span><span style=display:flex><span>nice_trace <span style=color:#666>=</span> trace[<span style=color:#666>-</span><span style=color:#666>1000</span>:]
</span></span></code></pre></div><p>Then, we can use our shim mechanism to inject the faults in the <code>.data</code> section with the addresses previously selected.
Moreover, we can reduce the set of <code>.data</code> addresses with the faults that introduce exactly <strong>4 differences</strong> in the ciphertext:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#408080;font-style:italic>// Make sure the .data section is writable
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>mprotect(
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span><span style=color:#b00040>void</span><span style=color:#666>*&gt;</span>(base_address <span style=color:#666>+</span> <span style=color:#408080;font-style:italic>/* .data */</span> <span style=color:#666>0x127000</span>),
</span></span><span style=display:flex><span>  <span style=color:#666>0x8e000</span>,
</span></span><span style=display:flex><span>  PROT_READ <span style=color:#666>|</span> PROT_WRITE
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> (uintptr_t <span style=color:#a0a000>fault_addr</span> : selected_addresses) {
</span></span><span style=display:flex><span>  <span style=color:#b00040>uint8_t</span><span style=color:#666>&amp;</span> target_byte <span style=color:#666>=</span> <span style=color:#666>*</span><span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span><span style=color:#b00040>uint8_t</span><span style=color:#666>*&gt;</span>(base_address <span style=color:#666>+</span> fault_addr);
</span></span><span style=display:flex><span>  <span style=color:#b00040>uint8_t</span> backup <span style=color:#666>=</span> target_byte;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#408080;font-style:italic>// Fault 1 byte:
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>  target_byte <span style=color:#666>^=</span> <span style=color:#666>0x33</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#408080;font-style:italic>// Run the whitebox with the faulty byte
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>  <span style=color:green;font-weight:700>const</span> std<span style=color:#666>::</span>vector<span style=color:#666>&lt;</span><span style=color:#b00040>uint8_t</span><span style=color:#666>&gt;</span> encrypted <span style=color:#666>=</span> encrypt(msg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#408080;font-style:italic>// Restore the original byte
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>  target_byte <span style=color:#666>=</span> backup;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#408080;font-style:italic>// Compute the number of errors
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>  <span style=color:#408080;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>}
</span></span></code></pre></div><p>Finally, with the subset of the addresses that affect exactly 4 bytes, we can generate several faults for a given
address:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:green;font-weight:700>for</span> (uintptr_t <span style=color:#a0a000>nice_fault_addr</span> : four_bytes_fault_addresses) {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>for</span> (size_t i <span style=color:#666>=</span> <span style=color:#666>0</span>; i <span style=color:#666>&lt;</span> <span style=color:#666>255</span>; <span style=color:#666>++</span>i) {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> std<span style=color:#666>::</span>vector<span style=color:#666>&lt;</span><span style=color:#b00040>uint8_t</span><span style=color:#666>&gt;&amp;</span> output <span style=color:#666>=</span> inject_fault(addr, PIN_AMOUNT, i);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>const</span> size_t nb_errors <span style=color:#666>=</span> get_error(genuine_value, output);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (nb_errors <span style=color:#666>==</span> <span style=color:#666>4</span> and unique.insert(output).second) {
</span></span><span style=display:flex><span>      <span style=color:#408080;font-style:italic>// Record the entry ...
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The aforementioned code gives an idea about how to generate the faults. One can find the whole implementation in
this file: <a href=https://github.com/romainthomas/r2pay/blob/master/shim-whitebox/src/main.cpp#L343-L365>shim-whitebox/src/main.cpp</a> that produces
this set of files <a href=https://github.com/romainthomas/r2pay/blob/master/assets/wb-traces>assets/wb-traces</a>.</p><h2 id=key-extraction>Key Extraction</h2><p>Thanks to the <a href=https://github.com/SideChannelMarvels><i class="fab fa-github"></i> Side-Channel Marvels</a> project,
we can use <a href=https://github.com/SideChannelMarvels/JeanGrey>JeanGrey</a> &mdash; developed by Philippe Teuwen &mdash; to recover the whitebox&rsquo;s key from the faulty traces:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>pathlib</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>phoenixAES</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CWD <span style=color:#666>=</span> pathlib<span style=color:#666>.</span>Path(__file__)<span style=color:#666>.</span>parent
</span></span><span style=display:flex><span>trace_dir <span style=color:#666>=</span> CWD <span style=color:#666>/</span> <span style=color:#ba2121>&#34;..&#34;</span> <span style=color:#666>/</span> <span style=color:#ba2121>&#34;assets&#34;</span> <span style=color:#666>/</span> <span style=color:#ba2121>&#34;wb-traces&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> f <span style=color:#a2f;font-weight:700>in</span> trace_dir<span style=color:#666>.</span>iterdir():
</span></span><span style=display:flex><span>    x <span style=color:#666>=</span> phoenixAES<span style=color:#666>.</span>crack_file(f)
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> x <span style=color:#a2f;font-weight:700>is</span> <span style=color:#a2f;font-weight:700>not</span> <span style=color:green;font-weight:700>None</span>:
</span></span><span style=display:flex><span>        <span style=color:green>print</span>(x, f<span style=color:#666>.</span>name)
</span></span></code></pre></div><p>It provides the following results which enable to retrieve the key:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> python wb_key_recovery.py
</span></span><span style=display:flex><span><span style=color:#888>..8D....7F............9A....79.. injection-1a930d.trace
</span></span></span><span style=display:flex><span><span style=color:#888>..8D....7F............9A....79.. injection-1a95bd.trace
</span></span></span><span style=display:flex><span><span style=color:#888>....19....62....B0............8F injection-1a91b2.trace
</span></span></span><span style=display:flex><span><span style=color:#888>....19....62....B0............8F injection-1a8fdf.trace
</span></span></span><span style=display:flex><span><span style=color:#888>76............1E....D3....E1.... injection-1a8549.trace
</span></span></span><span style=display:flex><span><span style=color:#888>......E1....A0....CD....28...... injection-1a8978.trace
</span></span></span><span style=display:flex><span><span style=color:#888>....19....62....B0............8F injection-1a90ce.trace
</span></span></span><span style=display:flex><span><span style=color:#888>....19....62....B0............8F injection-1a8efd.trace
</span></span></span><span style=display:flex><span><span style=color:#888>r 2 p 4 y 1 s N 0 w S e c u r 3
</span></span></span></code></pre></div><p>Finally, we can verify that <strong>r2p4y1sN0wSecur3</strong> is the right key by trying to decrypt <code>9497cdf1df2600e7f63778d0ae91dcbb</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:green;font-weight:700>from</span> <span style=color:#00f;font-weight:700>Crypto.Cipher</span> <span style=color:green;font-weight:700>import</span> AES
</span></span><span style=display:flex><span>WB_KEY <span style=color:#666>=</span> <span style=color:#ba2121>b</span><span style=color:#ba2121>&#34;r2p4y1sN0wSecur3&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cipher <span style=color:#666>=</span> AES<span style=color:#666>.</span>new(WB_KEY, AES<span style=color:#666>.</span>MODE_ECB)
</span></span><span style=display:flex><span>output <span style=color:#666>=</span> cipher<span style=color:#666>.</span>decrypt(<span style=color:green>bytes</span><span style=color:#666>.</span>fromhex(<span style=color:#ba2121>&#34;9497cdf1df2600e7f63778d0ae91dcbb&#34;</span>))
</span></span><span style=display:flex><span><span style=color:green>print</span>(output<span style=color:#666>.</span>decode())
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> python ./aes_test.py
</span></span><span style=display:flex><span><span style=color:#888>0000123400004567
</span></span></span></code></pre></div><h2 id=side-note-about-the-data-section>Side note about the <code>.data</code> section</h2><p>Most of the obfuscators encode strings so that we don&rsquo;t have any clue about functions&rsquo; logic. The obfuscator
used in the challenge follows this rule and running the <code>strings</code> utility on the library does not reveal any interesting information.</p><p>Nevertheless, we can find a lot of <code>.datadiv_decode&lt;random hex></code> in the ELF constructors of the library.
As explained in the previous part, they are generated by the obfuscator and aimed to decode the strings.</p><p>Since these functions are in the <strong>ELF constructors</strong>, this means that they are executed as soon as the library is loaded.
In particular, when calling <code>dlopen(...)</code> these constructors are executed. It can be confirmed by
dumping the <code>.data</code> section right after <code>dlopen()</code>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>dlopen(<span style=color:#ba2121>&#34;libnative-lib.so&#34;</span>, RTLD_NOW);
</span></span><span style=display:flex><span>std<span style=color:#666>::</span>ofstream ofs{fmt<span style=color:#666>::</span>format(<span style=color:#ba2121>&#34;/data/local/tmp/{}&#34;</span>, output)};
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>auto</span> start <span style=color:#666>=</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span><span style=color:green;font-weight:700>const</span> <span style=color:#b00040>char</span><span style=color:#666>*&gt;</span>(base_address <span style=color:#666>+</span> <span style=color:#666>0x127000</span>);
</span></span><span style=display:flex><span>ofs.write(start, <span style=color:#408080;font-style:italic>/* sizeof(.data) */</span> <span style=color:#666>0x8d49f</span>);
</span></span></code></pre></div><p>Then, we can compare the bytes distribution with <a href=https://binvis.io/>binvis.io</a>:</p><p><img src=data_strings.png alt="Bytes distribution in the .data section"></p><p>At the end of the in-memory <code>.data</code> section, we can found interesting strings used to detect Frida and the
device&rsquo;s root state.</p><h2 id=conclusion>Conclusion</h2><p>Thanks again to <u>Eduardo Novella</u> (<a href=https://twitter.com/enovella_>@enovella_</a>)
and <u>Gautam Arvind</u> (<a href=https://twitter.com/darvincisec>@darvincisec</a>) for this second part of the challenge :)</p><p>Also thanks to <u><a href=https://www.quarkslab.com>Quarkslab</a></u> that allowed this publication.
One can find related blog posts about whitebox attacks on the Quarkslab&rsquo;s blog:</p><ul><li><p><a href=https://blog.quarkslab.com/introduction-to-whiteboxes-and-collision-based-attacks-with-qbdi.html>Introduction to Whiteboxes and Collision-Based Attacks With QBDI</a> by Paul Hernault (<a href=https://twitter.com/0xAcid>@0xAcid</a>)</p></li><li><p><a href=https://blog.quarkslab.com/when-sidechannelmarvels-meet-lief.html>When SideChannelMarvels meet LIEF</a></p></li><li><p><a href=https://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html>Differential Fault Analysis on White-box AES
Implementations</a> by Philippe Teuwen (<a href=https://twitter.com/doegox>@doegox</a>).
<em>I used this blog post as a reference to resolve this part of the challenge.</em></p></li></ul><h3 id=references>References</h3><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://developer.android.com/reference/android/content/Context>https://developer.android.com/reference/android/content/Context</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/>https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>QBDI will execute the function using the <a href=https://qbdi.readthedocs.io/en/stable/api_cpp.html#execution-filtering>ExecBroker</a> mechanism.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>It is the output of the function when entering <code>1234</code> in the PIN field and <code>4567</code> in the amount field.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></div></div></div></div></main><script src=/vendor/bootstrap/dist/js/bootstrap.min.js></script>
<script src=/vendor/headroom.js/dist/headroom.min.js></script>
<script src=/vendor/onscreen/dist/on-screen.umd.min.js></script>
<script src=/vendor/jarallax/dist/jarallax.min.js></script>
<script src=/vendor/smooth-scroll/dist/smooth-scroll.polyfills.min.js></script>
<script src=/js/theme.bundle.js></script>
<script src=/vendor/@glidejs/glide/dist/glide.min.js></script>
<script src=/js/anime.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script>
<script>function katex_load(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})}</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=katex_load()></script></body></html>