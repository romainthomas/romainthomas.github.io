<!doctype html><html lang=en-us prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=manifest href=manifest.webmanifest><link rel=icon type=image/png href=/img/favicon/favicon_hu2a60c33e6cc729e53465c846fe50d8b2_13867_32x32_fill_box_center_3.png><link rel=apple-touch-icon type=image/png href=/img/favicon/favicon_hu2a60c33e6cc729e53465c846fe50d8b2_13867_192x192_fill_box_center_3.png><meta name=description content="This first blog post describes the protections in the challenge r2-pay."><meta name=keywords content="android,reverse engineering,write-up,obfuscation,whitebox"><meta property="og:type" content="article"><meta property="og:description" content="This first blog post describes the protections in the challenge r2-pay."><meta property="og:title" content="r2-pay: anti-debug, anti-root & anti-frida (part 1) | Romain Thomas"><meta property="og:site_name" content="Romain Thomas"><meta property="og:image" content="https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part1/featured.png"><meta property="og:url" content="https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part1/"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2020-09-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-14T15:55:15+02:00"><meta property="article:tag" content="android"><meta property="article:tag" content="reverse engineering"><meta property="article:tag" content="write-up"><meta property="article:tag" content="obfuscation"><meta property="article:tag" content="whitebox"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@rh0main"><meta name=twitter:creator content="@rh0main"><meta name=twitter:title content="r2-pay: anti-debug, anti-root & anti-frida (part 1) | Romain Thomas"><meta name=twitter:description content="This first blog post describes the protections in the challenge r2-pay."><meta name=twitter:domain content="https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part1/"><meta property="twitter:image" content="https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part1/featured.png"><title>Romain Thomas</title><link rel=canonical href=https://www.romainthomas.fr/post/20-09-r2con-obfuscated-whitebox-part1/><link rel=stylesheet href=/css/fa-all.min.css><link rel=stylesheet href=/vendor/@glidejs/glide/dist/css/glide.core.min.css><link rel=stylesheet href=/vendor/@glidejs/glide/dist/css/glide.theme.min.css><link rel=stylesheet href=/css/theme.bundle.css><style>.hide{opacity:0}</style><noscript><style>.hide{opacity:1;!important}</style></noscript><style>.hero_background{position:relative;overflow:hidden}.hero_background:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:90%;z-index:1;opacity:.2;background-image:url(/img/bg_home.svg);background-repeat:repeat;background-position:50%;background-size:100%;transform:rotate(180deg)}.project_bg{position:relative;overflow:hidden}.project_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;opacity:.1;background-image:url(/img/bg_project.svg);background-repeat:repeat;background-position:50%;background-size:100%;transform:rotate(180deg)}.experience_bg{position:relative;overflow:hidden}.experience_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;opacity:.1;background-image:url(/img/bg_experience.svg);background-position:0 0;background-size:100%}.post_bg{position:relative;overflow:hidden}.post_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:80%;z-index:1;opacity:.6;background-image:url(/img/bg_post.svg);background-position:0 0;background-size:100%}.contact_bg{position:relative;overflow:hidden}.contact_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:80%;z-index:1;opacity:.2;background-image:url(/img/bg_contact.svg);background-position:0 0;background-size:100%}.footnotes p{margin-bottom:0}.highlight{padding-left:20px;border-left:1px solid rgba(0,0,0,.1);border-radius:2px 2px}</style></head><body><header class=header-global><nav id=navbar-main aria-label="Primary navigation" class="navbar navbar-main navbar-expand-lg navbar-theme-primary headroom navbar-dark"><div class="container position-relative"><a class="navbar-brand me-lg-5" href=https://www.romainthomas.fr/><span class="navbar-brand-dark ft-ananda">R. T</span>
<span class="navbar-brand-light ft-ananda">R. T</span></a><div class="navbar-collapse collapse me-auto" id=navbar_global><div class=navbar-collapse-header><div class=row><div class="col-6 collapse-close"><a href=#navbar_global class="fas fa-times" data-bs-toggle=collapse data-bs-target=#navbar_global aria-controls=navbar_global aria-expanded=false title=close aria-label="Toggle navigation"></a></div></div></div><ul class="navbar-nav navbar-nav-hover align-items-lg-center"><li class=nav-item><a href=https://www.romainthomas.fr/#about class="nav-link fw-bold"><span class="fa-regular fa-person-swimming"></span> About</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#posts class="nav-link fw-bold"><span class="fa-regular fa-blog"></span> Posts</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#projects class="nav-link fw-bold"><span class="fa-regular fa-terminal"></span> Projects</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#publications class="nav-link fw-bold"><span class="far fa-book-open-cover"></span> Publications</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#work-experience class="nav-link fw-bold"><span class="fa-regular fa-briefcase"></span> Work Experience</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#misc class="nav-link fw-bold"><span class="fa-regular fa-chart-network"></span> Misc</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#contact class="nav-link fw-bold"><span class="fa-regular fa-binary-lock"></span> Contact</a></li></ul></div><div class="d-flex align-items-center"><button class="navbar-toggler ms-2 collapsed" type=button data-bs-toggle=collapse data-bs-target=#navbar_global aria-controls=navbar_global aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button></div></div></nav></header><main><section class="section-header pb-5 pb-sm-7 bg-primary text-white post_bg"><div class=container><div class="row justify-content-center"><div class="col-12 col-lg-10 text-center"><div class=mb-4><a href=/categories/android/><span class="me-2 badge alert-info text-uppercase px-3 btn-outline-primary">Android</span>
</a><a href=/categories/reverse-engineering/><span class="me-2 badge alert-info text-uppercase px-3 btn-outline-primary">Reverse Engineering</span></a></div><h1 class="display-3 mb-4 px-lg-5">r2-pay: anti-debug, anti-root & anti-frida (part 1)</h1><div class=post-meta><span class="fw-bold me-3">Romain Thomas</span>
<span class="post-date me-3">September 20, 2020</span>
<span class=fw-bold>14 min read</span></div></div></div></div><figure class="position-absolute bottom-0 left-0 w-100 d-none d-md-block mb-n2"><svg class="fill-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 3e3 185.4"><path d="M3e3.0v185.4H0V0c496.4 115.6 996.4 173.4 15e2 173.4S2503.6 115.6 3e3.0z"/></svg></figure></section><section class="section section-lg pt-0 pb-0" id=featured><div class="container mt-n8 mt-lg-n10 z-2 pb-0"><div class="row mt-7 mx-10"><img src=/post/20-09-r2con-obfuscated-whitebox-part1/featured.png class="rounded img-fluid" alt=featured.png></div></div></section><div class="section section-sm bg-white pt-4 pt-lg-4 text-black"><article class=container><div class="row justify-content-center"><div class="col-12 col-lg-9"><p><style>.green{color:green;font-family:fira code,monospace;font-size:87.5%}.blue{color:blue;font-family:fira code,monospace;font-size:87.5%}.orange{color:tomato;font-family:fira code,monospace;font-size:87.5%}.red{color:#df2b04;font-family:fira code,monospace;font-size:87.5%}.hl-comment{color:#df2b04;font-family:fira code,monospace;font-size:87.5%}.hl-keyword{color:#a90d91;font-family:fira code,monospace;font-size:87.5%}.hl-literal{color:#1c01ce;font-family:fira code,monospace;font-size:87.5%}.hl-preproc{color:#633820;font-family:fira code,monospace;font-size:87.5%}.hl-strings{color:#c41a16;font-family:fira code,monospace;font-size:87.5%}.yellow{color:#cc7000;font-family:fira code,monospace;font-size:87.5%}#</style><h2 id=introduction>Introduction</h2><p>This series of blog posts explains one way to resolve the r2-pay challenge released during the <a href=https://rada.re/con/2020/>r2con2020</a> conference. This first part is about the
anti-analysis tricks used to hinder reverse-engineering while the second part will be more focused on
breaking the whitebox.</p><p>The resolution took me more than a week-end but it covers nice topics that worth it: <strong>obfuscation & whitebox</strong>.
It was also the opportunity to practice attacks against whiteboxes
and to test <a href=https://github.com/SideChannelMarvels/JeanGrey>SideChannelMarvels/JeanGrey</a> developed by Philippe Teuwen (aka. <a href=https://twitter.com/doegox>@doegox</a>).</p><p>The challenge has been resolved with the AArch64 version on a device running on Android 9 and rooted with Magisk.</p><div class="col-12 col-md-12 mb-4 mb-lg-4 mt-4"><div class="p-4 rounded col-12 alert alert-info" style=border:none!important;background-color:#fafcff><div class="d-flex px-3"><div><div class="icon icon-sm icon-secondary"><span class="fas fa-circle-info" style=color:#084298></span></div></div><div class=ps-4 style=color:#084298><h3 class="h5 m-0 mb-1" style=color:#084298>Note</h3><p>Here are the files used in this write-up:</p><p><i class="fas fa-mobile-alt"></i> <a href=re.pwnme.1.0.apk>re.pwnme.1.0.apk - af019d3016720592aade7bde9890110c</a></p><p><i class="fas fa-shield-alt"></i> <a href=libnative-lib.so>libnative-lib.so (arm64-v8a version)</a></p></div></div></div></div><h2 id=overview>Overview</h2><p>When opening the application on a non-tempered device (or with Magisk hide enabled), we are asked to enter
a PIN and an amount that is used to generate a <em>token</em>.</p><p>To resolve the challenge, we have to find the <em>master key</em> that is used to generate the token.
Few days before the CTF I was told that one of the challenges
would involve an obfuscated whitebox&mldr;</p><p>The main interface of the APK is located in the Java class <code>re.pwnme.MainActivity</code> which forwards the user inputs (PIN & amount)
to a JNI function named <code>gXftm3iswpkVgBNDUp</code>. This function takes the concatenated input $PIN\ ||\ Amount$
and returns the token as a byte array.</p><p>The <strong>static constructor</strong> of the class loads the &ldquo;native-lib&rdquo; library which is available for the architectures:
<code>arm64-v8a</code>, <code>armeabi-v7a</code>, and <code>x86_64</code>. Unsurprisingly, this library is obfuscated and some symbols suggest that it has
been compiled with a fork of O-LLVM <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p><img src=mainactivity_tag.png alt="re.pwnme.MainActivity in r2pay"></p><p>In addition, the library does not export the expected symbol <code>Java_re_pwnme_MainActivity_gXftm3iswpkVgBNDUp</code> but prefers
to use the <code>JNI_OnLoad</code> technique <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. <code>JNI_OnLoad()</code> is also obfuscated along with control-flow-flattening.</p><p>The main task of the challenge is to understand the logic of the <code>gXftm3iswpkVgBNDUp</code> function to figure out how the
<em>token</em> is generated.</p><h2 id=anti-root--anti-frida>Anti-Root & Anti-Frida</h2><p>Along with the <code>libnative-lib.so</code> library, the applications embeds another library <code>libtool-checker.so</code>
whose name sounds quite familiar: it comes from the open-source project <a href=https://github.com/scottyab/rootbeer>rootbeer</a>
which is used to detect if the device is rooted.</p><p>Some of the root-checks are done in the MainActivity class and if the device is rooted the application raises
an exception by dividing a number with 0.</p><p>On this point, we can disable the check by using <a href=https://frida.re/>Frida</a> on the rootbeer&rsquo;s functions involved in the detection:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#408080;font-style:italic>// frida -U -l ./bypass-root.js --no-pause -f re.pwnme
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Java.perform(<span style=color:green;font-weight:700>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>var</span> RootCheck <span style=color:#666>=</span> Java.use(<span style=color:#ba2121>&#39;\u266b.\u1d64&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  RootCheck[<span style=color:#ba2121>&#39;₤&#39;</span>].implementation <span style=color:#666>=</span> <span style=color:green;font-weight:700>function</span> () {
</span></span><span style=display:flex><span>    console.log(<span style=color:#ba2121>&#34;Skip root&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> <span style=color:green;font-weight:700>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  RootCheck[<span style=color:#ba2121>&#39;θ&#39;</span>].overload().implementation <span style=color:#666>=</span> <span style=color:green;font-weight:700>function</span> () {
</span></span><span style=display:flex><span>    console.log(<span style=color:#ba2121>&#34;Skip root&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> <span style=color:green;font-weight:700>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Nevertheless, the application still crashes as soon as it starts and generates the following backtrace:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>F libc    : Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095 in tid 8875 (re.pwnme), pid 8849 (re.pwnme)
</span></span><span style=display:flex><span>F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
</span></span><span style=display:flex><span>F DEBUG   : Build fingerprint: &#39;google/taimen/taimen:9/PQ3A.190801.002/5670241:user/release-keys&#39;
</span></span><span style=display:flex><span>F DEBUG   : Revision: &#39;rev_10&#39;
</span></span><span style=display:flex><span>F DEBUG   : ABI: &#39;arm64&#39;
</span></span><span style=display:flex><span>F DEBUG   : pid: 8849, tid: 8875, name: re.pwnme  &gt;&gt;&gt; com.google.android.gms &lt;&lt;&lt;
</span></span><span style=display:flex><span>F DEBUG   : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095
</span></span><span style=display:flex><span>F DEBUG   :     x0  0000007f041f6610  x1  0000007f2565c800  x2  0000007f25600000  x3  000000000000001d
</span></span><span style=display:flex><span>F DEBUG   :     x4  000000000000005c  x5  0000000000000001  x6  0000000000000001  x7  0000000000000000
</span></span><span style=display:flex><span>F DEBUG   :     x8  0000007f041f6610  x9  0000007f041f6600  x10 00000000fa929095  x11 00000000000035b2
</span></span><span style=display:flex><span>F DEBUG   :     x12 00000000e34d79ac  x13 00000000fffffff7  x14 00000000a139577d  x15 0000000000000001
</span></span><span style=display:flex><span>F DEBUG   :     x16 0000007fa66af220  x17 0000007fa65e3608  x18 0000000000000000  x19 0000007f041f6680
</span></span><span style=display:flex><span>F DEBUG   :     x20 0000000000000000  x21 0000000000000000  x22 0000229100002291  x23 0000000000000000
</span></span><span style=display:flex><span>F DEBUG   :     x24 0000007f041ff570  x25 0000007f04102000  x26 0000007fab1ad5e0  x27 0000007f0421a690
</span></span><span style=display:flex><span>F DEBUG   :     x28 0000007f04209080  x29 0000007f041ff490
</span></span><span style=display:flex><span>F DEBUG   :     sp  0000007f041f65f0  lr  0000007f0423de04  pc  0000007f0423f980
</span></span><span style=display:flex><span>F DEBUG   :
</span></span><span style=display:flex><span>F DEBUG   : backtrace:
</span></span><span style=display:flex><span>F DEBUG   :     #00 pc 000000000003f980  /data/app/re.pwnme-7O3ynhSmMsg2_E5_uqbQxQ==/lib/arm64/libnative-lib.so
</span></span></code></pre></div><p>The backtrace suggests that other checks are performed in the native library. By looking at the ELF&rsquo;s constructors,
we can notice two functions that differ from those generated by the obfuscator:</p><p><img src=elf_ctor.png alt="ELF constructors involved in the detection"></p><div class="alert alert-info" role=alert style=border:none!important;background-color:#fafcff><code>.datadiv_decode13003153710004289592</code> functions are in the ELF constructors since they decode global strings that need to be
available as soon as the library is loaded.</div><p>By tracing these functions with <a href=https://qbdi.quarkslab.com/>QBDI</a>, we quickly understand that <span class=green>sub_9080</span> iterates over
<code>/proc/self/maps</code> with the syscalls <span class=blue>openat</span>/<span class=hl-keyword>read</span>
that are located at the addresses <span class=blue>0x009870</span> and <span class=hl-keyword>0x00b448</span>.</p><p>Then, we observe the following sequence:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x011fb0: syscall: openat(0xffffffffffffff9c, &#39;/system/lib64/libc.so&#39;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0x012884: syscall: read(51, 0x7ffc006c58, 64): &#39;ELF@)@8@&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0x013170: syscall: lseek(51, 0x112918, 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64)
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64)
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;/ &#39;
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;B88&#39;
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;J&gt;&#39;
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;RoP)&#39;
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;\o((&#39;
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;io&#39;
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;xo0&#39;
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64)
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;Bxx`-&#39;
</span></span><span style=display:flex><span>0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &#39;PP`&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0x0151f4: malloc(0x18): 0x7f0c21f4c0
</span></span><span style=display:flex><span>0x0156e4: syscall: lseek(51, 0x1a650, 0)
</span></span><span style=display:flex><span>0x015a68: malloc(0x1e60): 0x7f0acb2000
</span></span><span style=display:flex><span>0x015fa0: syscall: read(51, 0x7f0acb2000, 0x1e60): &#39;{n@b r@ v@ z@ ~@ @ @&#34; @B @b @ @ @ @ @ @&#34; @B @b @ @ @ @ @ @&#34; @B @b @ @ @ @ @ @&#34; @B @b @ @ @ @ A A&#34; AB Ab A A A A &#34;A &amp;A&#34; *AB .Ab 2A 6A :A &gt;A BA FA&#34; JAB NAb RA VA ZA ^A bA fA&#34; jAB nAb rA vA zA ~A A A&#34; AB Ab A A A A A A&#34; AB Ab A A A A A A&#34; AB Ab A A A A A A&#34; AB Ab A A A A B B&#34; BB Bb B B B B &#34;B &amp;B&#34; *BB .Bb 2B 6B :B &gt;B BB FB&#34; JBB NBb RB VB ZB ^B bB fB&#34; jBB nBb rB vB zB ~B B B&#34; BB Bb B B B B B B&#34; B ...&#39;
</span></span><span style=display:flex><span>0x016cfc: free(0x7f0acb2000) -&gt; {n@b    r@ v@ z@ ~@ @ @&#34; @B @b @ @ @ @ @ @&#34; @B @b @ @ @ @ @ @&#34; @B @b @ @ @ @ @ @&#34; @B @b @ @ @ @ A A&#34; AB Ab A A A A &#34;A &amp;A&#34; *AB .Ab 2A 6A :A &gt;A BA FA&#34; JAB NAb RA VA ZA ^A bA fA&#34; jAB nAb rA vA zA ~A A A&#34; AB Ab A A A A A A&#34; AB Ab A A A A A A&#34; AB Ab A A A A A A&#34; AB Ab A A A A B B&#34; BB Bb B B B B &#34;B &amp;B&#34; *BB .Bb 2B 6B :B &gt;B BB FB&#34; JBB NBb RB VB ZB ^B bB fB&#34; jBB nBb rB vB zB ~B B B&#34; BB Bb B B B B B B&#34; B ...
</span></span><span style=display:flex><span>0x017118: syscall: close(51)
</span></span></code></pre></div><p>From this output, we can infer the following logic:</p><ol><li><code>0x011fb0</code>: the function opens the libc</li><li><code>0x012884</code>: it reads the ELF header</li><li><code>0x013170</code>: it jumps to the ELF sections table</li><li><code>0x0145f8</code>: it looks for the <code>.plt</code> section</li><li><code>0x015a68</code>, <code>0x015fa0</code>: it reads the content of the <code>.plt</code> section</li></ol><p>These operations suggest that the function checks if the <code>.plt</code> of <code>/system/lib64/libc.so</code> is not tampered with.
In particular, if we use Frida on a libc&rsquo;s function this check won&rsquo;t pass.</p><p>After this check, the function <span class=green>sub_9080</span> spawns a thread:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x0195dc: pthread_create(0xf1079f10, 0x0, 0x1a690, 0x0)
</span></span></code></pre></div><p>The libc integrity check makes more sense as it is probably used to protect the library against a hook of <code>pthread_create()</code>.</p><p>The thread&rsquo;s routine <span class=red>sub_1a690</span> starts by making two calls to the mathematical function <code>tan()</code>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x01b774: tan(0.): 0.
</span></span><span style=display:flex><span>0x01b79c: tan(-7832.0): -0.00951489
</span></span><span style=display:flex><span>0x01cc74: memcpy(0x7ffc006598, libnative-lib.so!0x1267f0, 80) -&gt; !7Nl
</span></span><span style=display:flex><span>0x01ceb8: rand()
</span></span><span style=display:flex><span>0x01f774: tan(0.): 0.
</span></span><span style=display:flex><span>0x01f79c: tan(-7832.0): -0.00951489
</span></span></code></pre></div><p>My understanding of these calls is that the application tries to protect against tools that would not support
floating-point instructions such as <code>FCMP</code> or <code>FMOV</code>. In addition, I think that if we mock the behavior of
<code>tan()</code> with a constant value it would trigger a crash.</p><p><img src=tan_instruction.png alt=tan></p><p>Then it follows a check of <code>TracerPid</code> value in <code>/proc/self/status</code>. This value is set when
the process is ptrace-debugged (which is the case with gdb).
Dynamically, we observe syscalls that open <code>/proc/self/status</code> and read the content
byte-per-byte:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x020ee0: syscall: openat(0xffffffffffffff9c, &#39;/proc/self/status&#39;): 51
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;N&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;a&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;m&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;e&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;:&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1)
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;r&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;e&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;.&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;p&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;w&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;n&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;m&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;e&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1)
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;S&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;t&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;a&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;t&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;e&#39;
</span></span><span style=display:flex><span>0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &#39;:&#39;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=anti-frida-1>Anti-Frida #1</h2><p>Still in the thread&rsquo;s routine <span class=red>sub_1a690</span>, the function checks if Frida is running by looking
at all the values of <code>/proc/self/task/&lt;tid>/status</code> and by checking if one of the names is <span class=red><b><u>gmain</u></b></span>.
It turns out that it&rsquo;s the case when Frida is used in the application :-)</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x0368e4: snprintf(&#39;/proc/self/task/9719/status&#39;, &#39;/proc/self/task/%s/status&#39;): &#39;/proc/self/task/9719/status&#39;
</span></span><span style=display:flex><span>0x036a1c: syscall: openat(0xffffffffffffff9c, &#39;/proc/self/task/9719/status&#39;)
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;N&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;a&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;m&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;e&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;:&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1)
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;g&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;m&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;a&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;i&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1): &#39;n&#39;
</span></span><span style=display:flex><span>0x03897c: syscall: read(73, 0x7ffc400af4, 1)
</span></span><span style=display:flex><span>0x03897c: closedir()
</span></span><span style=display:flex><span># Crash!
</span></span></code></pre></div><p>To bypass this check, one can statically patch the syscall or we can dynamically
change the behavior of <code>snprintf(..., '/proc/self/task/%s/status')</code> in order to <strong>always</strong> returns the same status (e.g. <code>/proc/self/task/123/status</code>).
Concretely, it could be done by hooking <code>snprintf</code> and by forcing the <em>output</em> string to <code>/proc/self/task/123/status</code>.</p><h2 id=anti-frida-2>Anti-Frida #2</h2><p>Still in the <span class=red>sub_1a690</span> function, the anti-frida checks continue by inspecting the file descriptors
of the process. It iterates over <code>/proc/self/fd/%s</code> and looks at the underlying symlink.</p><p>Frida <span class=blue>server</span> &mdash; which is running globally on the device &mdash; and Frida agent &mdash; which is injected in the
process &mdash; communicate with named pipes that are associated with a file descriptor.</p><p>If Frida server is running, we can observe the following values:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x04308c: lstat(&#39;/proc/self/fd/32&#39;)
</span></span><span style=display:flex><span>0x043448: syscall: readlinkat(0xffffffffffffff9c, &#39;/proc/self/fd/32&#39;, 0x7ffbffdc10, 256): &#39;anon_inode:[eventfd]&#39;
</span></span><span style=display:flex><span>0x041844: readdir(&#39;33&#39;)
</span></span><span style=display:flex><span>0x043078: snprintf(&#39;/proc/self/fd/33&#39;, &#39;/proc/self/fd/%s&#39;): &#39;/proc/self/fd/33&#39;
</span></span><span style=display:flex><span>0x04308c: lstat(&#39;/proc/self/fd/33&#39;)
</span></span><span style=display:flex><span>0x043448: syscall: readlinkat(0xffffffffffffff9c, &#39;/proc/self/fd/33&#39;, 0x7ffbffdc10, 256): &#39;anon_inode:[eventfd]&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0x041844: readdir(&#39;34&#39;)
</span></span><span style=display:flex><span>0x043078: snprintf(&#39;/proc/self/fd/34&#39;, &#39;/proc/self/fd/%s&#39;): &#39;/proc/self/fd/34&#39;
</span></span><span style=display:flex><span>0x04308c: lstat(&#39;/proc/self/fd/34&#39;)
</span></span><span style=display:flex><span>0x043448: syscall: readlinkat(0xffffffffffffff9c, &#39;/proc/self/fd/34&#39;, 0x7ffbffdc10, 256): &#39;/data/local/tmp/re.frida.server/linjector-500&#39;
</span></span><span style=display:flex><span># Crash!
</span></span></code></pre></div><p>In this case, the file descriptor <code>34</code> is associated with <code>/data/local/tmp/re.frida.server/linjector-500</code>
which triggers the detection and the application crashes.</p><p>As for <code>/proc/self/task/&lt;tid>/status</code>, one can disable this check by <strong>statically patching</strong> the syscalls or
by <strong>dynamically changing</strong> the result of <code>readlinkat()</code>. For instance, we can use <a href=https://qbdi.quarkslab.com/>QBDI</a> to
instrument syscall instructions and process the result of <code>readlinkat()</code> in an user callback:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>vm.addMnemonicCB(<span style=color:#ba2121>&#34;SVC&#34;</span>, POST_INST,
</span></span><span style=display:flex><span>  [] (VMInstanceRef vm, GPRState<span style=color:#666>*</span> gprState, FPRState<span style=color:#666>*</span>, <span style=color:#b00040>void</span><span style=color:#666>*</span> data) {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (gprState<span style=color:#666>-&gt;</span>x8 <span style=color:#666>!=</span> __NR_readlinkat) {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>return</span> VMAction<span style=color:#666>::</span>CONTINUE;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>string buf <span style=color:#666>=</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span><span style=color:#b00040>char</span><span style=color:#666>*&gt;</span>(gprState<span style=color:#666>-&gt;</span>x2);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (buf.find(<span style=color:#ba2121>&#34;re.frida.server&#34;</span>) <span style=color:#666>!=</span> std<span style=color:#666>::</span>string<span style=color:#666>::</span>npos) {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>static</span> <span style=color:green;font-weight:700>const</span> std<span style=color:#666>::</span>string FAKE_VALUE <span style=color:#666>=</span> <span style=color:#ba2121>&#34;anon_inode:[eventfd]&#34;</span>;
</span></span><span style=display:flex><span>      <span style=color:#408080;font-style:italic>// Bypass Frida detection!
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>      memcpy(
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span><span style=color:#b00040>void</span><span style=color:#666>*&gt;</span>(gprState<span style=color:#666>-&gt;</span>x2),
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span><span style=color:#b00040>void</span><span style=color:#666>*&gt;</span>(FAKE_VALUE.c_str()),
</span></span><span style=display:flex><span>        FAKE_VALUE.size() <span style=color:#666>+</span> <span style=color:#666>1</span>
</span></span><span style=display:flex><span>      );
</span></span><span style=display:flex><span>      gprState<span style=color:#666>-&gt;</span>x0 <span style=color:#666>=</span> FAKE_VALUE.size() <span style=color:#666>+</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> VMAction<span style=color:#666>::</span>CONTINUE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }, ctx);
</span></span></code></pre></div><h2 id=anti-frida-3->Anti-Frida #3 ?</h2><p>I&rsquo;m not sure if the following calls sequence is used to check the libc&rsquo;s integrity against Frida but
at the end of the thread&rsquo;s routine, we can observe these syscalls:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x048ff0: syscall: openat(0xffffffffffffff9c, &#39;/proc/self/maps&#39;): 51
</span></span><span style=display:flex><span>0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &#39;1&#39;
</span></span><span style=display:flex><span>0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &#39;2&#39;
</span></span><span style=display:flex><span>0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &#39;c&#39;
</span></span><span style=display:flex><span>0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &#39;0&#39;
</span></span><span style=display:flex><span>0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &#39;0&#39;
</span></span><span style=display:flex><span>0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &#39;0&#39;
</span></span><span style=display:flex><span>0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &#39;0&#39;
</span></span><span style=display:flex><span>0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &#39;0&#39;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>0x0513f8: sscanf(&#39;7fa65c0000-7fa65dc000 r-xp 00000000 08:07 1275/system/lib64/libc.so&#39;, &#39;%lx-%lx %s %s %s %s %s&#39;)
</span></span><span style=display:flex><span>0x056034: syscall: close(51)
</span></span></code></pre></div><p>The result of <code>sscanf()</code> could be used to check the page permissions (e.g. <code>r</code><span class=blue>w</span><code>xp</code>)
or to the libc&rsquo;s base address (to check if it is consistent).</p><h2 id=anti-root>Anti-Root</h2><p>In addition to the root-beer detection, the library embeds another root detection located in the <strong>second</strong> ELF constructor.
This constructor &mdash; <span class=yellow>sub_77D14</span> &mdash; performs the same early checks as the first constructor
on the libc&rsquo;s <code>.plt</code> integrity before spawning another thread routine, <span class=yellow>sub_98c00</span>.</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x08861c: pthread_create(0xfa780b70, 0x0, 0x98c00, 0x0)
</span></span></code></pre></div><p><img src=ctor_pthread.png alt="ELF constructors: anti-frida and anti-root"></p><p>By tracing the thread&rsquo;s routine, we notice that it checks if <code>su</code> files are present on the device through
three different calls:</p><ol><li>One call to <code>open()</code>: <span class=hl-literal>0x099180: open(<span class=hl-strings>&rsquo;/system/xbin/su&rsquo;</span>)</span></li><li>One syscall to <code>openat()</code>: <span class=hl-literal>0x0992a4: syscall: openat(&mldr;, <span class=hl-strings>&rsquo;/data/su&rsquo;</span>)</span></li><li>One syscall to <code>faccessat()</code>: <span class=hl-literal>0x0993f0: syscall: faccessat(<span class=hl-strings>&rsquo;/sbin/su&rsquo;</span>)</span></li></ol><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x099180: open(&#39;/data/local/su&#39;): -1
</span></span><span style=display:flex><span>0x0992a4: syscall: openat(0xffffffffffffff9c, &#39;/data/local/su&#39;): -2
</span></span><span style=display:flex><span>0x0993f0: syscall: faccessat(&#39;/data/local/su&#39;): -2
</span></span><span style=display:flex><span>0x099180: open(&#39;/data/local/bin/su&#39;): -1
</span></span><span style=display:flex><span>0x0992a4: syscall: openat(0xffffffffffffff9c, &#39;/data/local/bin/su&#39;): -2
</span></span><span style=display:flex><span>0x0993f0: syscall: faccessat(&#39;/data/local/bin/su&#39;): -2
</span></span><span style=display:flex><span>0x099180: open(&#39;/data/local/xbin/su&#39;): -1
</span></span><span style=display:flex><span>0x0992a4: syscall: openat(0xffffffffffffff9c, &#39;/data/local/xbin/su&#39;): -2
</span></span><span style=display:flex><span>0x0993f0: syscall: faccessat(&#39;/data/local/xbin/su&#39;): -2
</span></span><span style=display:flex><span>0x099180: open(&#39;/sbin/su&#39;): 51
</span></span><span style=display:flex><span>0x0992a4: syscall: openat(0xffffffffffffff9c, &#39;/sbin/su&#39;): 52
</span></span><span style=display:flex><span>0x0993f0: syscall: faccessat(&#39;/sbin/su&#39;): 52
</span></span><span style=display:flex><span>Crash!
</span></span></code></pre></div><p>By forcing the results of these functions to <code>-1</code> or <code>-2</code>, we can disable the checks.</p><p>Here is the list of the su-files that are used in this detection:</p><ul><li><span class=hl-strings>/data/local/su</span></li><li><span class=hl-strings>/data/local/bin/su</span></li><li><span class=hl-strings>/data/local/xbin/su</span></li><li><span class=hl-strings>/sbin/su</span></li><li><span class=hl-strings>/su/bin/su</span></li><li><span class=hl-strings>/system/bin/su</span></li><li><span class=hl-strings>/system/bin/.ext/su</span></li><li><span class=hl-strings>/system/bin/failsafe/su</span></li><li><span class=hl-strings>/system/sd/xbin/su</span></li><li><span class=hl-strings>/system/usr/we-need-root/su</span></li><li><span class=hl-strings>/system/xbin/su</span></li><li><span class=hl-strings>/cache/su</span></li><li><span class=hl-strings>/data/su</span></li><li><span class=hl-strings>/dev/su</span></li></ul><p>At the end of the thread&rsquo;s routine, we can also observe the following calls that
are probably used to check if the application is running on a real Android system.</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0x099e30: syscall: faccessat(&#39;/system&#39;)
</span></span><span style=display:flex><span>0x099e30: syscall: faccessat(&#39;/system/bin&#39;)
</span></span><span style=display:flex><span>0x099e30: syscall: faccessat(&#39;/system/sbin&#39;)
</span></span><span style=display:flex><span>0x099e30: syscall: faccessat(&#39;/system/xbin&#39;)
</span></span><span style=display:flex><span>0x099e30: syscall: faccessat(&#39;/vendor/bin&#39;)
</span></span><span style=display:flex><span>0x099e30: syscall: faccessat(&#39;/sbin&#39;)
</span></span><span style=display:flex><span>0x099e30: syscall: faccessat(&#39;/etc&#39;)
</span></span></code></pre></div><h2 id=static-bypass-with-lief>Static bypass with LIEF</h2><p>In the previous sections, we described the anti-root, anti-debug and anti-frida checks
made in the ELF constructors. The <strong>same</strong> dynamic checks are also performed in the <code>gXftm3iswpkVgBNDUp</code> function
at the following locations:</p><ul><li><span class=hl-keyword>0x09f2f8</span>: <span class=hl-literal>/proc/self/status</span></li><li><span class=hl-keyword>0x0d4840</span>: <span class=hl-literal>/proc/self/fd/</span></li><li><span class=hl-keyword>0x0dec8c</span>: <span class=hl-literal>/proc/self/task/&lt;tid>/status</span></li></ul><p>While the checks in <code>gXftm3iswpkVgBNDUp</code> can be dynamically disabled when instrumenting the function,
the checks in the ELF constructors are annoying.</p><p>One way to disable the checks in the thread&rsquo;s routines is to disable the <code>pthread_create(...)</code>. It can
be achieved by patching the <code>.plt</code> entry associated with the function:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-armasm data-lang=armasm><span style=display:flex><span>mov <span style=color:#00f;font-weight:700>x0</span>, <span>xzr</span><span style=color:#408080;font-style:italic>;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>ret<span style=color:#408080;font-style:italic>;
</span></span></span></code></pre></div><p>Thanks to <code>llvm-mc</code>, we can get the raw bytes of these instructions:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> <span style=color:green>echo</span> <span style=color:#ba2121>&#34;mov x0, xzr;ret;&#34;</span>|llvm-mc -arch<span style=color:#666>=</span>aarch64 -show-encoding
</span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>.text
</span></span></span><span style=display:flex><span><span style=color:#888>mov     x0, xzr                 // encoding: [0xe0,0x03,0x1f,0xaa]
</span></span></span><span style=display:flex><span><span style=color:#888>ret                             // encoding: [0xc0,0x03,0x5f,0xd6]
</span></span></span></code></pre></div><p>Finally, we can patch the <code>.plt</code> with <a href=https://lief.quarkslab.com>LIEF</a>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>lief</span>
</span></span><span style=display:flex><span>lib <span style=color:#666>=</span> lief<span style=color:#666>.</span>parse(<span style=color:#ba2121>&#34;./libnative-lib.so&#34;</span>)
</span></span><span style=display:flex><span>lib<span style=color:#666>.</span>patch_address(<span style=color:#666>0x5870</span>, [<span style=color:#666>0xe0</span>,<span style=color:#666>0x03</span>,<span style=color:#666>0x1f</span>,<span style=color:#666>0xaa</span>])
</span></span><span style=display:flex><span>lib<span style=color:#666>.</span>patch_address(<span style=color:#666>0x5874</span>, [<span style=color:#666>0xc0</span>,<span style=color:#666>0x03</span>,<span style=color:#666>0x5f</span>,<span style=color:#666>0xd6</span>])
</span></span><span style=display:flex><span>lib<span style=color:#666>.</span>write(<span style=color:#ba2121>&#34;./libnative-lib-patched.so&#34;</span>)
</span></span></code></pre></div><p><img src=patching.png alt="pthread_create patches"></p><p>Using these patches and the Frida script exposed in the first section, we are able to <strong>load</strong> the application but the other
detections are triggered in <code>gXftm3iswpkVgBNDUp</code>. Nevertheless, with
the Frida&rsquo;s stalker or QBDI we can trace the instructions and disable the other checks.</p><p>If one wants to completely bypass all the protections statically, here are the patches:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>lief</span>
</span></span><span style=display:flex><span>lib <span style=color:#666>=</span> lief<span style=color:#666>.</span>parse(<span style=color:#ba2121>&#34;./libnative-lib.so&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic># Keys are str objects for a better understanding :)</span>
</span></span><span style=display:flex><span>INST <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#ba2121>&#34;mov x0, #0&#34;</span>:  [<span style=color:#666>0xe0</span>, <span style=color:#666>0x03</span>, <span style=color:#666>0x1f</span>, <span style=color:#666>0xaa</span>],
</span></span><span style=display:flex><span>    <span style=color:#ba2121>&#34;ret&#34;</span>:         [<span style=color:#666>0xc0</span>, <span style=color:#666>0x03</span>, <span style=color:#666>0x5f</span>, <span style=color:#666>0xd6</span>],
</span></span><span style=display:flex><span>    <span style=color:#ba2121>&#34;nop&#34;</span>:         [<span style=color:#666>0x1f</span>, <span style=color:#666>0x20</span>, <span style=color:#666>0x03</span>, <span style=color:#666>0xd5</span>],
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PATCHES <span style=color:#666>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic># Patch the .plt entry of pthread_create</span>
</span></span><span style=display:flex><span>    (<span style=color:#666>0x5870</span>, INST[<span style=color:#ba2121>&#34;mov x0, #0&#34;</span>]),
</span></span><span style=display:flex><span>    (<span style=color:#666>0x5874</span>, INST[<span style=color:#ba2121>&#34;ret&#34;</span>]),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic># Disable anti-frida checks</span>
</span></span><span style=display:flex><span>    (<span style=color:#666>0x0d718c</span>, INST[<span style=color:#ba2121>&#34;mov x0, #0&#34;</span>]), <span style=color:#408080;font-style:italic># /proc/self/fd : patch the result of readlinkat syscall</span>
</span></span><span style=display:flex><span>    (<span style=color:#666>0x0e1940</span>, INST[<span style=color:#ba2121>&#34;mov x0, #0&#34;</span>]), <span style=color:#408080;font-style:italic># /proc/self/task/&lt;tid&gt;/status: patch the result of read syscall</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic># Disable .text integrity checks</span>
</span></span><span style=display:flex><span>    (<span style=color:#666>0xB64D0</span>, INST[<span style=color:#ba2121>&#34;nop&#34;</span>]),
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> patch <span style=color:#a2f;font-weight:700>in</span> PATCHES:
</span></span><span style=display:flex><span>    lib<span style=color:#666>.</span>patch_address(<span style=color:#666>*</span>patch)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>lib<span style=color:#666>.</span>write(<span style=color:#ba2121>&#34;libnative-lib.so&#34;</span>)
</span></span></code></pre></div><p>When writing this write-up, I realized that patching the syscalls involved in the anti-frida (<span class=hl-literal>/proc/self/fd/</span> and <span class=hl-literal>/proc/self/task/&lt;tid>/status</span>)
makes the application crash.</p><p>It turns out that the library seems to implement <strong>code integrity on the <code>.text</code> section</strong> that I didn&rsquo;t notice when running
the function through QBDI.
Nevertheless, by tracing the basic block<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>
we can identify the basic block involved in the integrity check and patch it.</p><p><img src=code_integrity.png alt="Code integrity patches"></p><div class="alert alert-info" role=alert style=border:none!important;background-color:#fafcff>The scripts and the patched library are available <a href=https://github.com/romainthomas/r2pay>here <i class="fab fa-github"></i></a>.</div><p>Regarding <code>JNI_OnLoad()</code>, a trace generated with <a href=https://github.com/QBDI/examples/blob/d589d28b237f46d16cab3b11aa36bbb51102e307/packer-android-x86/src/libshellx_qbdi.cpp#L18-L85>QBDI&rsquo;s ExecBroker</a>
leads to following result:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>JNI_OnLoad() {
</span></span><span style=display:flex><span>    <span style=color:#666>0x09af3c</span><span style=color:#666>:</span> GetEnv(<span style=color:#666>0x7fcb507460</span>, <span style=color:#666>0x10006</span>)
</span></span><span style=display:flex><span>    <span style=color:#666>0x09b0ac</span><span style=color:#666>:</span> FindClass(<span style=color:#ba2121>&#34;re/pwnme/MainActivity&#34;</span>)<span style=color:#666>:</span> <span style=color:#666>537</span>
</span></span><span style=display:flex><span>    <span style=color:#666>0x09b1b4</span><span style=color:#666>:</span> RegisterNatives()
</span></span><span style=display:flex><span>        gXftm3iswpkVgBNDUp ([BB)[B <span style=color:#666>-&gt;</span> <span style=color:#ba2121>&#34;libnative-lib.so@0x9b41c&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, we can extract the function&rsquo;s offset: <span class=blue>gXftm3iswpkVgBNDUp</span>: <span class=red>0x9b41c</span>.</p><h2 id=summary--conclusion>Summary & Conclusion</h2><p>Whilst Frida detections are usually based on sockets and library names in <code>/proc/self/maps</code>,
this challenge introduces two detections based on named pipes:<code>/proc/self/fd</code> and thread status: <code>/proc/self/task/&lt;tid>/status</code>
which are pretty cool :-)</p><p>These checks are performed in two locations:</p><ol><li>The ELF constructors</li><li>The function <code>gXftm3iswpkVgBNDUp()</code></li></ol><p>The implementation in the ELF constructors might be tricky to analyse since the functions are called before <strong>any</strong>
other classical functions (which includes <code>JNI_OnLoad()</code>). Nevertheless, thanks to the interface of the ELF loader,
it exposes the function <code>call_array(...)</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> which is handy to process the ELF constructors.</p><div class="alert alert-info" role=alert style=border:none!important;background-color:#fafcff>This function is mangled as <code>__dl__ZL10call_arrayIPFviPPcS1_EEvPKcPT_mbS5_</code> in <code>/system/bin/linker64</code></div><p><img src=protection_overview.png alt="Overview of the anti-root and anti-frida"></p><p>Since QBDI is not detected in this challenge, it&rsquo;s a good opportunity to give it a try:</p><center><p><i class="fab fa-github"></i> <a href=https://github.com/QBDI/QBDI>https://github.com/QBDI/QBDI</a></p></center><h2 id=acknowledgments>Acknowledgments</h2><p>Thanks to <u>Eduardo Novella</u> (<a href=https://twitter.com/enovella_>@enovella_</a>)
and <u>Gautam Arvind</u> (<a href=https://twitter.com/darvincisec>@darvincisec</a>) for this interesting and realistic challenge they created!</p><p>Also thanks to <u><a href=https://www.quarkslab.com>Quarkslab</a></u> that allowed this publication.
For those who are interested in similar topics, you can take a look at the Quarkslab&rsquo;s <a href=https://blog.quarkslab.com/>blog</a>.</p><h3 id=references>References</h3><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://github.com/GoSSIP-SJTU/Armariris>GoSSIP-SJTU/Armariris</a> - <a href=https://github.com/GoSSIP-SJTU/Armariris/blob/0cba41329244a29c7cb94e25458191b68967b6e8/lib/Transforms/Obfuscation/StringObfuscation.cpp#L140><code>StringObfuscation.cpp#L140</code></a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://developer.android.com/training/articles/perf-jni#native-libraries>https://developer.android.com/training/articles/perf-jni#native-libraries</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://github.com/QBDI/QBDI/blob/a20653f07df3ae78250e7ecf28ed699b2d727027/include/QBDI/VM.h#L296-L305><code>addVMEventCB(VMEvent::BASIC_BLOCK_ENTRY, ...);</code></a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://android.googlesource.com/platform/bionic/+/refs/tags/android-9.0.0_r60/linker/linker_soinfo.cpp#420><code>linker/linker_soinfo.cpp:420</code></a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></div></div></div></div></main><script src=/vendor/bootstrap/dist/js/bootstrap.min.js></script>
<script src=/vendor/headroom.js/dist/headroom.min.js></script>
<script src=/vendor/onscreen/dist/on-screen.umd.min.js></script>
<script src=/vendor/jarallax/dist/jarallax.min.js></script>
<script src=/vendor/smooth-scroll/dist/smooth-scroll.polyfills.min.js></script>
<script src=/js/theme.bundle.js></script>
<script src=/vendor/@glidejs/glide/dist/glide.min.js></script>
<script src=/js/anime.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script>
<script>function katex_load(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})}</script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=katex_load()></script></body></html>