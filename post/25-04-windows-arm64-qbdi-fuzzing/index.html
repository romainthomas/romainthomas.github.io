<!doctype html><html lang=en-us prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=manifest href=manifest.webmanifest><link rel=icon type=image/png href=/img/favicon/favicon_hu_5cf5d258215c6333.png><link rel=apple-touch-icon type=image/png href=/img/favicon/favicon_hu_63d1451a5feec899.png><meta name=description content="This blog post introduces coverage-guided fuzzing with QBDI and libFuzzer targeting Windows ARM64."><meta name=keywords content="windows,arm64"><meta property="og:type" content="article"><meta property="og:description" content="This blog post introduces coverage-guided fuzzing with QBDI and libFuzzer targeting Windows ARM64."><meta property="og:title" content="Fuzzing Windows ARM64 closed-source binary  | Romain Thomas"><meta property="og:site_name" content="Romain Thomas"><meta property="og:image" content="https://www.romainthomas.fr/post/25-04-windows-arm64-qbdi-fuzzing/featured.webp"><meta property="og:url" content="https://www.romainthomas.fr/post/25-04-windows-arm64-qbdi-fuzzing/"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2025-04-28T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-29T17:29:22+02:00"><meta property="article:tag" content="windows"><meta property="article:tag" content="arm64"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@rh0main"><meta name=twitter:creator content="@rh0main"><meta name=twitter:title content="Fuzzing Windows ARM64 closed-source binary  | Romain Thomas"><meta name=twitter:description content="This blog post introduces coverage-guided fuzzing with QBDI and libFuzzer targeting Windows ARM64."><meta name=twitter:domain content="https://www.romainthomas.fr/post/25-04-windows-arm64-qbdi-fuzzing/"><meta property="twitter:image" content="https://www.romainthomas.fr/post/25-04-windows-arm64-qbdi-fuzzing/featured.webp"><title>Romain Thomas</title><link rel=canonical href=https://www.romainthomas.fr/post/25-04-windows-arm64-qbdi-fuzzing/><link rel=stylesheet href=/css/fa-all.min.css><link rel=stylesheet href=/vendor/@glidejs/glide/dist/css/glide.core.min.css><link rel=stylesheet href=/vendor/@glidejs/glide/dist/css/glide.theme.min.css><link rel=stylesheet href=/css/theme.bundle.css><style>.hide{opacity:0}</style><noscript><style>.hide{opacity:1;!important}</style></noscript><style>.hero_background{position:relative;overflow:hidden}.hero_background:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:90%;z-index:1;opacity:.2;background-image:url(/img/bg_home.svg);background-repeat:repeat;background-position:50%;background-size:100%;transform:rotate(180deg)}.project_bg{position:relative;overflow:hidden}.project_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;opacity:.1;background-image:url(/img/bg_project.svg);background-repeat:repeat;background-position:50%;background-size:100%;transform:rotate(180deg)}.experience_bg{position:relative;overflow:hidden}.experience_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;opacity:.1;background-image:url(/img/bg_experience.svg);background-position:0 0;background-size:100%}.post_bg{position:relative;overflow:hidden}.post_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:80%;z-index:1;opacity:.6;background-image:url(/img/bg_post.svg);background-position:0 0;background-size:100%}.contact_bg{position:relative;overflow:hidden}.contact_bg:before{pointer-events:none;content:' ';display:block;position:absolute;left:0;top:0;width:100%;height:80%;z-index:1;opacity:.2;background-image:url(/img/bg_contact.svg);background-position:0 0;background-size:100%}.footnotes p{margin-bottom:0}.highlight{padding-left:20px;border-left:1px solid rgba(0,0,0,.1);border-radius:2px 2px}</style></head><body><header class=header-global><nav id=navbar-main aria-label="Primary navigation" class="navbar navbar-main navbar-expand-lg navbar-theme-primary headroom navbar-dark"><div class="container position-relative"><a class="navbar-brand me-lg-5" href=https://www.romainthomas.fr/><span class="navbar-brand-dark ft-ananda">R. T</span>
<span class="navbar-brand-light ft-ananda">R. T</span></a><div class="navbar-collapse collapse me-auto" id=navbar_global><div class=navbar-collapse-header><div class=row><div class="col-6 collapse-close"><a href=#navbar_global class="fas fa-times" data-bs-toggle=collapse data-bs-target=#navbar_global aria-controls=navbar_global aria-expanded=false title=close aria-label="Toggle navigation"></a></div></div></div><ul class="navbar-nav navbar-nav-hover align-items-lg-center"><li class=nav-item><a href=https://www.romainthomas.fr/#about class="nav-link fw-bold"><span class="fa-regular fa-person-swimming"></span> About</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#posts class="nav-link fw-bold"><span class="fa-regular fa-blog"></span> Posts</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#projects class="nav-link fw-bold"><span class="fa-regular fa-terminal"></span> Projects</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#publications class="nav-link fw-bold"><span class="far fa-book-open-cover"></span> Publications</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#trainings class="nav-link fw-bold"><span class="far fa-books"></span> Trainings</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#misc class="nav-link fw-bold"><span class="fa-regular fa-chart-network"></span> Misc</a></li><li class=nav-item><a href=https://www.romainthomas.fr/#contact class="nav-link fw-bold"><span class="fa-regular fa-binary-lock"></span> Contact</a></li></ul></div><div class="d-flex align-items-center"><button class="navbar-toggler ms-2 collapsed" type=button data-bs-toggle=collapse data-bs-target=#navbar_global aria-controls=navbar_global aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button></div></div></nav></header><main><section class="section-header pb-5 pb-sm-7 bg-primary text-white post_bg"><div class=container><div class="row justify-content-center"><div class="col-12 col-lg-10 text-center"><div class=mb-4><a href=/categories/fuzzing/><span class="me-2 badge alert-info text-uppercase px-3 btn-outline-primary">Fuzzing</span></a></div><h1 class="display-3 mb-4 px-lg-5">Fuzzing Windows ARM64 closed-source binary</h1><div class=post-meta><span class="fw-bold me-3">Romain Thomas
</span><span class="post-date me-3">April 28, 2025</span>
<span class=fw-bold>8 min read</span></div></div></div></div><figure class="position-absolute bottom-0 left-0 w-100 d-none d-md-block mb-n2"><svg class="fill-white" viewBox="0 0 3e3 185.4"><path d="M3e3.0v185.4H0V0c496.4 115.6 996.4 173.4 15e2 173.4S2503.6 115.6 3e3.0z"/></svg></figure></section><section class="section section-lg pt-0 pb-0" id=featured><div class="container mt-n8 mt-lg-n10 z-2 pb-0"><div class="row mt-7 mx-10"><img src=/post/25-04-windows-arm64-qbdi-fuzzing/featured.webp class="rounded img-fluid" alt=featured.webp></div></div></section><div class="section section-sm bg-white pt-4 pt-lg-4 text-black"><article class=container><div class="row justify-content-center"><div class="col-12 col-lg-9"><p><h2 id=introduction>Introduction</h2><p>Coverage-guided fuzzing is a well-known technique that improves the efficiency
of a fuzzer by providing runtime feedback</p><p>This blog post explores this concept on Windows ARM64, using QBDI for code
instrumentation and LLVM&rsquo;s libFuzzer as the fuzzing engine.</p><p>In addition to the fact that QBDI is based on LLVM and
libFuzzer is under the LLVM umbrella, the support for Windows ARM64
(<code>arm64-pc-windows-msvc</code>) in LLVM is sufficient for cross-compiling executables
and libraries from Linux.</p><p>All the LLVM components mentioned in this blog post are based on LLVM 20.1.3
(2025-04-16)</p><h2 id=libfuzzer-101>LibFuzzer 101</h2><p>First, let&rsquo;s consider that we have access to the source code of the function that
we want to fuzz:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>fuzzme</span>(<span style=color:green;font-weight:700>const</span> <span style=color:#b00040>uint8_t</span> <span style=color:#666>*</span>data, size_t size) {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>0</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;Q&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>1</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>1</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;B&#39;</span>) {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>2</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>2</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;D&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>3</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>3</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;I&#39;</span>) {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>4</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>4</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;!&#39;</span>) {
</span></span><span style=display:flex><span>            __builtin_trap();
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>extern</span> <span style=color:#ba2121>&#34;C&#34;</span> <span style=color:#b00040>int</span> LLVMFuzzerTestOneInput(<span style=color:green;font-weight:700>const</span> <span style=color:#b00040>uint8_t</span> <span style=color:#666>*</span>data, size_t size) {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>return</span> <span style=color:#00f>fuzzme</span>(data, size);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As mentioned in the documentation of libFuzzer<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, we can run clang on this
source file to leverage built-in coverage instrumentation:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ clang++ --target<span style=color:#666>=</span>arm64-pc-windows-msvc -fsanitize<span style=color:#666>=</span>fuzzer -c fuzzme.cpp -o fuzzme.obj
</span></span></code></pre></div><p>When compiling <code>fuzzme.cpp</code> with the <code>-fsanitize=fuzzer</code> flag, Clang instruments
the code at sensitive locations to enhance fuzzer efficiency.
In this context, these sensitive locations are:</p><ul><li>Comparisons (e.g. <code>data[3] == 'I'</code>)</li><li>Basic block edges</li></ul><p>You can find more about the LLVM code coverage instrumentation built-in on the
<a href=https://clang.llvm.org/docs/SanitizerCoverage.html>SanitizerCoverage</a> page.</p><p>When we open <code>fuzzme.obj</code> in Binary Ninja, we get the following representation:</p><p><img src=./img/llvm-instru.webp alt></p><ul><li><code>__sanitizer_cov_trace_const_cmp{4,8}</code> is injected before comparisons</li><li>Edge coverage is done by incrementing a bitmap.</li></ul><p>For more insight about how a bitmap is used by a fuzzer, I recommend this
presentation by P. - batcido - Hernault : <a href=https://project.inria.fr/FranceJapanICST/files/2019/04/19-Kyoto-Fuzzing_Binaries_using_Dynamic_Instrumentation.pdf>Fuzzing binaries using Dynamic Instrumentation</a></p><p>The hidden instrumentation produced by Clang with the <code>-fsanitize=fuzzer</code> flag
can also be achieved by manually modifying the source code:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:green;font-weight:700>extern</span> <span style=color:#ba2121>&#34;C&#34;</span> <span style=color:#b00040>void</span> __sanitizer_cov_trace_const_cmp8(<span style=color:#b00040>uint64_t</span> Arg1, <span style=color:#b00040>uint64_t</span> Arg2);
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>extern</span> <span style=color:#ba2121>&#34;C&#34;</span> <span style=color:#b00040>void</span> __sanitizer_cov_trace_const_cmp4(<span style=color:#b00040>uint32_t</span> Arg1, <span style=color:#b00040>uint32_t</span> Arg2);
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>extern</span> <span style=color:#ba2121>&#34;C&#34;</span> <span style=color:#b00040>void</span> __sanitizer_cov_8bit_counters_init(<span style=color:#b00040>uint8_t</span> <span style=color:#666>*</span>Start, <span style=color:#b00040>uint8_t</span> <span style=color:#666>*</span>Stop);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>static</span> std<span style=color:#666>::</span>array<span style=color:#666>&lt;</span><span style=color:#b00040>uint8_t</span>, <span style=color:#666>5</span><span style=color:#666>&gt;</span> BITMAP <span style=color:#666>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// For the *NIX folks, this code is equivalent to
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// __attribute__((constructor)) void ctor() {
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//    __sanitizer_cov_8bit_counters_init(BITMAP.data(), BITMAP.data() + BITMAP.size())
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// }
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// but since __attribute__((constructor)) is not available and its equivalent is
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// painfull to write, we allocate a static class whose constructor init the bitmap
</span></span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>InitBitMap</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>public</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>  InitBitMap() {
</span></span><span style=display:flex><span>    BITMAP.fill(<span style=color:#666>0</span>);
</span></span><span style=display:flex><span>    __sanitizer_cov_8bit_counters_init(BITMAP.data(), BITMAP.data() <span style=color:#666>+</span> BITMAP.size());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>static</span> InitBitMap _;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>fuzzme</span>(<span style=color:green;font-weight:700>const</span> <span style=color:#b00040>uint8_t</span> <span style=color:#666>*</span>data, size_t size) {
</span></span><span style=display:flex;background-color:#e5e5e5><span>  __sanitizer_cov_trace_const_cmp8(size, <span style=color:#666>0</span>);
</span></span><span style=display:flex;background-color:#e5e5e5><span>  __sanitizer_cov_trace_const_cmp4(data[<span style=color:#666>0</span>], <span style=color:#ba2121>&#39;Q&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>0</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;Q&#39;</span>) {
</span></span><span style=display:flex;background-color:#e5e5e5><span>    __sanitizer_cov_trace_const_cmp8(size, <span style=color:#666>1</span>);
</span></span><span style=display:flex;background-color:#e5e5e5><span>    __sanitizer_cov_trace_const_cmp4(data[<span style=color:#666>1</span>], <span style=color:#ba2121>&#39;B&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>1</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>1</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;B&#39;</span>) {
</span></span><span style=display:flex;background-color:#e5e5e5><span>      __sanitizer_cov_trace_const_cmp8(size, <span style=color:#666>2</span>);
</span></span><span style=display:flex;background-color:#e5e5e5><span>      __sanitizer_cov_trace_const_cmp4(data[<span style=color:#666>2</span>], <span style=color:#ba2121>&#39;D&#39;</span>);
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>2</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>2</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;D&#39;</span>) {
</span></span><span style=display:flex;background-color:#e5e5e5><span>        __sanitizer_cov_trace_const_cmp8(size, <span style=color:#666>3</span>);
</span></span><span style=display:flex;background-color:#e5e5e5><span>        __sanitizer_cov_trace_const_cmp4(data[<span style=color:#666>3</span>], <span style=color:#ba2121>&#39;I&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>3</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>3</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;I&#39;</span>) {
</span></span><span style=display:flex;background-color:#e5e5e5><span>          __sanitizer_cov_trace_const_cmp8(size, <span style=color:#666>4</span>);
</span></span><span style=display:flex;background-color:#e5e5e5><span>          __sanitizer_cov_trace_const_cmp4(data[<span style=color:#666>4</span>], <span style=color:#ba2121>&#39;!&#39;</span>);
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#666>4</span> <span style=color:#666>&amp;&amp;</span> data[<span style=color:#666>4</span>] <span style=color:#666>==</span> <span style=color:#ba2121>&#39;!&#39;</span>) {
</span></span><span style=display:flex><span>            __builtin_trap();
</span></span><span style=display:flex;background-color:#e5e5e5><span>          } <span style=color:green;font-weight:700>else</span> { <span style=color:#666>++</span>BITMAP[<span style=color:#666>4</span>]; }
</span></span><span style=display:flex;background-color:#e5e5e5><span>        } <span style=color:green;font-weight:700>else</span> { <span style=color:#666>++</span>BITMAP[<span style=color:#666>3</span>]; }
</span></span><span style=display:flex;background-color:#e5e5e5><span>      } <span style=color:green;font-weight:700>else</span> { <span style=color:#666>++</span>BITMAP[<span style=color:#666>2</span>]; }
</span></span><span style=display:flex;background-color:#e5e5e5><span>    } <span style=color:green;font-weight:700>else</span> { <span style=color:#666>++</span>BITMAP[<span style=color:#666>1</span>]; }
</span></span><span style=display:flex;background-color:#e5e5e5><span>  } <span style=color:green;font-weight:700>else</span> { <span style=color:#666>++</span>BITMAP[<span style=color:#666>0</span>]; }
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this <strong>manual</strong> source-based instrumentation, we simply need to link the
compiled object file (<code>fuzzme.obj</code>) with the LibFuzzer runtime
(<code>lib/clang/20/lib/arm64-pc-windows-msvc/clang_rt.fuzzer.lib</code>):</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ clang++ -fuse-ld<span style=color:#666>=</span>lld-link -fsanitize<span style=color:#666>=</span>fuzzer fuzzme.obj -o fuzzme.exe
</span></span></code></pre></div><p>Et voilà.</p><p>As depicted in the following screenshot, when running <code>fuzzme.exe</code> on
my Inspiron 14 Plus (Snapdragon X Elite), libFuzzer finds the relevant input (<code>QBDI!</code>)
in less than a second.</p><center><figure><img class=lightense data-lightense-background=#fff src=/post/25-04-windows-arm64-qbdi-fuzzing/img/fuzzing-src-feedback.webp alt="Fuzzing with source instrumentation feedback"><br><figcaption>Fuzzing with source instrumentation feedback</figure></figure><br></center><p>The key point here is that providing feedback to the fuzzer engine (libFuzzer)
enhances the chances of finding meaningful inputs.
While in this section, we assumed we had access to the function&rsquo;s original
source code, the next section assumes a black-box approach.</p><h2 id=dbi-based-fuzzing>DBI-based Fuzzing</h2><p>Now let&rsquo;s consider that we don&rsquo;t have access to the source code of the function,
which means we cannot use the <code>-fsanitize=fuzzer</code> option at compile time or
manually modify the source code. This situation is similar to fuzzing a closed-source
function. However, in our case, the implementation and the harness of <code>fuzzme</code>
is simple which is usually not the case with real-world targets.</p><p>Without any kind of feedback to libFuzzer, <code>fuzzme.exe</code> runs at ~300k execs/s
but it fails to find the input that triggers the <code>__builtin_trap</code> case before hours.</p><center><figure><img class=lightense data-lightense-background=#fff src=/post/25-04-windows-arm64-qbdi-fuzzing/img/fuzzing-nofeedback.webp alt="Fuzzing without feedback"><br><figcaption>Fuzzing without feedback</figure></figure><br></center><p>By using a DBI like Intel PIN, DynamoRIO, Frida, QBDI or emulating the code (QEMU/Unicorn),
we can gather information about the code being executed or emulated.
This information can then be used to provide feedback to libFuzzer.</p><p>While I&rsquo;m sure the following example could work with QEMU, Frida or other DBI,
I will focus on demonstrating these concepts using <a href=https://github.com/QBDI/QBDI>QBDI</a>.</p><h3 id=qbdi-bootstrap>QBDI Bootstrap</h3><p>To instrument a function through QBDI, we first need to create and instantiate
<code>QBDI::VM</code><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:green;font-weight:700>extern</span> <span style=color:#ba2121>&#34;C&#34;</span> <span style=color:#b00040>int</span> LLVMFuzzerTestOneInput(<span style=color:green;font-weight:700>const</span> <span style=color:#b00040>uint8_t</span> <span style=color:#666>*</span>data, size_t size) {
</span></span><span style=display:flex><span>  QBDI<span style=color:#666>::</span>VM dbi;
</span></span><span style=display:flex><span>  dbi.addInstrumentedModuleFromAddr((uintptr_t)<span style=color:#666>&amp;</span>fuzzme);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  QBDI<span style=color:#666>::</span>GPRState<span style=color:#666>*</span> gpr <span style=color:#666>=</span> dbi.getGPRState();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  gpr<span style=color:#666>-&gt;</span>pc <span style=color:#666>=</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>uintptr_t<span style=color:#666>&gt;</span>(fuzzme);
</span></span><span style=display:flex><span>  gpr<span style=color:#666>-&gt;</span>lr <span style=color:#666>=</span> <span style=color:#666>0xdeadc0de</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  gpr<span style=color:#666>-&gt;</span>x0 <span style=color:#666>=</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>uintptr_t<span style=color:#666>&gt;</span>(data);
</span></span><span style=display:flex><span>  gpr<span style=color:#666>-&gt;</span>x1 <span style=color:#666>=</span> <span style=color:green;font-weight:700>reinterpret_cast</span><span style=color:#666>&lt;</span>uintptr_t<span style=color:#666>&gt;</span>(size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  dbi.run(gpr<span style=color:#666>-&gt;</span>pc, gpr<span style=color:#666>-&gt;</span>lr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>return</span> dbi.getGPRState()<span style=color:#666>-&gt;</span>x0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code is just bootstrapping the execution of <code>fuzzme()</code> through QBDI. In particular,
we initiate <code>x0</code> and <code>x1</code> to match the inputs of <code>LLVMFuzzerTestOneInput</code>.</p><h3 id=basic-block-coverage>Basic Block Coverage</h3><p>Once we have setup the execution through QBDI, we can define instrumentation callbacks
to provide feedback to LibFuzzer. For instance, we can offer coverage feedback using
the QBDI event <code>BASIC_BLOCK_ENTRY</code>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:green;font-weight:700>static</span> std<span style=color:#666>::</span>vector<span style=color:#666>&lt;</span><span style=color:#b00040>uint8_t</span><span style=color:#666>&gt;</span> BITMAP;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dbi.addVMEventCB(VMEvent<span style=color:#666>::</span>BASIC_BLOCK_ENTRY,
</span></span><span style=display:flex><span>  [] (VM<span style=color:#666>*</span> vm, <span style=color:green;font-weight:700>const</span> VMState<span style=color:#666>*</span> state, GPRState<span style=color:#666>*</span> gpr, FPRState<span style=color:#666>*</span> fpr, <span style=color:#b00040>void</span><span style=color:#666>*</span> ctx) {
</span></span><span style=display:flex><span>    size_t bitmap_idx <span style=color:#666>=</span> to_index(state<span style=color:#666>-&gt;</span>basicBlockStart);
</span></span><span style=display:flex><span>    BITMAP[bitmap_idx] <span style=color:#666>+=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> VMAction<span style=color:#666>::</span>CONTINUE;
</span></span><span style=display:flex><span>  });
</span></span></code></pre></div><h3 id=comparison-feedback>Comparison Feedback</h3><p>We can also use QBDI to provide feedback about the comparisons similarly to
<code>__sanitizer_cov_trace_const_cmp{4,8}</code>. At the assembly level, these comparisons
are represented as follows:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>14004ada8  08044039   ldrb    w8, [x0, #0x1]
</span></span><span style=display:flex><span>14004adac  1f090171   cmp     w8, #0x42
</span></span><span style=display:flex><span>14004adb0  c1010054   b.ne    0x14004ade8
</span></span></code></pre></div><p>In particular, the LLVM <code>MCInst</code> representation of <code>cmp w8, #0x42</code> is:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&lt;stdin&gt;:1:1: note: parsed instruction: [&#39;cmp&#39;, &lt;register 216&gt;, 66]
</span></span><span style=display:flex><span>cmp w8, #0x42
</span></span><span style=display:flex><span>^
</span></span><span style=display:flex><span>        cmp     w8, #0x42   // encoding: [0x1f,0x09,0x01,0x71]
</span></span><span style=display:flex><span>                            // &lt;MCInst #7422 SUBSWri
</span></span><span style=display:flex><span>                            //  &lt;MCOperand Reg:12&gt;
</span></span><span style=display:flex><span>                            //  &lt;MCOperand Reg:216&gt;
</span></span><span style=display:flex><span>                            //  &lt;MCOperand Imm:66&gt;
</span></span><span style=display:flex><span>                            //  &lt;MCOperand Imm:0&gt;&gt;
</span></span></code></pre></div><p>One of the most powerful features of QBDI compared to other DBIs is the ability
to specify the conditions under which we want an instrumentation callback.
This means that the overhead associated with the DBI&rsquo;s context switch and the
callback only occur when the specified condition is met. In our context,
we don&rsquo;t want to pay the overhead for every instruction.
Rather, we only want a &ldquo;hook&rdquo; for comparison operations. To achieve this, we can use
the <a href=https://github.com/QBDI/QBDI/blob/34bf7e47ec90d825a320a3dd3479c1d6494358af/include/QBDI/VM.h#L459-L473><code>addMnemonicCB</code></a>
function or more efficiently, using the LLVM opcode:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>dbi<span style=color:#666>-&gt;</span>addOpcodeCB(llvm<span style=color:#666>::</span>AArch64<span style=color:#666>::</span>SUBSWri, InstPosition<span style=color:#666>::</span>PREINST,
</span></span><span style=display:flex><span>  [] (VM<span style=color:#666>*</span> dbi, GPRState<span style=color:#666>*</span> gpr, FPRState<span style=color:#666>*</span>, <span style=color:#b00040>void</span><span style=color:#666>*</span>) {
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// [...]
</span></span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> VMAction<span style=color:#666>::</span>CONTINUE;
</span></span><span style=display:flex><span>  }, <span style=color:#408080;font-style:italic>/*data=*/</span><span style=color:green;font-weight:700>nullptr</span>);
</span></span></code></pre></div><p>This callback is triggered before any <code>cmp w[0-29], #cst</code> instruction. Ideally,
we would like to call <code>__sanitizer_cov_trace_const_cmp4</code> with the values coming from
the DBI. Something like:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-cpp data-lang=cpp><span style=display:flex><span>dbi<span style=color:#666>-&gt;</span>addOpcodeCB(llvm<span style=color:#666>::</span>AArch64<span style=color:#666>::</span>SUBSWri, InstPosition<span style=color:#666>::</span>PREINST,
</span></span><span style=display:flex><span>  [] (VM<span style=color:#666>*</span> dbi, GPRState<span style=color:#666>*</span> gpr, FPRState<span style=color:#666>*</span>, <span style=color:#b00040>void</span><span style=color:#666>*</span>) {
</span></span><span style=display:flex;background-color:#e5e5e5><span>    __sanitizer_cov_trace_const_cmp4(inst.operands[<span style=color:#666>0</span>], inst.operands[<span style=color:#666>1</span>]);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> VMAction<span style=color:#666>::</span>CONTINUE;
</span></span><span style=display:flex><span>  }, <span style=color:#408080;font-style:italic>/*data=*/</span><span style=color:green;font-weight:700>nullptr</span>);
</span></span></code></pre></div><p>This would work but <code>__sanitizer_cov_trace_const_cmp4</code> is computing PC with a macro
that we can&rsquo;t control. Therefore, one solution consists of replicating the implementation of
<code>__sanitizer_cov_trace_const_cmp4</code>:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-diff data-lang=diff><span style=display:flex><span>dbi-&gt;addOpcodeCB(llvm::AArch64::SUBSWri, InstPosition::PREINST,
</span></span><span style=display:flex><span>  [] (VM* dbi, GPRState* gpr, FPRState*, void*) {
</span></span><span style=display:flex><span><span style=color:#a00000>-   __sanitizer_cov_trace_const_cmp4(inst.operands[0], inst.operands[1]);
</span></span></span><span style=display:flex><span><span style=color:#00a000>+   const llvm::MCInst* inst = dbi-&gt;getOriginalMCInst();
</span></span></span><span style=display:flex><span><span style=color:#00a000>+   const size_t regw_idx = inst-&gt;getOperand(1).getReg() - llvm::AArch64::W0;
</span></span></span><span style=display:flex><span><span style=color:#00a000>+   const uintptr_t cst = inst-&gt;getOperand(2).getImm();
</span></span></span><span style=display:flex><span><span style=color:#00a000>+   const auto* gpr_ptr = reinterpret_cast&lt;const uintptr_t*&gt;(gpr);
</span></span></span><span style=display:flex;background-color:#e5e5e5><span><span style=color:#00a000>+   fuzzer::TPC.HandleCmp&lt;uint32_t&gt;(gpr-&gt;pc, cst, gpr_ptr[regw_idx]);
</span></span></span><span style=display:flex><span>    return VMAction::CONTINUE;
</span></span><span style=display:flex><span>  }, /*data=*/nullptr);
</span></span></code></pre></div><p>Et voilà. We now provide comparison feedback to LibFuzzer.
As you can see in this screenshot, libFuzzer can efficiently identify the <code>QBDI!</code> input
in less than 10 seconds.</p><center><figure><img class=lightense data-lightense-background=#fff src=/post/25-04-windows-arm64-qbdi-fuzzing/img/fuzzing-qbdi.webp alt="Fuzzing with QBDI feedback"><br><figcaption>Fuzzing with QBDI feedback</figure></figure><br></center><h2 id=the-hidden-bits>The Hidden Bits</h2><p>The attentive reader may have noticed significant simplifications regarding some
technical aspects discussed in this blog post. For example, in the section on
<a href=#basic-block-coverage>Basic Block Coverage</a> I reference a function <code>to_index</code>
which is intended to convert a basic block&rsquo;s start address into a bitmap index:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-cpp data-lang=cpp><span style=display:flex><span>dbi.addVMEventCB(VMEvent<span style=color:#666>::</span>BASIC_BLOCK_ENTRY,
</span></span><span style=display:flex><span>  [] (VM<span style=color:#666>*</span> vm, <span style=color:green;font-weight:700>const</span> VMState<span style=color:#666>*</span> state, GPRState<span style=color:#666>*</span> gpr, FPRState<span style=color:#666>*</span> fpr, <span style=color:#b00040>void</span><span style=color:#666>*</span> ctx) {
</span></span><span style=display:flex;background-color:#e5e5e5><span>    size_t bitmap_idx <span style=color:#666>=</span> to_index(state<span style=color:#666>-&gt;</span>basicBlockStart);
</span></span><span style=display:flex><span>    BITMAP[bitmap_idx] <span style=color:#666>+=</span> <span style=color:#666>1</span>;
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> VMAction<span style=color:#666>::</span>CONTINUE;
</span></span><span style=display:flex><span>  });
</span></span></code></pre></div><p>Theoretically, this code could work if we establish a unique mapping between the
address of the basic block and the bitmap index (essentially, a bijection).
Additionally, this approach operates under the assumption that we have a
bitmap of unlimited size, as we cannot predict in advance how many basic blocks
will be reached by the DBI.
In practice, fulfilling these two conditions is quite challenging.
This topic is also examined in <a href=https://security.googleblog.com/2020/12/how-atheris-python-fuzzer-works.html>Google&rsquo;s Atheris blog post</a><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>
which has been a source of inspiration for this blog post.
You can review the actual implementation I used in the GitHub repository associated
with this blog post: <a href=https://github.com/romainthomas/windows-arm64-qbdi-fuzzing><i class="fa-brands fa-github"></i> romainthomas/windows-arm64-qbdi-fuzzing</a></p><p>When it comes to QBDI, I simplified the process by stating that we only need to
instantiate a <code>QBDI::VM</code> object:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:green;font-weight:700>extern</span> <span style=color:#ba2121>&#34;C&#34;</span> <span style=color:#b00040>int</span> LLVMFuzzerTestOneInput(<span style=color:green;font-weight:700>const</span> <span style=color:#b00040>uint8_t</span> <span style=color:#666>*</span>data, size_t size) {
</span></span><span style=display:flex><span>  QBDI<span style=color:#666>::</span>VM dbi;
</span></span><span style=display:flex><span>  dbi.addInstrumentedModuleFromAddr((uintptr_t)<span style=color:#666>&amp;</span>fuzzme);
</span></span><span style=display:flex><span>  [...]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This approach works well, but it doesn&rsquo;t use a key optimization feature of QBDI:
instrumented basic block caching. Essentially, QBDI caches instrumented basic
blocks so that when we re-execute a known basic block, we don&rsquo;t need to patch
and instrument it again.</p><p>To take advantage of this optimization, we can store the <code>QBDI::VM</code> object in a
static variable and initialize it just once. This allows us to leverage the
caching mechanism effectively:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#666>::</span>unique_ptr<span style=color:#666>&lt;</span>QBDI<span style=color:#666>::</span>VM<span style=color:#666>&gt;</span> get_dbi() {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>auto</span> dbi <span style=color:#666>=</span> std<span style=color:#666>::</span>make_unique<span style=color:#666>&lt;</span>QBDI<span style=color:#666>::</span>VM<span style=color:#666>&gt;</span>();
</span></span><span style=display:flex><span>  dbi<span style=color:#666>-&gt;</span>addInstrumentedModuleFromAddr((uintptr_t)<span style=color:#666>&amp;</span>fuzzme);
</span></span><span style=display:flex><span>  [...]
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>return</span> dbi;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>extern</span> <span style=color:#ba2121>&#34;C&#34;</span> <span style=color:#b00040>int</span> LLVMFuzzerTestOneInput(<span style=color:green;font-weight:700>const</span> <span style=color:#b00040>uint8_t</span> <span style=color:#666>*</span>data, size_t size) {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>static</span> std<span style=color:#666>::</span>unique_ptr<span style=color:#666>&lt;</span>QBDI<span style=color:#666>::</span>VM<span style=color:#666>&gt;</span> DBI <span style=color:#666>=</span> get_dbi();
</span></span><span style=display:flex><span>  [...]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=final-words>Final Words</h2><p>This blog post does not bring anything new in terms of fuzzing techniques,
but it demonstrates that:</p><ol><li>QBDI is able to run and instrument Windows ARM64 code</li><li>LLVM LibFuzzer works effectively on Windows ARM64.</li><li>QBDI and LibFuzzer can work together to fuzz binaries without built-in
coverage instrumentation (i.e. closed source)</li><li>LLVM excels in different areas from compilation<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>,
DBI (QBDI), reverse-engineering, and fuzzing &#x2764;&#xfe0f;</li></ol><p>The source code and the binaries used in this blog post are available on GitHub at this address:
<a href=https://github.com/romainthomas/windows-arm64-qbdi-fuzzing><i class="fa-brands fa-github"></i> romainthomas/windows-arm64-qbdi-fuzzing</a></p><p>Happy Fuzzing</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://llvm.org/docs/LibFuzzer.html>https://llvm.org/docs/LibFuzzer.html</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Don&rsquo;t be confused by the name <code>VM</code>, we are talking about dynamic
instrumentation, not emulation.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://security.googleblog.com/2020/12/how-atheris-python-fuzzer-works.html>https://security.googleblog.com/2020/12/how-atheris-python-fuzzer-works.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><strong>all</strong> the compilation and link steps in this blog post are cross-compiled from Linux for Windows ARM64.
This includes the (cross)compilation of QBDI and LLVM for Windows ARM64.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></div></div></div></div></main><script src=/vendor/bootstrap/dist/js/bootstrap.min.js></script><script src=/vendor/headroom.js/dist/headroom.min.js></script><script src=/vendor/onscreen/dist/on-screen.umd.min.js></script><script src=/vendor/jarallax/dist/jarallax.min.js></script><script src=/vendor/smooth-scroll/dist/smooth-scroll.polyfills.min.js></script><script src=/js/theme.bundle.js></script><script src=/vendor/@glidejs/glide/dist/glide.min.js></script><script src=/js/anime.min.js></script><script src=/js/svg-pan-zoom.min.js></script><script src=/js/lightense.min.js></script><script>window.addEventListener("load",function(){Lightense(".lightense")},!1)</script></body></html>